<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AdvancedTerrainTutorialHtml" xml:space="preserve">
    <value>&lt;h1 id="Advanced_Terrain_Creation"&gt;Advanced Terrain Creation&lt;/h1&gt;
&lt;div class="embedded image" title="Mmm, landscape :3"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/Rjwoq2s.png" alt="Mmm, landscape :3" /&gt;&lt;span class="caption"&gt;Mmm, landscape :3&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;Terrain is one of the more challenging things in GoldSrc mapping. There are many ways to make terrain, and not just with terrain generators, but by hand. It sounds complicated, but making terrain by hand is actually kind of easy if you know how to do it. I won&amp;#039;t show how to use a terrain generator, since they probably don&amp;#039;t need a guide how simple they are.&lt;br&gt;&lt;br&gt;Combining certain methods, you can get a landscape such as this:&lt;div class="embedded image" title="ts_untergrund"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="http://i.imgur.com/o7sw6Ru.png" alt="ts_untergrund" /&gt;&lt;span class="caption"&gt;ts_untergrund&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;In this tutorial I will show certain methods and how to combine them.
&lt;h2 id="Triangular_Prisms"&gt;Triangular Prisms&lt;/h2&gt;
&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/yj2q76C.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/XOETH7Y.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Let&amp;#039;s start with a method which is fairly easy to understand.&lt;br&gt;It&amp;#039;s similar to Source&amp;#039;s displacements.&lt;br&gt;&lt;br&gt;Triangular prisms (a.k.a. wedges) are a popular way of adding terrain into your map. A triangular prism is basically a 3D shape which, when looked from above, looks like a triangle.&lt;br&gt;Let&amp;#039;s see how to create terrain with triangular prisms:&lt;br&gt;&lt;br&gt;1. Create a brush like this:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/4H6LYSl.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;2. Cut it diagonally:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/yPwsgXc.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;3. Disable the Texture Lock:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/VXGLbDW.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;This is important for texturing. If you don&amp;#039;t turn it off, the textures will &amp;#039;stick&amp;#039; to the brushes and the terrain will have seams everywhere.&lt;br&gt;&lt;br&gt;4. Texture the top faces:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/oU9metj.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;5. Make copies of the 2 brushes, forming a grid:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/vOyIAfM.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;This is why I told you to disable the texture lock, otherwise it would look like this:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/5OmS9x7.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;6. Manipulate the vertexes in the top view: (with the Vertex Manipulation tool, of course)&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/zlnIAoo.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Now you can select the middle vertices and in the front or side view, you can pull them down. You can either nudge them with the arrow keys, or click and drag them.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/XkDG7G6.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div class="embed-panel card card-info"&gt;&lt;div class="card-header"&gt;Hint&lt;/div&gt;&lt;div class="card-body"&gt;Sometimes, you&amp;#039;ll end up with this:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/1JM1dXn.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;The triangle seems to be too &amp;quot;thin&amp;quot;. Usually, you can retriangulate the part by either deleting the few brushes and aligning them, or you can rotate them by 90° and align the vertices:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/ADk2JWr.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
What&amp;#039;s after 6th step has two variations:&lt;br&gt; &lt;br&gt;&lt;strong&gt;Variant 1&lt;/strong&gt;&lt;br&gt;&lt;br&gt;7. Now let&amp;#039;s do the walls.&lt;br&gt;Repeat the same process, and make it like this:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/MMWRVoD.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;8. Raise the vertexes upwards:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/VWjkjDb.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;strong&gt;Variant 2&lt;/strong&gt;&lt;br&gt;&lt;br&gt;7. Create a wall and cut it like this:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/AxZIVin.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;8. Copy it and align it to the floor:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/ObHXQ1v.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;9. Copy it vertically:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/zaWiUAt.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;10. Do the same for the other side:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/Asbwge3.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;11. Give it a shape:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/vnExcEk.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;This was done by selecting a line of vertices in the front view, and then I pushed them away from the centre.&lt;br&gt;&lt;br&gt;12. Simply apply the textures, and give the shape some more variation:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/TuXkBAZ.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;div class="embed-panel card card-success"&gt;&lt;div class="card-header"&gt;Tip&lt;/div&gt;&lt;div class="card-body"&gt;When some faces are stretched like this:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/xNorKOX.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Open the Texture Application tool, select the faces, and tick &lt;strong&gt;World&lt;/strong&gt;:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/SRbhdlI.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;If some faces don&amp;#039;t align properly like here:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/D6B0xNT.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Then pick one face that aligned correctly:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/CS8C5ZL.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Press &lt;strong&gt;Shift+F6&lt;/strong&gt;:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/vCYpcsG.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;And left-click the other faces which should&amp;#039;ve &lt;em&gt;obeyed&lt;/em&gt;, so you can force their orientation:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/9ToqR1D.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Sometimes, setting it to &lt;strong&gt;World&lt;/strong&gt; won&amp;#039;t work, so you&amp;#039;ll have to set the &amp;quot;parent&amp;quot; face to &lt;strong&gt;Face&lt;/strong&gt;.&lt;/div&gt;&lt;/div&gt;
Final step:&lt;br&gt;Press &lt;strong&gt;Alt+P&lt;/strong&gt;.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/ejj9sjr.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;This will usually happen to some faces that are invisible in-game. &lt;br&gt;It&amp;#039;s usually caused by vertex manipulation, and sometimes improper usage of the texturing tool.
&lt;div class="embed-panel card card-info"&gt;&lt;div class="card-header"&gt;Texture axis perpendicular to face&lt;/div&gt;&lt;div class="card-body"&gt;Here&amp;#039;s a quick explanation of it.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/WDDZTE3.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;The white frames represent the projection planes, and the arrows represent the normals. This is perfectly fine. If the face is parallel to the projection plane, it&amp;#039;s not stretched.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/41MUDNg.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;In this scenario, we rotate the projection plane by 90° and thus it becomes perpendicular to the face. Actually, the projection was copied from the top face. This causes infinite stretching and a &amp;quot;Bad surface extents&amp;quot; error when compiling, as well as the &amp;quot;Texture axis perpendicular to face&amp;quot; error in the map editor.&lt;/div&gt;&lt;/div&gt;
You should not make the cliffs too detailed, otherwise you&amp;#039;ll hit the clipnode limit pretty quickly (32 767). There are 3 clipnodes generated per face, so be careful.&lt;br&gt;Alternatively, you can use the -nohull2 parameter in CSG, so you&amp;#039;ll end up saving a third of your clipnodes.&lt;br&gt;Basically, hull2 is for big monsters. Counter-Strike 1.6 doesn&amp;#039;t have any monsters except the hostages.&lt;br&gt;&lt;br&gt;This method can have a few tricks. If you&amp;#039;ve followed Variant 2 of this method, then you can do this:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/6VcmCNr.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;You can essentially use your triangular prisms for not just the wall, but also the floor which is on that wall.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/CVftqws.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;With some smoothing, triangular prism terrain like this is surely a delight.
&lt;h2 id="Tetrahedra"&gt;Tetrahedra&lt;/h2&gt;
While this method is very messy for the 2D views, it&amp;#039;s really useful in a lot of situations.&lt;br&gt;Let&amp;#039;s see how to create tetrahedrons and how to make something with them.&lt;br&gt;&lt;br&gt;1. Create a cube and cut it diagonally:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/DjZliFT.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;2. Pull these 3 vertices up:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/7CPLkhZ.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/H9y32OX.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;3. Apply a texture, disable &lt;em&gt;texture locking&lt;/em&gt;, and clone the tetrahedron pair:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/sprWoyS.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;You&amp;#039;ll mostly use the 3 top vertices. Those vertices will define that visible, textured face you see in-game.&lt;br&gt;But there&amp;#039;s a 4th one. (highlighted in red)&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/HlhE5Cx.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Consider it as a &amp;quot;root&amp;quot; vertice. If the root vertice is sticking out like this:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/5s7vta7.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;... then it&amp;#039;s concave. It&amp;#039;s simply inside-out. So you should always look out for this.&lt;br&gt;&lt;br&gt;Now, when do we sometimes use tetrahedra instead of prisms?&lt;br&gt;With tetrahedra, it&amp;#039;s impossible to get the &amp;quot;face not planar&amp;quot; error.&lt;br&gt;A tetrahedron is made of triangles, while a triangular prism is made out of two triangles, and three squares.&lt;br&gt;Those squares&amp;#039; planes get bent if you&amp;#039;re not careful:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/yuJ6VrB.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;You could triangulate it via Ctrl+F, but it could lead to problems later on since it&amp;#039;s not easily reversible.&lt;br&gt;&lt;br&gt;4. Clone it into walls and the ceiling:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/prWlKC9.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;5. Shape it like a cave with the VM tool:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/nbMEDbe.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/3E2683h.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;6. Copy the segments and twist it a bit more:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/ZmP58b4.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/hzZYVjy.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;As you can see, there are 512 brushes.&lt;br&gt;In theory, that should be 1536 clipnodes (1024 with -nohull2). This is why you have to be careful with such terrain.&lt;br&gt;&lt;br&gt;And another reason is VIS. It can take VIS a LONG time to process a map of this complexity.&lt;br&gt;&lt;br&gt;We could&amp;#039;ve used regular, old wedges for this part, but it wouldn&amp;#039;t be ideal for the following part.&lt;br&gt;&lt;br&gt;7. Copy the whole part and rotate it 90°:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/0zusJPF.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;8. Copy a few segments and align the vertices in the top view:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/CxPVmB5.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;These vertices are now aligned on the XY plane, but now we need to align them vertically as well.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/PwuiW10.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Now you can polish the brushwork a little bit, and texture it.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/F2Xa6B3.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h2 id="Cave_entrance/exit_(combining_tetrahedra_and_triangular_prisms)"&gt;Cave entrance/exit (combining tetrahedra and triangular prisms)&lt;/h2&gt;
In this example, we&amp;#039;ll use a cliff made out of triangular prisms, and a cave made out of tetrahedra.&lt;br&gt;&lt;br&gt;1. Start off by preparing the cliff and cave mesh&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/dXaTHbU.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/YWltisB.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;(note: never do it this detailed, it&amp;#039;s just for the sake of this example)&lt;br&gt;&lt;br&gt;One end is on the bottom, and the other end is on the top.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/QTZ060u.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;2. Go to one of the ends, hide everything except this:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/8DeFmZj.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;3. &amp;quot;Open&amp;quot; the wall with the VM tool (without deleting any brushes)&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/ZT2nuaf.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;That step is usually done by selecting one half of the brushes (e.g. left half) and dragging the vertices, effectively un-welding them.&lt;br&gt;&lt;br&gt;Since the cave mesh end is about 256 units away from the wall, we should copy it a couple of times otherwise there would be stretching.&lt;br&gt;&lt;br&gt;4. Copy the cave segments close to the wall&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/mU6oPAu.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;To quickly connect the two segments, mirror this one horizontally.&lt;br&gt;&lt;br&gt;5. In the Vertex Manipulation tool, connect the vertices of the cave to the wall.&lt;br&gt;&lt;br&gt;For J.A.C.K. users: Select the vertices in the 3D view, and nudge them in the 2D views. If the 2D views are too messy, you can use the blue camera in the 2D views to help you. Wherever the 3D camera is at, it will show up in the 2D views. Just navigate to the point where you want to move your vertices and you&amp;#039;ll see where to move the verts in the 2D view.&lt;br&gt;For VHE users: on my end, it will always select just one vertice unless you enable auto-select IIRC, therefore I suggest you to drag a selection box in the Top view and then drag the vertices around. Sledge selects &amp;#039;bundled&amp;#039; vertices just fine like J.A.C.K.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/ovjLbve.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;.&lt;br&gt;&lt;br&gt;6. Repeat the same for the other end&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/ygMe9w7.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div class="embed-panel card card-success"&gt;&lt;div class="card-header"&gt;Potential encounters&lt;/div&gt;&lt;div class="card-body"&gt;However, it doesn&amp;#039;t look too great.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/eIoxg31.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;In this case, delete these brushes:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/b2No8aC.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Connect these:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/Kk6wGKf.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/74yI08s.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Add some brushes to cover it up (and texture it):&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/GUjcphZ.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
I told you not to do it this detailed because of a good reason:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/osvweo6.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;span style="color: #6495ed;"&gt;(0fps FTW)&lt;/span&gt;&lt;br&gt;&lt;br&gt;It&amp;#039;s a mess of wpolys. And VIS would take a lot of time if they were all world brushes. &lt;br&gt;&lt;br&gt;However, if you really want to, or have to use a lot of triangles, here&amp;#039;s a tip: scale all the textures to larger values like 4 or 8, and use a detail texture and downscale it. That way you&amp;#039;ll prevent a part of BSP subdivision, although lightmaps will be more low-res (texture scale affects lightmap scales on faces).&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/7RJtU1i.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;The cave, on the other hand, was subdivided nicely:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/nbtFeXM.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Combining tetrahedra with triangular prisms was used in ts_untergrund to make a hole going through a cliff.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/G0ry5fE.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h1 id="Toward_Gearbox-style_terrain"&gt;Toward Gearbox-style terrain&lt;/h1&gt;
&lt;em&gt;Quads 4 life!&lt;/em&gt;
&lt;h2 id="Creating_cliffs_with_a_relatively_small_number_of_brushes"&gt;Creating cliffs with a relatively small number of brushes&lt;/h2&gt;
&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/HMEPlOk.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;You start with a &amp;quot;base&amp;quot;.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/JqSR8va.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;After that, add a few big cubes and start cutting them:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/W3NMPjM.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/GOPLx8H.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Sledge has a really useful feature in its Clipping Tool. Its clipping plane can be defined by 3 points, not just 2.&lt;br&gt;Click the edges and connect each edge:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/r2Ani3R.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/kTBVKSJ.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Basically, once you select two edges, press &lt;strong&gt;Ctrl+F&lt;/strong&gt;. &lt;br&gt;&lt;br&gt;If you return to the Select mode and the lines get removed, check this:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/RdQwK1w.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;And repeat it for all of the brushes except the left-most and right-most ones:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/uVJVK5K.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Now, this is a more complex part:&lt;br&gt;&lt;br&gt;Connect the edges like this:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/YlxiCad.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;And then merge these two:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/Wqdzk0a.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;With this one:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/R7MPXKt.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Do the same for the other end.&lt;br&gt;And then select the edge vertices:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/1fUI4sH.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;And move them:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/0uQsdb3.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Lastly, make sure to do some minor corrections and then press &lt;strong&gt;Ctrl+Alt+T&lt;/strong&gt; if needed (if you end up with the &amp;quot;face not planar&amp;quot; error). If you aren&amp;#039;t using J.A.C.K., you can always select the brush with that non-planar face, and use &lt;strong&gt;Ctrl+F&lt;/strong&gt; to cut the face into 2 triangles, thus making it planar.&lt;br&gt;And then, we have the texturing part. All of the faces should have a common projection plane, so you can either turn on &amp;quot;World&amp;quot; alignment, or use the &amp;quot;Apply (all + copy axes)&amp;quot; mode.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/fJpFvko.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/Ax98YuC.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;After that, you can keep adding more geometry this way:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/QWFzKZq.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;The end result will look something like this:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/AImZd3p.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;However, there&amp;#039;s a problem:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/Z41WKwT.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/r0ygBR3.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;If you would leave these to be world brushes, the compiled map would be messy. It&amp;#039;s sort of messy as it is, but that&amp;#039;s one of the compromises with GoldSRC terrian.&lt;br&gt;This is why you should convert these brushes to &lt;span style="color: blue;"&gt;func_detail&lt;/span&gt;.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/4n7q4n9.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Don&amp;#039;t forget to cover them with CLIP brushes, of course. We&amp;#039;d rather not want too many clipnodes or funky geometry that can make other players get stuck.&lt;br&gt;You will, of course, encounter errors while trying to do this:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/eqUfxNf.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;The brush looks completely fine, but it&amp;#039;s really not fine.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/l9NDT68.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Let&amp;#039;s take a closer look:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/nu4XLvc.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;This is where we need to retriangulate our brush. It&amp;#039;s fairly simple and it&amp;#039;s done in the VM tool.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/KJlrKfO.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Make these lines:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/svZRdm1.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/dbXcPCK.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;And then merge two vertices to make the brush look like this:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/T6oXvOw.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;After that, you have to pull the middle vertice:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/jbNt9T5.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;If you scroll up, you would remember that the diagonal line was going from the bottom left to the top right corner.&lt;br&gt;So, we only need to make it the opposite.&lt;br&gt;Pull the middle vertice to the bottom-right corner:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/x61cduT.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;If you get the &amp;quot;Point off the face plane&amp;quot; error, I suggest you to move some vertices.&lt;br&gt;In the end, you&amp;#039;ll save many brushes:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/Usufimn.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;56 brushes (not counting the 2 clip brushes)&lt;br&gt;&lt;br&gt;Imagine how many brushes it would take if you did that with tetrahedrons only.&lt;br&gt;Tetrahedrons surely give you lots of freedom when you&amp;#039;re working on the shape, but that produces a lot of brushes.
&lt;h2 id="Terrain_without_the_VM_tool"&gt;Terrain without the VM tool&lt;/h2&gt;
This might be the least messiest method for the 2D views. So far, we&amp;#039;ve mainly used the Clipping tool and the Vertex Manipulation tool for the brushwork. Now let&amp;#039;s limit ourselves to not using the VM tool at all.&lt;br&gt;&lt;br&gt;Firstly, let&amp;#039;s disable the texture lock.&lt;br&gt;&lt;br&gt;Now, create a cuboid like this:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/599DlC0.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Clone it above:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/gciTMDG.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Click the cuboid multiple times in the 2D view until the skewing mode shows up:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/4fhlZef.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;And skew it a little bit. Repeat the two steps until you get to a certain height or a shape.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/UciG5Fm.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Now group this entire segment, and clone it sideways.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/cYiz0ss.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Select one segment and skew it in a different 2D view.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/UqXPeiQ.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/ypZZwMa.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Lastly, you can skew it again in the Top view.&lt;br&gt;You can easily make ground this way too.&lt;br&gt;&lt;br&gt;Just don&amp;#039;t overdetail it.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/4jyMICm.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;This takes a lot to compile and it wouldn&amp;#039;t make much of a difference compared to something more low-poly.&lt;br&gt;Effectively the same thing can always be achieved with less.
&lt;h2 id="Gearbox-style"&gt;Gearbox-style&lt;/h2&gt;
&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/fjazc9p.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;When first playing through Opposing Force, the terrain just amazed me. If you&amp;#039;re looking for the terrain style that looks so late 90&amp;#039;s, look no further. But beware, funky geometry awaits after you compile it.&lt;br&gt;&lt;br&gt;One approach to this style of terrain is via layers.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/LfYu4fg.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;First layer.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/mI1vRJN.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/NsNZWBY.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Second layer.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/xa1Ez24.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Third layer.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/VRfc8Xn.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Fourth layer.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/QwK6VEY.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Fifth layer. (optional, also it doesn&amp;#039;t have to be in this very order)&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/UpIYdpw.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Let&amp;#039;s do this on another example.&lt;br&gt;&lt;br&gt;1. Place down the floor brushes&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/7AP8vyZ.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Let&amp;#039;s give them a twist. You can either skew them with the Select tool or the Vertex Manipulation tool.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/K3y4uo4.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/IEBO9kt.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;2. Start adding the wall segments.&lt;br&gt;&lt;br&gt;If you simply started adding walls and skewing them, you&amp;#039;d get this:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/3Dvv5qV.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;It looks boring...&lt;br&gt;Start off by placing this block.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/ZEjvHoy.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Cut it and turn it into this.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/qAlTtF1.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;This is where the magic happens.&lt;br&gt;After this point, a lot of people could do something wrongly in the VM tool and get a &amp;quot;Face not planar&amp;quot; error.&lt;br&gt;However, a way to prevent it is to prepare the brush for further operations. &lt;br&gt;&lt;br&gt;Since these two are relatively simple, only 2 edges needed to be moved.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/CiafWoZ.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Now, select the following vertices and move them up:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/l1Y5uC6.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;After that, select the bottom vertices and move them sideways:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/f4MPFRz.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;We can go one step further and move the vertices in the middle.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/Blo4Hgn.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;We&amp;#039;re not finished with this wall segment yet, as it has to be complete.&lt;br&gt;You can clone one brush and keep skewing it downwards and inwards.&lt;br&gt;&lt;br&gt;In the end, you&amp;#039;ll get a rock like this:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/LKpibD8.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;You may cut the rock to later merge it into one brush. (I&amp;#039;d rather not do that, though)&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/6K4Jw72.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;At this point, you might become worried about the off-grid vertices. It won&amp;#039;t be too much of a problem. In the final phase we&amp;#039;ll convert a lot of things into func_detail and cover what&amp;#039;s needed in CLIP brushes.&lt;br&gt;&lt;br&gt;For now, let&amp;#039;s save this rock for later. It&amp;#039;s part of the 5th layer.&lt;br&gt;Let&amp;#039;s focus on the 1st layer.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/DmgGQ4L.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Remember. Always prepare the brushes:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/h8tN6Hp.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;(top view - this is to preserve facial planarity)&lt;br&gt;&lt;br&gt;That&amp;#039;s better. We&amp;#039;ll start by lowering these vertices:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/vaSSjXp.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;And then we can move the vertices to form this:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/9bYzd8b.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;For some variety, we can nudge some segments closer to the road.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/8ELOpF3.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Additionally, raise some segments:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/4VCb8Iy.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;First you do a smooth curve, then the &amp;#039;pinches&amp;#039;.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/m7cLaKx.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;You&amp;#039;ve probably noticed by now that the front view is never really used due to the mess. I&amp;#039;ve done all my vertex manipulations in the top and side view. That&amp;#039;s at least in this situation. Sometimes you won&amp;#039;t use the top view, sometimes you won&amp;#039;t use the side view.&lt;br&gt;&lt;br&gt;We&amp;#039;ll repeat the same for the other side.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/czvFmq3.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div class="embed-panel card card-success"&gt;&lt;div class="card-header"&gt;Holes&lt;/div&gt;&lt;div class="card-body"&gt;In case you get a hole like this:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/kUxr5uq.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Extend the ground to close it, or move the cliff.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/aM8TsmT.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
I&amp;#039;m extending all the segments in order to preserve the planarity, because the ground will be slanted.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/R5EUCn8.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Now we&amp;#039;ll make a rock.&lt;br&gt;&lt;br&gt;3. Create a block, and rotate it:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/YnGI1yr.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;And just cut it up:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/11NDY3v.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/FRmHHl6.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;After some more adjustments, we get the final result.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/w2IgODV.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;4. Optimise. &lt;br&gt;&lt;br&gt;Back in the day, if you had terrain like that, you would&amp;#039;ve had to go through very long compile times. Maps compiled for hours and some took days. Even if you&amp;#039;ve got a decent PC with a fast CPU, it doesn&amp;#039;t mean you shouldn&amp;#039;t bother optimising the map. Remember, a lot of people still use (old) laptops and old desktop PCs. I&amp;#039;ve got a relatively decent PC, but before that one, I had a 2007 Fujitsu laptop.&lt;br&gt;&lt;br&gt;So, let&amp;#039;s begin.&lt;br&gt;&lt;br&gt;Since I&amp;#039;ve raised my ground in a specific way:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/4yLR2xW.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;I can do the following:&lt;br&gt;&lt;br&gt;Hide everything but the road.&lt;br&gt;Copy the road on both sides and apply the NULL texture.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/NHqo9U1.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;And align it to the cliffs while they&amp;#039;re unhidden. You can hide them again and place sky brushes.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/EaDVB7C.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Time for &lt;span style="color: blue;"&gt;func_detail&lt;/span&gt;.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/6FZTlHB.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;The ground -&amp;gt; detail level 1&lt;br&gt;The cliffs -&amp;gt; detail level 2&lt;br&gt;The rocks -&amp;gt; detail level 3&lt;br&gt;&lt;br&gt;If you&amp;#039;re familiar with BSP face clipping, this means that you can control it even further. If not, well, I&amp;#039;ll explain.&lt;br&gt;Level 1 can clip level 2 and 3, while level 2 can&amp;#039;t clip level 1, but can clip 3. Level 3 can&amp;#039;t clip level 1 and 2, but gets clipped by them.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/2U04gxm.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;If you look closely, the parts where the rock touches the cliff are cut. This is because I&amp;#039;ve set all the func_details to the same detail level (1).&lt;br&gt;&lt;br&gt;If we follow the image I posted above, however:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/mujspgT.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;You can see that we managed to save some wpoly as the rock doesn&amp;#039;t cut the cliff, and the cliff doesn&amp;#039;t cut the ground.&lt;br&gt;Additionally, to save on clipnodes, you can turn the rocks into passable func_details and add some CLIP brushes.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/prW6d5O.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Good half-morning. :v&lt;br&gt;There&amp;#039;s one thing to keep in mind, though. You can&amp;#039;t always use func_detail for all things. It will lead to huge areas being rendered at once and that means lag. It does sound hard to believe for GoldSrc, but even with a GTX 1080 Ti, the game can drop from 400fps to 40fps if certain things are going on. &lt;br&gt;So you&amp;#039;ll sometimes have to make a compromise.&lt;br&gt;&lt;br&gt;Also, if you func_detail too much terrain, it will lead to a bigger clipnode count. So be careful. Clipnodes are one of the biggest threats to terrain in GoldSrc. &lt;br&gt;You might hit the clipnode limit pretty quickly (32 767). There are 3 clipnodes generated per face (one for each hull except hull0, the visual hull), so be careful.&lt;br&gt;&lt;br&gt;Alternatively, you can use the -nohull2 parameter in CSG, so you&amp;#039;ll end up saving a third of your clipnodes.&lt;br&gt;Basically, hull2 is for big monsters. Counter-Strike 1.6 doesn&amp;#039;t have any monsters except the hostages, so compiling with -nohull2 shouldn&amp;#039;t cause any issues. Hull1 and hull3 are for standing and crouching players respectively.
&lt;h1 id="Tips_&amp;_Tricks"&gt;Tips &amp;amp; Tricks&lt;/h1&gt;

&lt;div class="embed-panel card card-info"&gt;&lt;div class="card-header"&gt;Flow&lt;/div&gt;&lt;div class="card-body"&gt;&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/SRx9PJ9.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Look at the marked brushes. There&amp;#039;s something bad.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/zjGbg54.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;This one ruins the terrain because there&amp;#039;s a noticeable line on it.&lt;br&gt;&lt;br&gt;To fix this, mirror it horizontally in the Top view:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/XuWYqz9.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;And align the vertices:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/qGVVyRy.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;This improves the flow of the terrain by a bit. It looks smoother this way and it looks more natural.&lt;/div&gt;&lt;/div&gt;

&lt;div class="embed-panel card card-info"&gt;&lt;div class="card-header"&gt;Grouping&lt;/div&gt;&lt;div class="card-body"&gt;&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/cRaXA1m.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;It&amp;#039;s a good idea to group the segments because it becomes easier to work with.&lt;br&gt;When you want to select more specific parts, just turn on Ignore Grouping and turn it off when you&amp;#039;re done.&lt;/div&gt;&lt;/div&gt;

&lt;div class="embed-panel card card-info"&gt;&lt;div class="card-header"&gt;Smoothing&lt;/div&gt;&lt;div class="card-body"&gt;&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/MeskBCd.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;This is a blocky corner.&lt;br&gt;We need smooth ones. Select these:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/J17L9Pq.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Shape them into this:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/dczC2MD.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;If you smooth every corner, you can have really nice results.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/iPoSyPy.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/Wf11MhR.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Let&amp;#039;s see how I actually did the smoothing.&lt;br&gt;We&amp;#039;ll perform this on a low-poly mesh.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/zf0qLpn.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Grab the corner vertices in the Top view and pull them:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/JTzW81p.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;If you come across this kind of segment:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/XOkk4h0.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Rotate it by 90°. In J.A.C.K. you can press Ctrl+R to rotate it 90°.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/NMd4TqZ.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;We&amp;#039;ve finished one part of the smoothing:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/DuTrRhF.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Now, make the grid smaller by one step, and start smoothing it even more:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/Z2JHgkK.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/Dytb6wi.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Now, we grab either the ceiling or the floor. Let&amp;#039;s start with the ceiling:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/L1bSXmp.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;And pull!&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/beHieNn.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Do the same with the other edges.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/Am4PpbB.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;After this, you can either do the same thing with the floor.&lt;br&gt;If you want to save time, you can just copy the finished half.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/XtkOBTx.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;And then mirror it:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/Odd80G0.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Then spend some time fine-tuning the mesh:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/x8m5giA.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;It doesn&amp;#039;t always have to be terrain, though.&lt;br&gt;&lt;br&gt;Take the bottom half:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/aIgwRBU.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;And then wrap another segment around it:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/Ur5XqCo.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;And then make a heart shape out of it:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/xtKJ9dl.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;You can decorate your indoors this way. It would surely make a nice addition.&lt;br&gt;You don&amp;#039;t necessarily need to make a heart shape. You could also shape it like a lake:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/2u16wkG.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Or maybe a ball. Anything is possible.&lt;/div&gt;&lt;/div&gt;

&lt;div class="embed-panel card card-info"&gt;&lt;div class="card-header"&gt;Blend textures and large textures&lt;/div&gt;&lt;div class="card-body"&gt;&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/SH6quAa.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;The lake up there doesn&amp;#039;t look too natural, so I decided to give it a blend texture.&lt;br&gt;I basically went up and took 3 screenshots of it.&lt;br&gt;One with the gravel texture, one with the mud texture, and the last one which is covered in water, so I know how to blend the first two.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/Z4Yvo3p.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;This is starting to look more like Source.&lt;br&gt;However, be careful with 512x512 blend textures, as you can easily make a huge WAD file, and produce more wpolys (assuming you downscaled the texture). Another limit to take into account is AllocBlock.&lt;br&gt;&lt;br&gt;Another method would be making 4 textures, 512x512 each. However, that would require a strict grid of triangular prisms, which you can only raise up and down. (actually, not entirely true)&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/v05vgtK.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Here are the source BMPs.&lt;br&gt;In a map, it would look like this:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/BuEfQYm.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;The &amp;#039;strict grid&amp;#039; I was talking about actually doesn&amp;#039;t have to be completely followed.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/4hpRZWx.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Moving vertices in the top view here will cause seams:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/sLrQOt4.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;However, since J.A.C.K. has a UV lock (sometimes doesn&amp;#039;t work as intended), this problem can be partially avoided, if we move the vertices in a single direction.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/qp26nD4.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/DpNC9wc.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;As mentioned, sometimes it does not work as intended, so I suggest you to avoid using this.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/6FVj51A.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;If you have faces that share the same texture, and share the same angle, chances are that CSG is going to merge them, like it did in this example. So, you don&amp;#039;t have to worry too much if you&amp;#039;ve got a lot of faces like those in the editor.&lt;br&gt;On the other hand, BSP cuts some of those faces. CSG merges, BSP cuts.&lt;br&gt;&lt;br&gt;Either way, out of the potential 128 wpoly or more, only about 97 faces got compiled in my case.&lt;br&gt;&lt;br&gt;If you wish to use a texture with dimensions like 1024x256, 2048x128 etc., be warned:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/9dFCsdK.png" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;In OpenGL, power-of-two textures will be rendered properly, but NPOT textures won&amp;#039;t. Instead, they will be rescaled: 1024x256 to 256x256, 2048x128 to 128x128, which will make them look horribly stretched horizontally. So yeah, 96x96 will be 64x64, 48x48 will be 32x32 etc. In Software mode they are rendered exactly as they are.&lt;/div&gt;&lt;/div&gt;

&lt;div class="embed-panel card card-info"&gt;&lt;div class="card-header"&gt;Terrain density&lt;/div&gt;&lt;div class="card-body"&gt;In most situations, you will want a constant terrain density in your map.&lt;br&gt;What does this mean, however?&lt;br&gt;&lt;br&gt;With the first method, triangular prisms, when you&amp;#039;re making that first brush, you have to define what dimensions you want to use.&lt;br&gt;Basically, I made a 64x64x16 block, and cut it into two wedges. These first two dimensions are what matter. If it&amp;#039;s 64x64, it means there will be a relatively high terrain density. If you&amp;#039;re going for a very open area, you&amp;#039;ll want something bigger (less dense) like 128x128, 256x256 or even 512x512 if it&amp;#039;s far away.&lt;br&gt;&lt;br&gt;But nothing prevents you from using a dynamic density. ts_untergrund is the prime example of that. Some parts of the terrain consist of 128x128 pieces, some are 320x224, and a lot of the parts are off the &amp;#039;strict grid&amp;#039;. This basically means that you can have detailed terrain that&amp;#039;s in the nearby playable area, and low-poly terrain in the far away area, which is sometimes good.&lt;/div&gt;&lt;/div&gt;

&lt;div class="embed-panel card card-info"&gt;&lt;div class="card-header"&gt;SOLIDHINT&lt;/div&gt;&lt;div class="card-body"&gt;Here we have a nice little cliff:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/6WhSW2W.jpg" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;From experience, we know that we will get messy cuts with terrain like this.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/WlenfiV.jpg" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;We can actually &amp;#039;tell&amp;#039; the compiler how exactly it should cut that geometry. We do that by using the SOLIDHINT tool texture.&lt;br&gt;So, after we replace the backfaces with SOLIDHINT (typically textured with NULL or BEVEL), we&amp;#039;re gonna get this:&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://i.imgur.com/Ju2mh4E.jpg" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;In this scenario, it decreased the wpolys by roughly 40%. Your mileage may vary, but it&amp;#039;ll certainly be significant.&lt;/div&gt;&lt;/div&gt;

&lt;h1 id="In_the_end"&gt;In the end&lt;/h1&gt;
I hope this helped you out at least a bit on terrain in GoldSrc.&lt;br&gt;It&amp;#039;s one of those things that I was fascinated with, when I started mapping. &lt;br&gt;You could expect me to write a part 2 of this tutorial one day. The first part already took long enough and it&amp;#039;s long enough by itself. The next part will focus on certain situations and some extra things I haven&amp;#039;t mentioned in this tutorial.&lt;br&gt;&lt;br&gt;Just remember, watch your r_speeds and keep your compile times reasonable. You can always make it look better with less.&lt;br&gt;&lt;br&gt;You can find source files (JMF &amp;amp; WAD) &lt;a href="https://twhl.info/vault/view/6398"&gt;here&lt;/a&gt;.&lt;br&gt;&lt;br&gt;&lt;span style="color: orange;font-size: 20px;"&gt;Happy mapping!&lt;/span&gt; - sincerely, Admer456</value>
  </data>
  <data name="AdvancedTerrainTutorialInput" xml:space="preserve">
    <value>[cat:Goldsource Tutorials]
[cat:Tutorials]
[cat:Intermediate Tutorials]
[cat:Mapping]

= Advanced Terrain Creation

[img:https://i.imgur.com/Rjwoq2s.png|Mmm, landscape :3]

Terrain is one of the more challenging things in GoldSrc mapping. There are many ways to make terrain, and not just with terrain generators, but by hand. It sounds complicated, but making terrain by hand is actually kind of easy if you know how to do it. I won't show how to use a terrain generator, since they probably don't need a guide how simple they are.

Combining certain methods, you can get a landscape such as this:

[img:http://i.imgur.com/o7sw6Ru.png|ts_untergrund]

In this tutorial I will show certain methods and how to combine them.

== Triangular Prisms

[img]https://i.imgur.com/yj2q76C.png[/img]

[img]https://i.imgur.com/XOETH7Y.png[/img]

Let's start with a method which is fairly easy to understand.
It's similar to Source's displacements.

Triangular prisms (a.k.a. wedges) are a popular way of adding terrain into your map. A triangular prism is basically a 3D shape which, when looked from above, looks like a triangle.
Let's see how to create terrain with triangular prisms:

1. Create a brush like this:
[img]https://i.imgur.com/4H6LYSl.png[/img]

2. Cut it diagonally:
[img]https://i.imgur.com/yPwsgXc.png[/img]

3. Disable the Texture Lock:
[img]https://i.imgur.com/VXGLbDW.png[/img]

This is important for texturing. If you don't turn it off, the textures will 'stick' to the brushes and the terrain will have seams everywhere.

4. Texture the top faces:
[img]https://i.imgur.com/oU9metj.png[/img]

5. Make copies of the 2 brushes, forming a grid:
[img]https://i.imgur.com/vOyIAfM.png[/img]

This is why I told you to disable the texture lock, otherwise it would look like this:
[img]https://i.imgur.com/5OmS9x7.png[/img]

6. Manipulate the vertexes in the top view: (with the Vertex Manipulation tool, of course)
[img]https://i.imgur.com/zlnIAoo.png[/img]

Now you can select the middle vertices and in the front or side view, you can pull them down. You can either nudge them with the arrow keys, or click and drag them.
[img]https://i.imgur.com/XkDG7G6.png[/img]

~~~info
:Hint 
Sometimes, you'll end up with this:

[img]https://i.imgur.com/1JM1dXn.png[/img]

The triangle seems to be too "thin". Usually, you can retriangulate the part by either deleting the few brushes and aligning them, or you can rotate them by 90° and align the vertices:

[img]https://i.imgur.com/ADk2JWr.png[/img]
~~~

What's after 6th step has two variations:
 
*Variant 1*

7. Now let's do the walls.
Repeat the same process, and make it like this:

[img]https://i.imgur.com/MMWRVoD.png[/img]

8. Raise the vertexes upwards:

[img]https://i.imgur.com/VWjkjDb.png[/img]

*Variant 2*

7. Create a wall and cut it like this:

[img]https://i.imgur.com/AxZIVin.png[/img]

8. Copy it and align it to the floor:

[img]https://i.imgur.com/ObHXQ1v.png[/img]

9. Copy it vertically:

[img]https://i.imgur.com/zaWiUAt.png[/img]

10. Do the same for the other side:

[img]https://i.imgur.com/Asbwge3.png[/img]

11. Give it a shape:

[img]https://i.imgur.com/vnExcEk.png[/img]

This was done by selecting a line of vertices in the front view, and then I pushed them away from the centre.

12. Simply apply the textures, and give the shape some more variation:

[img]https://i.imgur.com/TuXkBAZ.png[/img]

---

~~~message
:Tip
When some faces are stretched like this:

[img]https://i.imgur.com/xNorKOX.png[/img]

Open the Texture Application tool, select the faces, and tick *World*:

[img]https://i.imgur.com/SRbhdlI.png[/img]

If some faces don't align properly like here:

[img]https://i.imgur.com/D6B0xNT.png[/img]

Then pick one face that aligned correctly:

[img]https://i.imgur.com/CS8C5ZL.png[/img]

Press *Shift+F6*:

[img]https://i.imgur.com/vCYpcsG.png[/img]

And left-click the other faces which should've /obeyed/, so you can force their orientation:

[img]https://i.imgur.com/9ToqR1D.png[/img]

Sometimes, setting it to *World* won't work, so you'll have to set the "parent" face to *Face*.

~~~

Final step:
Press *Alt+P*.

[img]https://i.imgur.com/ejj9sjr.png[/img]

This will usually happen to some faces that are invisible in-game. 
It's usually caused by vertex manipulation, and sometimes improper usage of the texturing tool.

~~~info
:Texture axis perpendicular to face

Here's a quick explanation of it.

[img]https://i.imgur.com/WDDZTE3.png[/img]
The white frames represent the projection planes, and the arrows represent the normals. This is perfectly fine. If the face is parallel to the projection plane, it's not stretched.

[img]https://i.imgur.com/41MUDNg.png[/img]
In this scenario, we rotate the projection plane by 90° and thus it becomes perpendicular to the face. Actually, the projection was copied from the top face. This causes infinite stretching and a "Bad surface extents" error when compiling, as well as the "Texture axis perpendicular to face" error in the map editor. 

~~~

You should not make the cliffs too detailed, otherwise you'll hit the clipnode limit pretty quickly (32 767). There are 3 clipnodes generated per face, so be careful.
Alternatively, you can use the -nohull2 parameter in CSG, so you'll end up saving a third of your clipnodes.
Basically, hull2 is for big monsters. Counter-Strike 1.6 doesn't have any monsters except the hostages.

This method can have a few tricks. If you've followed Variant 2 of this method, then you can do this:

[img]https://i.imgur.com/6VcmCNr.png[/img]

You can essentially use your triangular prisms for not just the wall, but also the floor which is on that wall.

[img]https://i.imgur.com/CVftqws.png[/img]

With some smoothing, triangular prism terrain like this is surely a delight.

== Tetrahedra

While this method is very messy for the 2D views, it's really useful in a lot of situations.
Let's see how to create tetrahedrons and how to make something with them.

1. Create a cube and cut it diagonally:

[img]https://i.imgur.com/DjZliFT.png[/img]

2. Pull these 3 vertices up:

[img]https://i.imgur.com/7CPLkhZ.png[/img]
[img]https://i.imgur.com/H9y32OX.png[/img]

3. Apply a texture, disable /texture locking/, and clone the tetrahedron pair:

[img]https://i.imgur.com/sprWoyS.png[/img]

You'll mostly use the 3 top vertices. Those vertices will define that visible, textured face you see in-game.
But there's a 4th one. (highlighted in red)

[img]https://i.imgur.com/HlhE5Cx.png[/img]

Consider it as a "root" vertice. If the root vertice is sticking out like this:

[img]https://i.imgur.com/5s7vta7.png[/img]

... then it's concave. It's simply inside-out. So you should always look out for this.

Now, when do we sometimes use tetrahedra instead of prisms?
With tetrahedra, it's impossible to get the "face not planar" error.
A tetrahedron is made of triangles, while a triangular prism is made out of two triangles, and three squares.
Those squares' planes get bent if you're not careful:

[img]https://i.imgur.com/yuJ6VrB.png[/img]
You could triangulate it via Ctrl+F, but it could lead to problems later on since it's not easily reversible.


4. Clone it into walls and the ceiling:

[img]https://i.imgur.com/prWlKC9.png[/img]

5. Shape it like a cave with the VM tool:

[img]https://i.imgur.com/nbMEDbe.png[/img]

[img]https://i.imgur.com/3E2683h.png[/img]

6. Copy the segments and twist it a bit more:

[img]https://i.imgur.com/ZmP58b4.png[/img]

[img]https://i.imgur.com/hzZYVjy.png[/img]

As you can see, there are 512 brushes.
In theory, that should be 1536 clipnodes (1024 with -nohull2). This is why you have to be careful with such terrain.

And another reason is VIS. It can take VIS a LONG time to process a map of this complexity.

We could've used regular, old wedges for this part, but it wouldn't be ideal for the following part.

7. Copy the whole part and rotate it 90°:

[img]https://i.imgur.com/0zusJPF.png[/img]

8. Copy a few segments and align the vertices in the top view:

[img]https://i.imgur.com/CxPVmB5.png[/img]

These vertices are now aligned on the XY plane, but now we need to align them vertically as well.

[img]https://i.imgur.com/PwuiW10.png[/img]

Now you can polish the brushwork a little bit, and texture it.

[img]https://i.imgur.com/F2Xa6B3.png[/img]

== Cave entrance/exit (combining tetrahedra and triangular prisms)

In this example, we'll use a cliff made out of triangular prisms, and a cave made out of tetrahedra.

1. Start off by preparing the cliff and cave mesh
[img]https://i.imgur.com/dXaTHbU.png[/img]

[img]https://i.imgur.com/YWltisB.png[/img]

(note: never do it this detailed, it's just for the sake of this example)

One end is on the bottom, and the other end is on the top.

[img]https://i.imgur.com/QTZ060u.png[/img]

2. Go to one of the ends, hide everything except this:
[img]https://i.imgur.com/8DeFmZj.png[/img]

3. "Open" the wall with the VM tool (without deleting any brushes)
[img]https://i.imgur.com/ZT2nuaf.png[/img]
That step is usually done by selecting one half of the brushes (e.g. left half) and dragging the vertices, effectively un-welding them.

Since the cave mesh end is about 256 units away from the wall, we should copy it a couple of times otherwise there would be stretching.

4. Copy the cave segments close to the wall
[img]https://i.imgur.com/mU6oPAu.png[/img]

To quickly connect the two segments, mirror this one horizontally.

5. In the Vertex Manipulation tool, connect the vertices of the cave to the wall.

For J.A.C.K. users: Select the vertices in the 3D view, and nudge them in the 2D views. If the 2D views are too messy, you can use the blue camera in the 2D views to help you. Wherever the 3D camera is at, it will show up in the 2D views. Just navigate to the point where you want to move your vertices and you'll see where to move the verts in the 2D view.
For VHE users: on my end, it will always select just one vertice unless you enable auto-select IIRC, therefore I suggest you to drag a selection box in the Top view and then drag the vertices around. Sledge selects 'bundled' vertices just fine like J.A.C.K.

[img]https://i.imgur.com/ovjLbve.png[/img].

6. Repeat the same for the other end
[img]https://i.imgur.com/ygMe9w7.png[/img]

~~~message
:Potential encounters
However, it doesn't look too great.
[img]https://i.imgur.com/eIoxg31.png[/img]

In this case, delete these brushes:
[img]https://i.imgur.com/b2No8aC.png[/img]

Connect these:
[img]https://i.imgur.com/Kk6wGKf.png[/img]
[img]https://i.imgur.com/74yI08s.png[/img]

Add some brushes to cover it up (and texture it):
[img]https://i.imgur.com/GUjcphZ.png[/img]
~~~

I told you not to do it this detailed because of a good reason:
[img]https://i.imgur.com/osvweo6.png[/img]
[font color=#6495ed](0fps FTW)[/font]

It's a mess of wpolys. And VIS would take a lot of time if they were all world brushes. 

However, if you really want to, or have to use a lot of triangles, here's a tip: scale all the textures to larger values like 4 or 8, and use a detail texture and downscale it. That way you'll prevent a part of BSP subdivision, although lightmaps will be more low-res (texture scale affects lightmap scales on faces).
[img]https://i.imgur.com/7RJtU1i.png[/img]

The cave, on the other hand, was subdivided nicely:
[img]https://i.imgur.com/nbtFeXM.png[/img]

Combining tetrahedra with triangular prisms was used in ts_untergrund to make a hole going through a cliff.
[img]https://i.imgur.com/G0ry5fE.png[/img]

= Toward Gearbox-style terrain
/Quads 4 life!/

== Creating cliffs with a relatively small number of brushes

[img]https://i.imgur.com/HMEPlOk.png[/img]
You start with a "base".

[img]https://i.imgur.com/JqSR8va.png[/img]

After that, add a few big cubes and start cutting them:

[img]https://i.imgur.com/W3NMPjM.png[/img]

[img]https://i.imgur.com/GOPLx8H.png[/img]

Sledge has a really useful feature in its Clipping Tool. Its clipping plane can be defined by 3 points, not just 2.
Click the edges and connect each edge:

[img]https://i.imgur.com/r2Ani3R.png[/img]
[img]https://i.imgur.com/kTBVKSJ.png[/img]

Basically, once you select two edges, press *Ctrl+F*. 

If you return to the Select mode and the lines get removed, check this:
[img]https://i.imgur.com/RdQwK1w.png[/img]

And repeat it for all of the brushes except the left-most and right-most ones:
[img]https://i.imgur.com/uVJVK5K.png[/img]

Now, this is a more complex part:

Connect the edges like this:

[img]https://i.imgur.com/YlxiCad.png[/img]

And then merge these two:
[img]https://i.imgur.com/Wqdzk0a.png[/img]

With this one:
[img]https://i.imgur.com/R7MPXKt.png[/img]

Do the same for the other end.
And then select the edge vertices:
[img]https://i.imgur.com/1fUI4sH.png[/img]

And move them:
[img]https://i.imgur.com/0uQsdb3.png[/img]

Lastly, make sure to do some minor corrections and then press *Ctrl+Alt+T* if needed (if you end up with the "face not planar" error). If you aren't using J.A.C.K., you can always select the brush with that non-planar face, and use *Ctrl+F* to cut the face into 2 triangles, thus making it planar.
And then, we have the texturing part. All of the faces should have a common projection plane, so you can either turn on "World" alignment, or use the "Apply (all + copy axes)" mode.

[img]https://i.imgur.com/fJpFvko.png[/img]
[img]https://i.imgur.com/Ax98YuC.png[/img]

After that, you can keep adding more geometry this way:

[img]https://i.imgur.com/QWFzKZq.png[/img]

The end result will look something like this:

[img]https://i.imgur.com/AImZd3p.png[/img]

However, there's a problem:

[img]https://i.imgur.com/Z41WKwT.png[/img]
[img]https://i.imgur.com/r0ygBR3.png[/img]

If you would leave these to be world brushes, the compiled map would be messy. It's sort of messy as it is, but that's one of the compromises with GoldSRC terrian.
This is why you should convert these brushes to [font=blue]func_detail[/font].

[img]https://i.imgur.com/4n7q4n9.png[/img]

Don't forget to cover them with CLIP brushes, of course. We'd rather not want too many clipnodes or funky geometry that can make other players get stuck.
You will, of course, encounter errors while trying to do this:

[img]https://i.imgur.com/eqUfxNf.png[/img]

The brush looks completely fine, but it's really not fine.

[img]https://i.imgur.com/l9NDT68.png[/img]

Let's take a closer look:

[img]https://i.imgur.com/nu4XLvc.png[/img]

This is where we need to retriangulate our brush. It's fairly simple and it's done in the VM tool.

[img]https://i.imgur.com/KJlrKfO.png[/img]

Make these lines:

[img]https://i.imgur.com/svZRdm1.png[/img]
[img]https://i.imgur.com/dbXcPCK.png[/img]

And then merge two vertices to make the brush look like this:

[img]https://i.imgur.com/T6oXvOw.png[/img]

After that, you have to pull the middle vertice:

[img]https://i.imgur.com/jbNt9T5.png[/img]

If you scroll up, you would remember that the diagonal line was going from the bottom left to the top right corner.
So, we only need to make it the opposite.
Pull the middle vertice to the bottom-right corner:

[img]https://i.imgur.com/x61cduT.png[/img]

If you get the "Point off the face plane" error, I suggest you to move some vertices.
In the end, you'll save many brushes:

[img]https://i.imgur.com/Usufimn.png[/img]
56 brushes (not counting the 2 clip brushes)

Imagine how many brushes it would take if you did that with tetrahedrons only.
Tetrahedrons surely give you lots of freedom when you're working on the shape, but that produces a lot of brushes.

== Terrain without the VM tool

This might be the least messiest method for the 2D views. So far, we've mainly used the Clipping tool and the Vertex Manipulation tool for the brushwork. Now let's limit ourselves to not using the VM tool at all.

Firstly, let's disable the texture lock.

Now, create a cuboid like this:
[img]https://i.imgur.com/599DlC0.png[/img]

Clone it above:
[img]https://i.imgur.com/gciTMDG.png[/img]

Click the cuboid multiple times in the 2D view until the skewing mode shows up:
[img]https://i.imgur.com/4fhlZef.png[/img]

And skew it a little bit. Repeat the two steps until you get to a certain height or a shape.
[img]https://i.imgur.com/UciG5Fm.png[/img]

Now group this entire segment, and clone it sideways.
[img]https://i.imgur.com/cYiz0ss.png[/img]

Select one segment and skew it in a different 2D view.
[img]https://i.imgur.com/UqXPeiQ.png[/img]
[img]https://i.imgur.com/ypZZwMa.png[/img]

Lastly, you can skew it again in the Top view.
You can easily make ground this way too.

Just don't overdetail it.
[img]https://i.imgur.com/4jyMICm.png[/img]
This takes a lot to compile and it wouldn't make much of a difference compared to something more low-poly.
Effectively the same thing can always be achieved with less.

== Gearbox-style

[img]https://i.imgur.com/fjazc9p.png[/img]

When first playing through Opposing Force, the terrain just amazed me. If you're looking for the terrain style that looks so late 90's, look no further. But beware, funky geometry awaits after you compile it.

One approach to this style of terrain is via layers.

[img]https://i.imgur.com/LfYu4fg.png[/img]
First layer.

[img]https://i.imgur.com/mI1vRJN.png[/img]
[img]https://i.imgur.com/NsNZWBY.png[/img]
Second layer.

[img]https://i.imgur.com/xa1Ez24.png[/img]
Third layer.

[img]https://i.imgur.com/VRfc8Xn.png[/img]
Fourth layer.

[img]https://i.imgur.com/QwK6VEY.png[/img]
Fifth layer. (optional, also it doesn't have to be in this very order)

[img]https://i.imgur.com/UpIYdpw.png[/img]

Let's do this on another example.

1. Place down the floor brushes
[img]https://i.imgur.com/7AP8vyZ.png[/img]

Let's give them a twist. You can either skew them with the Select tool or the Vertex Manipulation tool.
[img]https://i.imgur.com/K3y4uo4.png[/img]
[img]https://i.imgur.com/IEBO9kt.png[/img]

2. Start adding the wall segments.

If you simply started adding walls and skewing them, you'd get this:

[img]https://i.imgur.com/3Dvv5qV.png[/img]

It looks boring...
Start off by placing this block.

[img]https://i.imgur.com/ZEjvHoy.png[/img]

Cut it and turn it into this.

[img]https://i.imgur.com/qAlTtF1.png[/img]

This is where the magic happens.
After this point, a lot of people could do something wrongly in the VM tool and get a "Face not planar" error.
However, a way to prevent it is to prepare the brush for further operations. 

Since these two are relatively simple, only 2 edges needed to be moved.

[img]https://i.imgur.com/CiafWoZ.png[/img]

Now, select the following vertices and move them up:

[img]https://i.imgur.com/l1Y5uC6.png[/img]

After that, select the bottom vertices and move them sideways:

[img]https://i.imgur.com/f4MPFRz.png[/img]

We can go one step further and move the vertices in the middle.

[img]https://i.imgur.com/Blo4Hgn.png[/img]

We're not finished with this wall segment yet, as it has to be complete.
You can clone one brush and keep skewing it downwards and inwards.

In the end, you'll get a rock like this:
[img]https://i.imgur.com/LKpibD8.png[/img]

You may cut the rock to later merge it into one brush. (I'd rather not do that, though)
[img]https://i.imgur.com/6K4Jw72.png[/img]

At this point, you might become worried about the off-grid vertices. It won't be too much of a problem. In the final phase we'll convert a lot of things into func_detail and cover what's needed in CLIP brushes.

For now, let's save this rock for later. It's part of the 5th layer.
Let's focus on the 1st layer.

[img]https://i.imgur.com/DmgGQ4L.png[/img]

Remember. Always prepare the brushes:
[img]https://i.imgur.com/h8tN6Hp.png[/img]
(top view - this is to preserve facial planarity)

That's better. We'll start by lowering these vertices:
[img]https://i.imgur.com/vaSSjXp.png[/img]

And then we can move the vertices to form this:
[img]https://i.imgur.com/9bYzd8b.png[/img]

For some variety, we can nudge some segments closer to the road.
[img]https://i.imgur.com/8ELOpF3.png[/img]

Additionally, raise some segments:
[img]https://i.imgur.com/4VCb8Iy.png[/img]

First you do a smooth curve, then the 'pinches'.
[img]https://i.imgur.com/m7cLaKx.png[/img]

You've probably noticed by now that the front view is never really used due to the mess. I've done all my vertex manipulations in the top and side view. That's at least in this situation. Sometimes you won't use the top view, sometimes you won't use the side view.

We'll repeat the same for the other side.
[img]https://i.imgur.com/czvFmq3.png[/img]

~~~message
:Holes

In case you get a hole like this:
[img]https://i.imgur.com/kUxr5uq.png[/img]

Extend the ground to close it, or move the cliff.
[img]https://i.imgur.com/aM8TsmT.png[/img]
~~~

I'm extending all the segments in order to preserve the planarity, because the ground will be slanted.
[img]https://i.imgur.com/R5EUCn8.png[/img]

Now we'll make a rock.

3. Create a block, and rotate it:
[img]https://i.imgur.com/YnGI1yr.png[/img]

And just cut it up:
[img]https://i.imgur.com/11NDY3v.png[/img]
[img]https://i.imgur.com/FRmHHl6.png[/img]

After some more adjustments, we get the final result.
[img]https://i.imgur.com/w2IgODV.png[/img]

4. Optimise. 

Back in the day, if you had terrain like that, you would've had to go through very long compile times. Maps compiled for hours and some took days. Even if you've got a decent PC with a fast CPU, it doesn't mean you shouldn't bother optimising the map. Remember, a lot of people still use (old) laptops and old desktop PCs. I've got a relatively decent PC, but before that one, I had a 2007 Fujitsu laptop.

So, let's begin.

Since I've raised my ground in a specific way:
[img]https://i.imgur.com/4yLR2xW.png[/img]

I can do the following:

Hide everything but the road.
Copy the road on both sides and apply the NULL texture.
[img]https://i.imgur.com/NHqo9U1.png[/img]

And align it to the cliffs while they're unhidden. You can hide them again and place sky brushes.
[img]https://i.imgur.com/EaDVB7C.png[/img]

Time for [font color=blue]func_detail[/font].

[img]https://i.imgur.com/6FZTlHB.png[/img]

The ground -&gt; detail level 1
The cliffs -&gt; detail level 2
The rocks -&gt; detail level 3

If you're familiar with BSP face clipping, this means that you can control it even further. If not, well, I'll explain.
Level 1 can clip level 2 and 3, while level 2 can't clip level 1, but can clip 3. Level 3 can't clip level 1 and 2, but gets clipped by them.
[img]https://i.imgur.com/2U04gxm.png[/img]

If you look closely, the parts where the rock touches the cliff are cut. This is because I've set all the func_details to the same detail level (1).

If we follow the image I posted above, however:
[img]https://i.imgur.com/mujspgT.png[/img]

You can see that we managed to save some wpoly as the rock doesn't cut the cliff, and the cliff doesn't cut the ground.
Additionally, to save on clipnodes, you can turn the rocks into passable func_details and add some CLIP brushes.

[img]https://i.imgur.com/prW6d5O.png[/img]

Good half-morning. :v
There's one thing to keep in mind, though. You can't always use func_detail for all things. It will lead to huge areas being rendered at once and that means lag. It does sound hard to believe for GoldSrc, but even with a GTX 1080 Ti, the game can drop from 400fps to 40fps if certain things are going on. 
So you'll sometimes have to make a compromise.

Also, if you func_detail too much terrain, it will lead to a bigger clipnode count. So be careful. Clipnodes are one of the biggest threats to terrain in GoldSrc. 
You might hit the clipnode limit pretty quickly (32 767). There are 3 clipnodes generated per face (one for each hull except hull0, the visual hull), so be careful.

Alternatively, you can use the -nohull2 parameter in CSG, so you'll end up saving a third of your clipnodes.
Basically, hull2 is for big monsters. Counter-Strike 1.6 doesn't have any monsters except the hostages, so compiling with -nohull2 shouldn't cause any issues. Hull1 and hull3 are for standing and crouching players respectively.

= Tips &amp; Tricks

~~~info
:Flow

[img]https://i.imgur.com/SRx9PJ9.png[/img]
Look at the marked brushes. There's something bad.

[img]https://i.imgur.com/zjGbg54.png[/img]
This one ruins the terrain because there's a noticeable line on it.

To fix this, mirror it horizontally in the Top view:
[img]https://i.imgur.com/XuWYqz9.png[/img]

And align the vertices:
[img]https://i.imgur.com/qGVVyRy.png[/img]

This improves the flow of the terrain by a bit. It looks smoother this way and it looks more natural.
~~~

~~~info
:Grouping

[img]https://i.imgur.com/cRaXA1m.png[/img]
It's a good idea to group the segments because it becomes easier to work with.
When you want to select more specific parts, just turn on Ignore Grouping and turn it off when you're done.
~~~

~~~info
:Smoothing

[img]https://i.imgur.com/MeskBCd.png[/img]
This is a blocky corner.
We need smooth ones. Select these:

[img]https://i.imgur.com/J17L9Pq.png[/img]

Shape them into this:

[img]https://i.imgur.com/dczC2MD.png[/img]

If you smooth every corner, you can have really nice results.

[img]https://i.imgur.com/iPoSyPy.png[/img]
[img]https://i.imgur.com/Wf11MhR.png[/img]

Let's see how I actually did the smoothing.
We'll perform this on a low-poly mesh.

[img]https://i.imgur.com/zf0qLpn.png[/img]

Grab the corner vertices in the Top view and pull them:
[img]https://i.imgur.com/JTzW81p.png[/img]

If you come across this kind of segment:
[img]https://i.imgur.com/XOkk4h0.png[/img]

Rotate it by 90°. In J.A.C.K. you can press Ctrl+R to rotate it 90°.
[img]https://i.imgur.com/NMd4TqZ.png[/img]


We've finished one part of the smoothing:
[img]https://i.imgur.com/DuTrRhF.png[/img]

Now, make the grid smaller by one step, and start smoothing it even more:
[img]https://i.imgur.com/Z2JHgkK.png[/img]
[img]https://i.imgur.com/Dytb6wi.png[/img]

Now, we grab either the ceiling or the floor. Let's start with the ceiling:
[img]https://i.imgur.com/L1bSXmp.png[/img]

And pull!
[img]https://i.imgur.com/beHieNn.png[/img]

Do the same with the other edges.
[img]https://i.imgur.com/Am4PpbB.png[/img]

After this, you can either do the same thing with the floor.
If you want to save time, you can just copy the finished half.
[img]https://i.imgur.com/XtkOBTx.png[/img]

And then mirror it:
[img]https://i.imgur.com/Odd80G0.png[/img]

Then spend some time fine-tuning the mesh:
[img]https://i.imgur.com/x8m5giA.png[/img]

It doesn't always have to be terrain, though.

Take the bottom half:
[img]https://i.imgur.com/aIgwRBU.png[/img]

And then wrap another segment around it:
[img]https://i.imgur.com/Ur5XqCo.png[/img]

And then make a heart shape out of it:
[img]https://i.imgur.com/xtKJ9dl.png[/img]

You can decorate your indoors this way. It would surely make a nice addition.
You don't necessarily need to make a heart shape. You could also shape it like a lake:
[img]https://i.imgur.com/2u16wkG.png[/img]

Or maybe a ball. Anything is possible.
~~~

~~~info
:Blend textures and large textures

[img]https://i.imgur.com/SH6quAa.png[/img]

The lake up there doesn't look too natural, so I decided to give it a blend texture.
I basically went up and took 3 screenshots of it.
One with the gravel texture, one with the mud texture, and the last one which is covered in water, so I know how to blend the first two.

[img]https://i.imgur.com/Z4Yvo3p.png[/img]

This is starting to look more like Source.
However, be careful with 512x512 blend textures, as you can easily make a huge WAD file, and produce more wpolys (assuming you downscaled the texture). Another limit to take into account is AllocBlock.

Another method would be making 4 textures, 512x512 each. However, that would require a strict grid of triangular prisms, which you can only raise up and down. (actually, not entirely true)

[img]https://i.imgur.com/v05vgtK.png[/img]

Here are the source BMPs.
In a map, it would look like this:
[img]https://i.imgur.com/BuEfQYm.png[/img]

The 'strict grid' I was talking about actually doesn't have to be completely followed.
[img]https://i.imgur.com/4hpRZWx.png[/img]

Moving vertices in the top view here will cause seams:
[img]https://i.imgur.com/sLrQOt4.png[/img]

However, since J.A.C.K. has a UV lock (sometimes doesn't work as intended), this problem can be partially avoided, if we move the vertices in a single direction.
[img]https://i.imgur.com/qp26nD4.png[/img]
[img]https://i.imgur.com/DpNC9wc.png[/img]

As mentioned, sometimes it does not work as intended, so I suggest you to avoid using this.

[img]https://i.imgur.com/6FVj51A.png[/img]
If you have faces that share the same texture, and share the same angle, chances are that CSG is going to merge them, like it did in this example. So, you don't have to worry too much if you've got a lot of faces like those in the editor. 
On the other hand, BSP cuts some of those faces. CSG merges, BSP cuts. 

Either way, out of the potential 128 wpoly or more, only about 97 faces got compiled in my case.

If you wish to use a texture with dimensions like 1024x256, 2048x128 etc., be warned:
[img]https://i.imgur.com/9dFCsdK.png[/img]

In OpenGL, power-of-two textures will be rendered properly, but NPOT textures won't. Instead, they will be rescaled: 1024x256 to 256x256, 2048x128 to 128x128, which will make them look horribly stretched horizontally. So yeah, 96x96 will be 64x64, 48x48 will be 32x32 etc. In Software mode they are rendered exactly as they are.
~~~

~~~info
:Terrain density

In most situations, you will want a constant terrain density in your map.
What does this mean, however?

With the first method, triangular prisms, when you're making that first brush, you have to define what dimensions you want to use.
Basically, I made a 64x64x16 block, and cut it into two wedges. These first two dimensions are what matter. If it's 64x64, it means there will be a relatively high terrain density. If you're going for a very open area, you'll want something bigger (less dense) like 128x128, 256x256 or even 512x512 if it's far away.

But nothing prevents you from using a dynamic density. ts_untergrund is the prime example of that. Some parts of the terrain consist of 128x128 pieces, some are 320x224, and a lot of the parts are off the 'strict grid'. This basically means that you can have detailed terrain that's in the nearby playable area, and low-poly terrain in the far away area, which is sometimes good.
~~~

~~~info
:SOLIDHINT

Here we have a nice little cliff:
[img:https://i.imgur.com/6WhSW2W.jpg]

From experience, we know that we will get messy cuts with terrain like this.
[img:https://i.imgur.com/WlenfiV.jpg]

We can actually 'tell' the compiler how exactly it should cut that geometry. We do that by using the SOLIDHINT tool texture.
So, after we replace the backfaces with SOLIDHINT (typically textured with NULL or BEVEL), we're gonna get this:
[img:https://i.imgur.com/Ju2mh4E.jpg] 

In this scenario, it decreased the wpolys by roughly 40%. Your mileage may vary, but it'll certainly be significant.
~~~

= In the end

I hope this helped you out at least a bit on terrain in GoldSrc.
It's one of those things that I was fascinated with, when I started mapping. 
You could expect me to write a part 2 of this tutorial one day. The first part already took long enough and it's long enough by itself. The next part will focus on certain situations and some extra things I haven't mentioned in this tutorial.

Just remember, watch your r_speeds and keep your compile times reasonable. You can always make it look better with less.

You can find source files (JMF &amp; WAD) [https://twhl.info/vault/view/6398|here].

[font color=orange size=20]Happy mapping![/font] - sincerely, Admer456</value>
  </data>
  <data name="LightTutorialHtml" xml:space="preserve">
    <value>Some of the basics of lighting were covered in &lt;a href="https://twhl.info/wiki/page/Tutorial%3A_In_the_Beginning_Part_4"&gt;In the Beginning Part 4: Basic Lighting&lt;/a&gt; but people are still asking questions about lighting and texlights. So this tutorial is going to cover the basics and some more advanced stuff to help you get some good lighting in your maps.&lt;br&gt;&lt;br&gt;&lt;span style="color: blue;"&gt;Note&lt;/span&gt;: The value of any tutorial is in direct proportion to the effort YOU put into learning the material. If you just read it without trying out the examples and exercises on your own, in a map you make just to play around, you will not get the visual feedback, particularly in this &amp;quot;Light&amp;quot; tutorial, that will make you a better mapper.&lt;br&gt;&lt;br&gt;This tutorial was developed using WorldCraft/Hammer 3.4 and 3.5. Some of the screenshots may not look exactly like your editor, but the descriptions of the editor menus, entity properties, etc., should give you the information you need. It is also a good idea to get the latest .fgd file and include it in your Configuration Menu. Currently, for HL, that is version 3.0.0.1. While we are on the subject I also recommend using Zoners Half Life Tools 2.5.3 custom Build 1.7. If fact, you&amp;#039;ll have to have those tools to do everything described in this tutorial.
&lt;h2 id="Light_entity"&gt;Light entity&lt;/h2&gt;
Let&amp;#039;s start with the humble light entity:&lt;div class="embedded image" title="Light, glorious light!"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://twhl.info/wiki/embed/light_1.jpg" alt="Light, glorious light!" /&gt;&lt;span class="caption"&gt;Light, glorious light!&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;Build a simple box 512 x 512 x 256, hollow it and apply a some texture to the walls. To place a &lt;span style="color: purple;"&gt;Light&lt;/span&gt; in your map, Select the &lt;span style="color: #e97000;"&gt;Entity Tool&lt;/span&gt; [Shift+E] or click on the Entity Tool button (it looks like a rounded-top mushroom) and choose &lt;span style="color: purple;"&gt;light&lt;/span&gt; from the drop down list in the &lt;span style="color: #e97000;"&gt;Object Bar&lt;/span&gt;. [If you haven&amp;#039;t got an Object Bar like the one on the right hand side of the picture above, go to &lt;span style="color: #e97000;"&gt;View&lt;/span&gt; then &lt;span style="color: #e97000;"&gt;Screen Elements&lt;/span&gt; and select the Object Bar.] Ok, now place the axe-like cursor over the top (x/y) 2D view, near the center of the room and Left Click, then Right Click and select Create Object. If you have selected the light from the drop down list, then you should be the proud owner of a light entity. Now select the info_player_start entity from the entity, place it in your map and &amp;quot;create&amp;quot; it. Compile your map by using F9 and using the &lt;span style="color: #e97000;"&gt;Normal&lt;/span&gt; Mode. Make sure that all the compiling options are checked at Normal. Hammer &amp;#039;Normal&amp;#039; compile has a habit of defaulting it&amp;#039;s Run VIS and Run RAD setting to &lt;span style="color: blue;"&gt;No&lt;/span&gt;, so make sure they are checked. You should have something like this:&lt;div class="embedded image" title="Lights On"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://twhl.info/wiki/embed/light_3.jpg" alt="Lights On" /&gt;&lt;span class="caption"&gt;Lights On&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;span style="color: blue;"&gt;NOTE&lt;/span&gt;: If you don&amp;#039;t have something like this then, there is possibly something wrong with your map. Check the error log as the most common problem for new mappers is a LEAK. If you have a LEAK, your map will default to &amp;#039;Fullbright&amp;#039; and look as though it is totally lit without shadow. Fix the leak and compile again. If it isn&amp;#039;t a LEAK, have a look at where your light entity and info_player_start entities are. Are they both inside the map? Can you see both of them inside the box? Sometimes you can place a light inside a thick wall and the compile program will behave as though it is there but you will get a totally dark map. The first thing I am going to look are the &lt;span style="color: red;"&gt;Properties&lt;/span&gt; of the light. Select the light you have created by Left Clicking on it in one of the views. In the 3D view, it will appear as a light bulb. In the 2D views, it will be a small colored square. When you select it, it will go &lt;span style="color: blue;"&gt;Red&lt;/span&gt; with little white handles. Now Right Click on the light and select &lt;span style="color: #e97000;"&gt;Properties&lt;/span&gt; from the dropdown menu. You should have something like this:&lt;div class="embedded image" title="Get used to this window. It&amp;#039;ll be your new best friend!"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://twhl.info/wiki/embed/light_2.jpg" alt="Get used to this window. It&amp;#039;ll be your new best friend!" /&gt;&lt;span class="caption"&gt;Get used to this window. It&amp;#039;ll be your new best friend!&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h3 id="Properties"&gt;Properties&lt;/h3&gt;

&lt;h4 id="Target"&gt;Target&lt;/h4&gt;
This property really is only useful for a light_spot entity (see below). A light entity shines light in all directions and having a target makes no difference to the lighting. If you are using the light to target an &lt;span style="color: purple;"&gt;info_target&lt;/span&gt;, then enter the info_target&amp;#039;s name here. More on that later...
&lt;h4 id="Name"&gt;Name&lt;/h4&gt;
If you&amp;#039;re not going to switch your light on and off or give it a Custom Appearance, leave this blank. If you want to turn your light &amp;#039;on&amp;#039; and &amp;#039;off,&amp;#039; or if you want to give it a Custom Appearance, then you will need to give it a name. This name will be the &lt;span style="color: red;"&gt;target&lt;/span&gt; in the Properties of the device you are using to switch the light. E.g., the &lt;span style="color: red;"&gt;target&lt;/span&gt; of a &lt;span style="color: purple;"&gt;func_button&lt;/span&gt; or a &lt;span style="color: purple;"&gt;trigger_once&lt;/span&gt;. Here&amp;#039;s the rub: if you give a light without a Custom Appearance a name so you can switch it on and off, it will have a Normal Appearance no matter what type of Appearance style you have selected. Have I got you confused yet? See the section on Switching Lights and Texlights below.
&lt;h4 id="Brightness"&gt;Brightness&lt;/h4&gt;
Brightness is comprised of &lt;span style="color: blue;"&gt;4&lt;/span&gt; numbers. The default is 255 255 128 200. The first three numbers are the coresponding Red, Green and Blue (RGB) pallete scales, the fourth number is the luminosity, or the actual brightness of the light. To make a light brighter or darker, you need to change that 4th number. The Default is &lt;span style="color: blue;"&gt;200&lt;/span&gt;. You can use the Pick Color button to select the color and luminosity if you prefer that to editing the numbers. The ratio of the 3 RGB values to one another, not the actual numbers themselves, is what determines the color of the light. For instance, RGB values of 200 0 200 and 100 0 100 will both appear purple. Values of 200 200 0 and 100 100 0 will both appear yellow(ish). The size of the color numbers also affects the luminosity of the light. RGB values of 200 200 200 contribute a brightness of 200. Using the values in the previous paragraph, a light with a Brightness property setting of 200 0 200 255 will appear to be about twice as bright as a light with values of 100 0 100 255. Although I&amp;#039;ve used examples of RGB and brightness values in the range of 0 to 255, you can use much larger numbers if you&amp;#039;d like. A Brightness property of 1000 0 1000 255 will just be a very bright purple light. However, to help you keep track of the colors and brightnesses of lights relative to one another, just use RGB values in the range of 0 to 255 and vary the luminosity (the 4th number) to suit your needs. If you want a really bright purple light, use 255 0 255 1000 instead. &lt;span style="color: blue;"&gt;Note&lt;/span&gt;: A light with a Brightness value of &amp;quot;0 0 0 0&amp;quot; will actually appear as a light of color &amp;quot;255 255 255&amp;quot; with a mid level brightness. So if you chose this to make a really dark room, then you now know why it didn&amp;#039;t work.
&lt;h4 id="Appearance"&gt;Appearance&lt;/h4&gt;
&lt;em&gt;This property applies only if your light does not have a name. Remember?&lt;/em&gt; You can change the appearance of your light to one of the 11 different types listed below:
&lt;ul&gt;&lt;li&gt;&lt;span style="color: red;"&gt;Normal&lt;/span&gt;: A steady light of the chosen color.&lt;/li&gt;&lt;li&gt;&lt;span style="color: red;"&gt;Fluorescent Flicker&lt;/span&gt;: Alternates the light between &amp;#039;off&amp;#039; and &amp;#039;on&amp;#039; in a random timed sequence.&lt;/li&gt;&lt;li&gt;&lt;span style="color: red;"&gt;Slow,strong pulse&lt;/span&gt;: Goes from fully light to dark and back again slowly.&lt;/li&gt;&lt;li&gt;&lt;span style="color: red;"&gt;Slow pulse,noblack&lt;/span&gt;: Same as above, but it doesn&amp;#039;t go totally dark.. although that is a matter of perception.&lt;/li&gt;&lt;li&gt;&lt;span style="color: red;"&gt;Gentle pulse&lt;/span&gt;: Not quite as harsh as the above &amp;quot;pulses.&amp;quot;&lt;/li&gt;&lt;li&gt;&lt;span style="color: red;"&gt;Flicker A&lt;/span&gt;: a short quick flicker, but only changing the light level slightly.&lt;/li&gt;&lt;li&gt;&lt;span style="color: red;"&gt;Flicker B&lt;/span&gt;: a slightly quicker flicker.&lt;/li&gt;&lt;li&gt;&lt;span style="color: red;"&gt;Candle A&lt;/span&gt;: Nothing like a candle.. Sort of erratic pulse to black and then a few bright pulses.&lt;/li&gt;&lt;li&gt;&lt;span style="color: red;"&gt;Candle B&lt;/span&gt;: Two &amp;#039;on&amp;#039;,&amp;#039;off&amp;#039; pulses then a fade to bright.&lt;/li&gt;&lt;li&gt;&lt;span style="color: red;"&gt;Candle C&lt;/span&gt;: Three &amp;#039;on&amp;#039;,&amp;#039;off&amp;#039; pulses and a bit of Candle &amp;#039;A&amp;#039; and &amp;#039;B&amp;#039; thrown in for good measure.&lt;/li&gt;&lt;li&gt;&lt;span style="color: red;"&gt;Fast Strobe&lt;/span&gt;: Exactly what it says... &amp;#039;on and &amp;#039;off&amp;#039; quickly.&lt;/li&gt;&lt;li&gt;&lt;span style="color: red;"&gt;Slow Strobe&lt;/span&gt;: A slower version of the Fast Strobe, no surprises there.&lt;/li&gt;&lt;/ul&gt;

&lt;h4 id="Custom_Appearance"&gt;Custom Appearance&lt;/h4&gt;
Used for designing your own custom effect or to give a named light an appearance other than Normal. If you want to design your own light effect, you need to give the light a &lt;span style="color: red;"&gt;Name&lt;/span&gt;. The brightness will vary according to the strings of letters you enter in this property. If you want, you can trigger a light with a custom appearance and toggle the light on and off. You give the light the appearance you want by specifying a string of letters (a-z) where &lt;span style="color: blue;"&gt;a&lt;/span&gt; is completely dark and &lt;span style="color: blue;"&gt;z&lt;/span&gt; is maximum brightness, the 4th number in the Brightness property. Letters in between &lt;span style="color: blue;"&gt;a&lt;/span&gt; and &lt;span style="color: blue;"&gt;z&lt;/span&gt; represent brightness levels in between. Each letter will give you about 1/10th of a second at that brightness. If you want more than a 10th of a second at that brightness, repeat the same letter. The letters do not have to go in alphabetical sequence and can be in any order that varies the light the way you want it. There is a maximum number of alpha characters you can enter of 142. So for a really slow pulse you could try: &lt;span style="color: blue;"&gt;aaaabbbbccccddddeeeeffffgggghhhhggggffffeeeeddddccccbbbbbaaaa&lt;/span&gt; and this will give you about a six second dark to bright to dark effect. Note: You can create some major funkiness by using capital letters, numbers or other characters instead of lower case letters in the custom appearance property! Since you&amp;#039;re using Zoner&amp;#039;s Half Life Tools and the most recent .fgd file (right?), you will have noticed that your light entity has a few extra values: ZHLT Fade and ZHLT Falloff. The brightness of a real point source of light in nature will decrease as the inverse square of the distance it travels. That is, the brightness at 2 meters will be 1/4 of the brightness at 1 meter. If the brightness at 1 meter is 1/(1*1) = 1, the brightness at 2 meters is 1/(2*2), or 1/4. This &amp;quot;falloff&amp;quot; of brightness, the spreading out of light from a source, looks natural to us &amp;#039;cause that&amp;#039;s, like, how nature actually works. The ZHLT Fade and Falloff properties allow us to change the way the compiler calculates the brightness of a light as it gets farther and farther from its source.
&lt;h4 id="ZHLT_Fade"&gt;ZHLT Fade&lt;/h4&gt;
If the explanation of this property makes your head hurt and you don&amp;#039;t understand it anyway, just leave it at the default of 1.0. This property applies to any light, light_environment, or light_spot entity. ZHLT Fade adds in an artificial factor into the normal (1 / dist * dist) inverse square falloff calculations, by multiplying the denominator of the scale by the fade value. That&amp;#039;s why just leaving it at 1 is okay. Individual point lights (point entities) can set their own individual fade and falloff values, which override any global setting on the command line. These fade and falloff values only affect the direct lighting layer, as the radiosity pass always uses plain inverse square falloff. The default fade value is 1.0. Numbers less than 1.0 and greater than 0 will cause the lights to illuminate objects further away. Fade values greater than 1.0 will travel less. This can have uses in making dark corners (we&amp;#039;ll get to that in the exercises below) and in texture lighting. See the discussion on texture lighting below. [&lt;span style="color: blue;"&gt;Note&lt;/span&gt;]: I played around with the falloff parameter a lot. Personally I think Zoner messed up a bit implementing this. To get a light with linear falloff to look even close to a light with inverse square, I had to jack up the fade to, like, 50-150. The parameters between the two types of falloff don&amp;#039;t appear to be consistent. In addition, brush areas that are perpendicular to a linear falloff light seemed to be illuminated inconsistently with areas at lesser angles. I&amp;#039;ve got a map that shows a brush some 1000 units away down a dark hallway lit like the sun. I included the explanation solely for consistency and kind of left the application to the student.
&lt;h4 id="ZHLT_Falloff"&gt;ZHLT Falloff&lt;/h4&gt;
You can select: Default (normally Inverse Square. [Perhaps intended to allow override by commandline switches[???]]) Inverse Linear Inverse Square This property can also be applied to any light, light_environment, or light_spot entity [test this]. This option can change the normal inverse square falloff of lighting in the direct lighting layer with inverse linear falloff. That is, instead of light falling off at a normal, more realistic 1/dist*dist rate, it will fall off more slowly, i.e., 1/dist. A light that decreases in brightness linearly instead of at an inverse square rate is like a highly collimated beam that doesn&amp;#039;t decrease in brightness because it&amp;#039;s spreading out, but because something in the air (smoke, haze) is attenuating it. This could be useful if you wanted to simulate a searchlight, a movie projector or a lighthouse beacon that has mirrors or lenses collimating the beam.
&lt;h3 id="Flags"&gt;Flags&lt;/h3&gt;
When you bring up the Properties box, you&amp;#039;ll see three tabs at the top - Class Info, Flags and Visgroup. Click on the Flags tab and you&amp;#039;ll see a bunch of (mostly untitled) checkboxes.
&lt;ul&gt;&lt;li&gt;&amp;#039;Initially dark&amp;#039; - You can check this flag if you want the light to be &amp;#039;off&amp;#039; when you start the map. Kinda useless unless you intend to give the light a name and turn it &amp;#039;on&amp;#039; with a trigger at some point.&lt;/li&gt;&lt;/ul&gt;

&lt;h3 id="Testing_it_Yourself"&gt;Testing it Yourself&lt;/h3&gt;
So far we have only covered the &lt;span style="color: purple;"&gt;light&lt;/span&gt; entities properties, I am hoping to show you how to use the thing, or this tutorial will be pretty pointless. If you haven&amp;#039;t made up a test map as described above, make one now, just for playing around. Put just an info_player_start and a light entity in a room. What we&amp;#039;ll do (actually, what you&amp;#039;ll do) is to change a property or two of the light, compile the map and look at the result of the changes. Leave the light&amp;#039;s properties all at the default values - no Name, Appearance &amp;#039;Normal&amp;#039;, no Custom Appearance.&lt;br&gt;&lt;br&gt;Compile and run the map. A room with a plain whitish light in it, right? Now bring up the properties of the light entity and change the Appearance to &amp;#039;Flourescent flicker.&amp;#039; Just for fun, change the brightness to 0 255 128 150. Compile and run it. You should now see a dimmer, flickering blue-green light. Play around with the Appearance, color and brightness to see their effects. Use the color picker to set the Brightness property numbers, if you like. If everything&amp;#039;s dark when you run the map, bump up the 4th number in the brightness property or run up the scale on the right of the color picker to make the light brighter. Depending on your monitor&amp;#039;s settings, you may need a brightness of 150 or more to see the effect.&lt;br&gt;&lt;br&gt;Now, set the Brightness and Appearance properties back to their defaults: Brightness = 255 255 128 200, and a &amp;#039;Normal&amp;#039; Appearance. Enter a Name of &amp;#039;light1&amp;#039; (without the quotation marks). If you were to compile and run the map now, you&amp;#039;ll just have the old vanilla normal light in a room thing. So click on the Custom Appearance property and enter the string abcdefghijklmnopqrstuvwxyzyxwvutsrqponmlkjihgfedcb. You can highlight the string in the tutorial, hit ctrl-C to copy it, and hit ctrl-v to paste in the Custom Appearance field. When you run it, you should get light that varies from dark to bright and back to dark over about a 5 second period (50 characters in the string at 1/10 of a second apiece). Note that once you have the Custom Appearance that you want, you can change the color and the brightness to get the overall effect you want.&lt;br&gt;&lt;br&gt;If you&amp;#039;re not interested in the ZHLT flags, more of an advanced application anyway, you can skip the next couple of exercises. Make sure your light is near the center of the room and near (but not IN) the ceiling brush. Set the Brightness of your light to 255 255 128 150 (not too bright), set Appearance to Normal, and erase anything you have in Custom Appearance. Compile it, run it and take note of how the room is illuminated. The corners of the room should be a bit darker than the center of the room. Now change the ZHLT Fade property of your light to 2.0. Compile it, run it and note that the center of the room is at just about the same brightness as before but the corners of the room are darker. If you had decreased the brightness to get dark corners instead, the center of the room would be darker also. Change the ZHLT Fade to 0.5, compile and run. Once again, the center of the room is about the same but the corners are lighter. Increasing the brightness to get light in the corners would increase the light in the center of the room as well as the corners. You don&amp;#039;t want light in the corners of a room in Half-Life, anyway! The Fade property actually does effect the light in the center of the room. But, by using the Fade property this way, you can more easily maintain the general brightness of a room consistent with other rooms in your map, while still adding some dark corners.&lt;br&gt;&lt;br&gt;Now move your light to one end of the room. Keep it near the ceiling (but not IN the ceiling brush). Change the ZHLT Fade back to 1.0 and set the ZHLT Falloff to Inverse Linear. Keep the brightness at 150. Compile and run. One bright room, huh? The light drops off much less dramatically using this setting. In fact, you&amp;#039;d have to set up a very long hallway to see much dropoff at all at a brightness of 150. In addition, this setting tends to illuminate brushes a long way off in ways that definitely do not make sense to the eye. With the room setup for this tutorial, you&amp;#039;ll probably have to drop the brightness down to 50 or less to see much affect. Even then, the far wall seems unusually bright compared to the adjacent floor.&lt;br&gt;&lt;br&gt;Enough about plain old lights. Let&amp;#039;s look at the...
&lt;h2 id="Light_spot_entity"&gt;Light_spot entity&lt;/h2&gt;
Light_spot entities, &amp;quot;spotlights,&amp;quot; are more fun that regular lights. There are more properties to play with and, in general, the lighting effects are more dramatic. So it&amp;#039;s important to understand what the various properties of a light_spot entity. A light_spot projects a cone of light, like a spotlight. Like a spotlight, a light_spot entity can be given a direction along which to point the cone or you can give it a target to aim at. [Reviewers: MORE EXPLANATION? inner angle, outer angle and a picture? ] So, let&amp;#039;s look at the &lt;strong&gt;Properties&lt;/strong&gt;. If you haven&amp;#039;t modified your fgd file, the properties for light_spot appear in a slightly different order in the Properites box than for the light entity. The order they appear in the menu is not important. You can edit your fgd file to put them in a more convenient order if you like.
&lt;h3 id="Properties_2"&gt;Properties&lt;/h3&gt;

&lt;h4 id="Name_2"&gt;Name&lt;/h4&gt;
Same as described in &amp;#039;light&amp;#039; entity above. A named light_spot can only have a Normal Appearance or a Custom Appearance but can be triggered on and off. A light_spot with a Custom Appearance must have a name.
&lt;h4 id="Target_2"&gt;Target&lt;/h4&gt;
You don&amp;#039;t have to use a target to aim the light_spot. You can set the pitch and yaw properties instead. However, if you want to set a target, like an info_target entity, for the light_spot, then, if you later need to move the light_spot around in your map, it will still be aimed at the desired spot in the map and you don&amp;#039;t have to manually readjust the direction of the light_spot. To set the target, fill in the name of the entity on which the light_spot will be centered. That entity is usually an info_target or an info_null. Place the info_target or info_null in the map where you want the center of the spot to be aimed. Give the info_target or info_null the same name that you filled in for the light_spot target. Done. &lt;span style="color: blue;"&gt;NOTE&lt;/span&gt;: Lighting is determined during compilation, not during gameplay. That means, unfortunately, that you can&amp;#039;t move the target of the light_spot and have a &amp;quot;spotlight&amp;quot; follow it. You can set the target of a light_spot to a named entity, but the light will remain centered on the spot where the entity was at the start of the map, even if the targeted entity later moves. So it can&amp;#039;t be set to follow a func_train or a monster. Bummer.
&lt;h4 id="Pitch_roll_yaw_(Y_Z_X)"&gt;Pitch roll yaw (Y Z X)&lt;/h4&gt;
Because roll has no meaning for a symetrical beam, use the Pitch and Yaw properties explained below instead. &lt;span style="color: blue;"&gt;Note&lt;/span&gt;: if the Is sky property (see below) is set to Yes, the ZHLT fade and falloff properties are ignored.
&lt;h4 id="ZHLT_fade"&gt;ZHLT fade&lt;/h4&gt;
See the discussion in the light entity properties above.
&lt;h4 id="ZHLT_falloff"&gt;ZHLT falloff&lt;/h4&gt;
See the discussion in the light entity properties above.
&lt;h4 id="Inner_(bright)_angle"&gt;Inner (bright) angle&lt;/h4&gt;
This property determines the size of the inner, uniformly lit cone. This cone forms the brighter center cone of light. Useful values for the inner angle are in the range of 15 to 90 degrees. At angles of 135 and above, it loses the affect of being a spotlight. &lt;span style="color: red;"&gt;Outer (fading) angle&lt;/span&gt;: This property determines the size of the outer, fading cone of light. From the edge of the inner angle on out to the outer angle, the light drops off from the more brightly lit center to darkness. Values for the outer angle, to keep it looking like a spotlight, are normally about 15 to 30 degrees wider than the inner angle.&lt;div class="embedded image" title="Inner and outer angles."&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://twhl.info/wiki/embed/light_bj1.jpg" alt="Inner and outer angles." /&gt;&lt;span class="caption"&gt;Inner and outer angles.&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;In this picture, the inner angle (the black circle) is 30 degrees. The outer angle is 45 and you can the fading between the outside the black circle.
&lt;h4 id="Pitch"&gt;Pitch&lt;/h4&gt;
This is the angle above or below the horizontal for the light_spot direction. Angles above the horizontal are postive (+45 points up at an angle of 45 degrees) and angles below the horizontal are negative (-90 points straight down).
&lt;h4 id="Yaw"&gt;Yaw&lt;/h4&gt;
Yaw is the compass direction for the light as viewed from directly above. You won&amp;#039;t see this property in the Smartedit list. You can set it by typing in the desired angle in the Angle box, or by dragging the little white line around in the black compass to the right of the Angle box.
&lt;h4 id="Brightness_2"&gt;Brightness&lt;/h4&gt;
See the discussion in the light entity properties above.
&lt;h4 id="Is_sky"&gt;Is sky&lt;/h4&gt;
You have a choice of No or Yes. &amp;#039;No&amp;#039; means the light_spot will cast light onto your map from where you&amp;#039;ve placed it. &amp;#039;Yes&amp;#039; means that any point on the map visible from any &amp;#039;sky&amp;#039; brush will be lit as if the light_spot were pointing directly at that spot. That is, if you set the direction of a &amp;#039;sky&amp;#039; light_spot pointing down at a 45 degree angle (pitch= -45), areas which can be seen from any sky brush will be lit as if light were coming down at a 45 degree angle. That angle will be constant throughout any &amp;#039;sky&amp;#039; illuminated areas, regardless of the location of the light_spot and regardless of where the sky texture is located. Strangely enough, when used as sky illumination, it can still be turned on and off and given a custom appearance! I don&amp;#039;t know whether that&amp;#039;s a feature or a bug. Also, if you have a window in one room with a sky texture and another window in another room with a sky texture, light will shine in both windows in the same direction. That&amp;#039;s.. pretty much.. realistic, hmm? If you want, you can set a target for the light_spot used as sky lighting. The overall lighting from the sky will then be from the direction from the light_spot to the target entity (e.g., info_null or info_target).
&lt;h4 id="Appearance_2"&gt;Appearance&lt;/h4&gt;
See the discussion in the light entity properties above.
&lt;h4 id="Custom_Appearance_2"&gt;Custom Appearance&lt;/h4&gt;
See the discussion in the light entity properties above.
&lt;h3 id="Flags_2"&gt;Flags&lt;/h3&gt;
See the discussion in the light entity properties above.&lt;br&gt;&lt;br&gt;The third light entity to discuss is the...
&lt;h2 id="Light_environment_entity"&gt;Light_environment entity&lt;/h2&gt;
The light_environment entity is used (as can the light_spot entity) to control the angle, pitch, color and brightness of any areas that are visible from sky brushes in your map, i.e., the &amp;quot;outdoors.&amp;quot; You can use other lights &amp;quot;outside,&amp;quot; also, for effect if you wish. And, like the light_spot with its Is sky property set to Yes, a light_environment can be placed anywhere in your map. It does not need to be located near a sky brush nor, for that matter, does it need to be in the &amp;quot;outdoors&amp;quot; area of your map.
&lt;h3 id="Properties_3"&gt;Properties&lt;/h3&gt;

&lt;h4 id="Name_3"&gt;Name&lt;/h4&gt;
Similar to the light and light_spot entities, you can give the light_environment entity a name. Strangely enough, considering its purpose, if you give it a name you can turn it on and off by using its name as the target for a trigger entity (e.g., func_button, trigger_once). Like the other two light entities, its default state is &amp;#039;on&amp;#039; when the map starts. Unlike the other two, it does not have an &amp;#039;Initially dark&amp;#039; flag.
&lt;h4 id="Pitch_roll_yaw_(YZX)"&gt;Pitch roll yaw (YZX)&lt;/h4&gt;
Like light_spot entity, roll isn&amp;#039;t applicable to the light_environment entity. Use Pitch and Angle to set the direction of your &amp;quot;outdoors&amp;quot; light. Note: I&amp;#039;m not sure why the fgd includes the ZHLT properties for light_environment. They are ignored.
&lt;h4 id="ZHLT_Fade_2"&gt;ZHLT Fade&lt;/h4&gt;

&lt;h4 id="ZHLT_Falloff_2"&gt;ZHLT Falloff&lt;/h4&gt;

&lt;h4 id="Pitch_2"&gt;Pitch&lt;/h4&gt;
See the discussion in the light_spot entity properties above.
&lt;h4 id="Angle"&gt;Angle&lt;/h4&gt;
See the discussion in the light_spot entity properties above.
&lt;h4 id="Brightness_3"&gt;Brightness&lt;/h4&gt;
Yes, you can set the color of your outdoor lighting. Might prove useful for early morning, late evening or xeno effects. See the discussion in the light entity properties above for setting color and brightness.
&lt;h3 id="Flags_3"&gt;Flags&lt;/h3&gt;
none
&lt;h2 id="Texture_Lighting_(Texlights)"&gt;Texture Lighting (Texlights)&lt;/h2&gt;
Having discussed the three light entities, that brings us to a discussion on the use of textures to light your map.&lt;br&gt;&lt;br&gt;Texture lighting is the use of textures to provide lighting. Once your editor has been set up to use them, basic texlights are quick and simple to apply. Texture lights, or texlights for short, can be used for lighting by themselves (quite effectively) or you can &amp;#039;group&amp;#039; them with light entities to achieve more specialized effects. The basic form of texlight is simple to use. By applying more advanced principles, you can switch texlights on and off and give them varying appearances (as described in the Appearance property in the light entity discussion above) and even custom appearances as described in Custom Appearance above).
&lt;h3 id="Setting_up_to_use_texlights"&gt;Setting up to use texlights&lt;/h3&gt;
To use texture lighting as described in this tutorial, you&amp;#039;ll need:
&lt;ul&gt;&lt;li&gt;The ZHLT Tools 2.5.3 Custom Build 1.7. These tools are recommended for general Half-Life mapping in any case.&lt;/li&gt;&lt;li&gt;A modified halflife.fgd which lets you insert the info_texlights entity into your map. If you want to use the advanced features of texlights (turning them on and off and using various appearances), the halflife.fgd file must also be modified to add &amp;#039;texlight styles&amp;#039; to at least one entity, usually &lt;span style="color: purple;"&gt;func_wall&lt;/span&gt;.&lt;/li&gt;&lt;/ul&gt;
By using the info_texlights entity, you don&amp;#039;t have to create or edit a lights.rad file. There are two big benefits from this:
&lt;ul&gt;&lt;li&gt;This allows you to change your texlight color and brightness settings without leaving the editor. If you use a lights.rad file to define your texlights, you either have to use that same lighting for every map you make or you have to edit the lights.rad file uniquely for every map.&lt;/li&gt;&lt;li&gt;By defining your texlights in an info_texlights entity in your map, those settings are applied only to that map, are included in that map if you distribute it and don&amp;#039;t affect the texture lighting in any other map. If you put your map in the TWHL map vault, you don&amp;#039;t need to upload the lights.rad file with it or include a text file describing what texture lighting you&amp;#039;ve defined in your map. It&amp;#039;s all in the info_texlights entity inserted into your map file.&lt;/li&gt;&lt;/ul&gt;

&lt;h4 id="Modifying_your_halflife.fgd_file"&gt;Modifying your halflife.fgd file&lt;/h4&gt;
&lt;span style="color: blue;"&gt;Note&lt;/span&gt;: Modifying your halflife.fgd file as described below will not affect the way any of your existing maps work. It extends the capabilities of your editor, not change them. Your halflife.fgd file can be found in the fgd subfolder under your Hammer editor folder. It&amp;#039;ll be something like C:\Program Files\Valve Hammer Editor\fgd\Half-Life\halflife.fgd.&lt;br&gt;&lt;br&gt;1. Save a copy of your existing halflife.fgd file in case you screw up.&lt;br&gt;2. Make sure Hammer is closed and open your halflife.fgd file in Notepad or some simple text editor.&lt;br&gt;3. Copy the following single line and insert it into the file anywhere. I recommend putting it right after &lt;span style="color: purple;"&gt;info_teleport_destination&lt;/span&gt; so it&amp;#039;ll appear in alphabetical order in your entities dropdown list.
&lt;pre&gt;&lt;code&gt;@PointClass color(255 128 0) = info_texlights : &amp;quot;Texture Light Config&amp;quot;&lt;/code&gt;&lt;/pre&gt;
4. If you&amp;#039;ve inserted that single line into the fgd where I recommend, check that that portion of the file looks like this:
&lt;pre&gt;&lt;code&gt;...
@PointClass size(-8 -8 0, 8 8 16) base(PlayerClass, Targetname) = info_teleport_destination : &amp;quot;Teleport destination&amp;quot;
@PointClass color(255 128 0) = info_texlights : &amp;quot;Texture Light Config&amp;quot;
...&lt;/code&gt;&lt;/pre&gt;
5. Search for the description of the &lt;span style="color: purple;"&gt;func_wall&lt;/span&gt; entity. It will look like this:
&lt;pre&gt;&lt;code&gt;@SolidClass base(Targetname, Appearflags, RenderFields, Global, ZHLT) = func_wall : &amp;quot;Wall&amp;quot; [
    _minlight(string) : &amp;quot;Minimum light level&amp;quot;
]&lt;/code&gt;&lt;/pre&gt;
6. Copy the following lines and insert them into the &lt;span style="color: purple;"&gt;func_wall&lt;/span&gt; definition so it looks as shown in step 7:
&lt;pre&gt;&lt;code&gt;style(choices) : &amp;quot;Texlight style&amp;quot; : 0 =
[
    0 : &amp;quot;Normal&amp;quot;
    -3: &amp;quot;Grouped&amp;quot;
    10: &amp;quot;Fluorescent flicker&amp;quot;
    2 : &amp;quot;Slow, strong pulse&amp;quot;
    11: &amp;quot;Slow pulse, noblack&amp;quot;
    5 : &amp;quot;Gentle pulse&amp;quot;
    1 : &amp;quot;Flicker A&amp;quot;
    6 : &amp;quot;Flicker B&amp;quot;
    3 : &amp;quot;Candle A&amp;quot;
    7 : &amp;quot;Candle B&amp;quot;
    8 : &amp;quot;Candle C&amp;quot;
    4 : &amp;quot;Fast strobe&amp;quot;
    9 : &amp;quot;Slow strobe&amp;quot;
    12: &amp;quot;Underwater&amp;quot;
]&lt;/code&gt;&lt;/pre&gt;
7. Check that the &lt;span style="color: purple;"&gt;func_wall&lt;/span&gt; definition looks like the following. Be sure it&amp;#039;s exactly like this, including all the square brackets:
&lt;pre&gt;&lt;code&gt;@SolidClass base(Targetname, Appearflags, RenderFields, Global, ZHLT) = func_wall : &amp;quot;Wall&amp;quot; [
    style(choices) : &amp;quot;Texlight style&amp;quot; : 0 =
    [
        0 : &amp;quot;Normal&amp;quot;
        -3: &amp;quot;Grouped&amp;quot;
        10: &amp;quot;Fluorescent flicker&amp;quot;
        2 : &amp;quot;Slow, strong pulse&amp;quot;
        11: &amp;quot;Slow pulse, noblack&amp;quot;
        5 : &amp;quot;Gentle pulse&amp;quot;
        1 : &amp;quot;Flicker A&amp;quot;
        6 : &amp;quot;Flicker B&amp;quot;
        3 : &amp;quot;Candle A&amp;quot;
        7 : &amp;quot;Candle B&amp;quot;
        8 : &amp;quot;Candle C&amp;quot;
        4 : &amp;quot;Fast strobe&amp;quot;
        9 : &amp;quot;Slow strobe&amp;quot;
        12: &amp;quot;Underwater&amp;quot;
    ]
    _minlight(string) : &amp;quot;Minimum light level&amp;quot;
]&lt;/code&gt;&lt;/pre&gt;
8. Save your modified halflife.fgd file back into the fgd directory of your editor.&lt;br&gt;9. Restart Hammer for the modifications to take effect.&lt;br&gt;10. Select the entity tool, drop the entity list down and check that &lt;span style="color: purple;"&gt;info_texlights&lt;/span&gt; appears somewhere in the list. If you&amp;#039;ve done it correctly, it will follow &lt;span style="color: purple;"&gt;info_teleport_destination&lt;/span&gt;.&lt;br&gt;11. Create a brush, tie it to a func_wall entity and check that Texlight style appears as a Property of the &lt;span style="color: purple;"&gt;func_wall&lt;/span&gt;. &lt;br&gt;&lt;br&gt;Now that we have a newly modified fgd to play with, let&amp;#039;s work through a quick example so you can get an idea how the info_texlights entity works.
&lt;ol&gt;&lt;li&gt;Open a New map in Hammer.&lt;/li&gt;&lt;li&gt;Browse for and select the texture &lt;span style="color: blue;"&gt;FIFTIES_WALL13&lt;/span&gt; in the &lt;span style="color: red;"&gt;Texture Bar&lt;/span&gt;.&lt;/li&gt;&lt;li&gt;Select the Block Creation tool and make a block 512w x 512l x 256h.&lt;/li&gt;&lt;li&gt;Hollow it out. 32 unit walls are fine.&lt;/li&gt;&lt;li&gt;Bring up the Texture Application tool (Shift-A) and select the downward facing face of the ceiling brush. Which brush you actually select isn&amp;#039;t real important as this is just to demonstrate a very simple texlight. But the face you choose must be facing the inside of your map.&lt;/li&gt;&lt;li&gt;In the Texture Application tool, the &lt;span style="color: blue;"&gt;FIFTIES_WALL13&lt;/span&gt; texture should be shown. Select Browse in the Texture Application tool and select the FIFTIES_WALL14V texture.&lt;/li&gt;&lt;li&gt;Click Apply and ensure that just the texture of just one brushface has changed.&lt;/li&gt;&lt;li&gt;Close the tool.&lt;/li&gt;&lt;li&gt;Insert an info_player_start entity somewhere inside your map.&lt;/li&gt;&lt;li&gt;Insert an info_texlights entity somewhere in your map. The location doesn&amp;#039;t matter as long as it&amp;#039;s inside the map somewhere.&lt;/li&gt;&lt;li&gt;Select the info_texlights entity and open up Properties.&lt;/li&gt;&lt;li&gt;Click on Smartedit to open up the Add/Delete dialog.&lt;/li&gt;&lt;li&gt;Click Add.&lt;/li&gt;&lt;li&gt;For the Key, enter FIFTIES_WALL14V.&lt;/li&gt;&lt;li&gt;For the Value, enter 255 255 128 50.&lt;/li&gt;&lt;li&gt;Close the Object Properties dialog, compile and run the map.&lt;/li&gt;&lt;li&gt;You should appear in an ugly green cinderblock room with a fairly plain lit ceiling. The light in the room is being provided by the texlight. Remember? You didn&amp;#039;t add a light entity to the room.&lt;/li&gt;&lt;/ol&gt;
What you just did is to specify in the info_texlights entity (in just that map, no other) that everywhere the FIFTIES_WALL14V texture is used, it&amp;#039;s to emit light with a Brightness of 255 255 128 50. Let&amp;#039;s get into some of the details of texture lighting. There are three basic types of texture lighting:
&lt;ul&gt;&lt;li&gt;Simple texlight (lighted texture) - a texture defined in info_texlights applied to a brush-face. Shines with a Normal appearance.&lt;/li&gt;&lt;li&gt;Texlight tied to an entity - a texture defined in info_texlights applied to a brush-face. The brush is tied to an entity (normally a func_wall). Shines with a Texlight style selected in the &lt;span style="color: purple;"&gt;func_wall&lt;/span&gt; properties.&lt;/li&gt;&lt;li&gt;Texlight grouped with a light entity - a texture defined in info_texlights applied to a brush-face. The brush is tied to an entity (normally a func_wall). A light entity is grouped with the texlight by giving both the light entity and the func_wall entity the same name. Shines with a Normal appearance or a Custom Appearance set in the light entity properties. Can be turned on and off by triggering the group name.&lt;/li&gt;&lt;/ul&gt;

&lt;h3 id="Simple_Lighted_Textures"&gt;Simple Lighted Textures&lt;/h3&gt;
If you completed the example above, you have an idea what a simple lighted texture is. It&amp;#039;s a texture applied to a brush (that doesn&amp;#039;t have to be an entity! it&amp;#039;s applied to a world brush) and defined as a light emitting texture in an info_texlights entity. That&amp;#039;s it. You can&amp;#039;t switch it on and off or give any appearance other than Normal because it&amp;#039;s not tied to an entity. It&amp;#039;s plain and simply a texture that emits light. To create a simple texlight:
&lt;ol&gt;&lt;li&gt;Insert an info_texlights into your map.&lt;/li&gt;&lt;li&gt;In the info_texlights properties, Add the name of the texture which is to be used for the texlight and the color and brightness of the light that you want the texture to emit.&lt;/li&gt;&lt;li&gt;Apply that texture to brushfaces whereever you want.&lt;/li&gt;&lt;/ol&gt;
That&amp;#039;s it. You&amp;#039;ll now have a &amp;#039;light&amp;#039; in your map with the shape of the brush faced with the texlight texture.&lt;br&gt;&lt;br&gt;&lt;span style="color: blue;"&gt;Note&lt;/span&gt;: a texlight, unlike a light entity, gives off light in proportion to the size of the texlight. If the texlight brush is small, you get a small amount of light. If you make the texlight big, it will give off more light. I suggest making the texlight the size and shape you want and then adjust the luminosity, the 4th number in the Brightness of the texture in the info_texlights list, to get the desired level of lighting. You can also increase the number of texlights to brighten the area.&lt;br&gt;&lt;br&gt;Quite a bit can be accomplished with simple texlights and they can simplify the construction of portions of your map. Rather than add multiple light entities to light a hallway, for instance, you can add texlights directly to world brush faces as shown in the picture below.&lt;div class="embedded image" title="Light with no light."&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://twhl.info/wiki/embed/light_bj2.jpg" alt="Light with no light." /&gt;&lt;span class="caption"&gt;Light with no light.&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;There are no light entities used in that map. The hallway started as a hollowed block forming the hull of the map, the ceiling was clipped to correctly sized brushes and a texlight texture (defined in an info_texlights) applied to look like flourescent lights. Quick but effective. The original Doom maps were lighted only with textures. The light areas were bright textures and the dark areas were dark textures. &amp;quot;Blinking&amp;quot; lights were really just textures with two brightnesses that were rendered alternately every few frames. The areas lit by that blinking light appeared to be lit by the blinking light only because the mapper applied a blinking texture to adjacent shaped brushes to make it look that way.&lt;br&gt;&lt;br&gt;The Hammer editor and accompanying compiler simplify life by letting you define lights and texlights and assume they emit light that casts shadows and bounces off other surfaces. Note, however, that, with just a couple of exceptions, Half-Life maps are not dynamically lighted. That is, the compiler determines lighting before the map is created. When you actually play Half-Life maps, the &amp;quot;lighting&amp;quot; you see are just textures with bright pixels where there is supposed to be light and darker pixels where there is supposed to be shadows. Differently shaded textures are rendered in a view when a light is turned on or off to make it appear that light is being cast. The few exceptions I know of are the flashlight and, perhaps, the light that an alien slave gives off when it charges up.
&lt;h3 id="Texlight_Tied_to_an_Entity"&gt;Texlight Tied to an Entity&lt;/h3&gt;
To use a texlight that has something other than a Normal (steady) light appearance, you can tie the brush to which the texlight texture has been applied to a func_wall entity. Now you can select a Texlight style in the func_wall properties and have the texlight flicker with various styles.&lt;br&gt;&lt;br&gt;To create a texlight with a Texlight style:
&lt;ol&gt;&lt;li&gt;Open the Properties of your info_texlights entity and turn off Smartedit.&lt;/li&gt;&lt;li&gt;Click Add, enter the name of the texture to be used as a texlight as the Key.&lt;/li&gt;&lt;li&gt;Enter the Brightness (3 RGB values and a luminosity number) that you want as the Value. In general, texlights need to have much greater luminosities (the 4th number) than light entities. You&amp;#039;ll have to give it a value up in the range of 250 or more, maybe up to 2000 or more, to get it to &amp;quot;shine&amp;quot; much, to cast shadows, etc.&lt;/li&gt;&lt;li&gt;Create the brush that is to be your texlight. Note: the brush you use for your texlight cannot be a hull brush. All hull brushes must be world brushes or you&amp;#039;ll have a leak in your map.&lt;/li&gt;&lt;li&gt;Tie the brush to a func_wall entity (other entities can be used if you&amp;#039;ve edited your fgd file to allow selection of Texlight styles).&lt;/li&gt;&lt;li&gt;Open the Texture Application tool and apply the texlight texture to a face of the brush.&lt;/li&gt;&lt;li&gt;Open the func_wall Properties of your brush and select a Texlight style, such as Fluorescent flicker or Underwater.&lt;/li&gt;&lt;li&gt;Compile and run your map and you&amp;#039;ve got a texlight with other than Normal style.&lt;/li&gt;&lt;/ol&gt;
This is very similar to a simple texlight, but, by tying the brush to a func_wall entity, you have the capability to select a texlight style. In addition, you can use several texlights with the same texture and set different Texlight styles for each one. For instance, a hallway can be lit by several fluorescent fixtures of the same texlight texture, but just one of them flickers.
&lt;h3 id="Texlight_Grouped_with_a_Light_Entity"&gt;Texlight Grouped with a Light Entity&lt;/h3&gt;
This application is a bit more complicated but it gives you the capability to turn your texlight on and off and/or give it a Custom Appearance. The &amp;quot;grouped&amp;quot; texlight is a texture applied to a brush and the brush is tied to an entity, most commonly a func_wall. A light entity is then added to the map and &amp;quot;grouped&amp;quot; together with the func_wall by giving both the light and the func_wall the same Name property. The texlight can now be turned on and off by triggering the group name and the texlight can be given a Custom Appearance by setting the Custom Appearance property in the light entity.&lt;br&gt;&lt;br&gt;Like the simple texlight, the texture that is to emit light is defined in the info_texlights entity with the desired color and luminosity. The principle behind this type of texlight is that the map compiler uses information from the info_texlights entity to set the Brightness of the texlight. The map compiler also uses the Name of the light entity and its Custom Appearance (if it&amp;#039;s set) to allow the texlight to be turned on and off and/or give it the Custom Appearance defined in the light entity.&lt;br&gt;&lt;br&gt;First, here&amp;#039;s how to create a grouped texlight:
&lt;ol&gt;&lt;li&gt;Open the Properties of your info_texlights entity and turn off Smartedit.&lt;/li&gt;&lt;li&gt;Click Add, enter the name of the texture to be used as a texlight as the Key.&lt;/li&gt;&lt;li&gt;Enter the Brightness (3 RGB values and a luminosity number) that you want as the Value.&lt;/li&gt;&lt;li&gt;Create the brush that is to be your texlight.&lt;/li&gt;&lt;li&gt;Tie the brush to a func_wall entity (other entities can be used if you&amp;#039;ve edited your fgd file to allow selection of Texlight styles).&lt;/li&gt;&lt;li&gt;Open the Texture Application tool and apply the texlight texture to a face of the brush. Close the Texture app tool.&lt;/li&gt;&lt;li&gt;Open the Properties of the func_wall and selected Grouped from the Texlight styles.&lt;/li&gt;&lt;li&gt;Give the func_wall a name, like &amp;#039;texlight1&amp;#039; (without the quotation marks).&lt;/li&gt;&lt;li&gt;Add a light entity to your map (anywhere). Be sure it&amp;#039;s inside the map somewhere and not outside the hull.&lt;/li&gt;&lt;li&gt;Open the Properties of the light entity and give it the same name (like &amp;#039;texlight1&amp;#039;) as the func_wall. This &amp;#039;groups&amp;#039; it with the func_wall.&lt;/li&gt;&lt;li&gt;Change the luminosity, the 4th number of the Brightness property, to something small, like 0.01 (e.g., Brightness=255 255 128 0.01).&lt;/li&gt;&lt;/ol&gt;
&lt;span style="color: blue;"&gt;Note&lt;/span&gt;: The light entity you&amp;#039;ve added will still be treated by the compiler as if it&amp;#039;s giving off light! If you want only the texlight to give off light, you have to make the light entity very dim (to the point where it isn&amp;#039;t seen). If you compile and run a map with a grouped texlight as described in the steps above, the texlight will pretty much look like a simple texlight.&lt;br&gt;&lt;br&gt;So what&amp;#039;s the point?
&lt;ul&gt;&lt;li&gt;You can set a Custom Appearance (see the Properties of the Light entity at the beginning of the tutorial) in the light entity and the texlight will take on that Custom Appearance. Note, however, that you can&amp;#039;t change the Appearance property of the light entity to achieve this, only the Custom Appearance.&lt;/li&gt;&lt;li&gt;Since the texlight and the light have a name, you can trigger the texlight on and off. If you want the texlight light to be initially dark, set the Initially dark flag in the grouped light entity.&lt;/li&gt;&lt;li&gt;You can have multiple texlights all grouped with one light entity and switch them all on and off, as you would expect to be able to do in a large room with one switch and several light fixtures. You don&amp;#039;t have to set the properties of several light entities, just one info_texlights Brightness. If you want to change the light level in an area like that, you can edit just the texture Brightness in the info_texlights list.&lt;/li&gt;&lt;li&gt;You don&amp;#039;t have to use the same texture for every texlight in a group. As long as the texture is listed in the info_texlights and the func_wall to which the texture&amp;#039;s been applied has the same group name, it will behave (have the same appearance and be turned on and off) like the rest of the group. You can give each texlight texture a different color and/or luminosity. Using a multimanager and several groups of texlights, you can create a circus lighting effect.. if you want.&lt;/li&gt;&lt;/ul&gt;

&lt;h3 id="Tips_for_Using_info_texlights"&gt;Tips for Using info_texlights&lt;/h3&gt;
As mentioned above, the advantages of using an info_texlights entity in your map are: you don&amp;#039;t have to edit or distribute a lights.rad file, and the texlights you define in one map don&amp;#039;t affect the lighting in any other map. In some cases, you may want to use the same texture as both a texlight and as a normal texture. Well, you can&amp;#039;t actually do that.&lt;br&gt;&lt;br&gt;However, you can use two textures that look identical but have different names. What I&amp;#039;ve done is to create a separate wad file and copied textures from halflife.wad (for instance) into my special wad file (using Wally) but given them a different name. For instance, I copied the texture +0~FIFTS_LGHT06 into my special wad file and gave it the name FIFTS_LGHT06x. Where I want a regular looking light fixture, I use the +0~FIFTS_LGHT06 texture. Where I want the same looking texture as a texlight, I use FIFTS_LGHT06x and define its Brightness in an info_texlights entity in my map. I added my special wad to the Textures tab I have set up in my Configuration. That ensures I have those &amp;quot;special&amp;quot; textures available when I build a map. I also added &amp;quot;-wadinclude &amp;lt;Specialwadname&amp;gt;&amp;quot; to the command line for my csg compiler (&amp;quot;Expert&amp;quot; option in the compile dialog). This results in any textures I&amp;#039;ve used from my special wad to be included directly in the bsp file.&lt;br&gt;&lt;br&gt;There are advantages and disadvantages to this setup. On the plus side, I can distribute a bsp file without hassling anyone with an extra wad file. No special instructions on where to copy an extra wad file, etc. Just load and run the bsp as you would any bsp. On the negative side, the bsp file size is increased by the size of a texture that the user already has in his/her halflife.wad file. If the texture isn&amp;#039;t too big, no big deal. If I use lots of special textures, the bsp size can be dominated by the size of the extra textures. In the neutral area, if I wanted to distribute the .rmf file, I&amp;#039;d have to include the special wad file. The info_texlights entity included in the .rmf would, however, have the Brightness for any texlights already set. There&amp;#039;d be no need to provide instructions on how to edit the user&amp;#039;s lights.rad file which, as a mapper, I would find a pain in the backside.&lt;br&gt;&lt;br&gt;I made lots and lots of test maps to prepare this tutorial. I got into the habit of inserting a func_button + info_texlights + info_player_start prefab, just to make sure I had a lit button with a defined texlight texture where I could find it in the dark. I did a lot of turning lights on and off and it didn&amp;#039;t take long to get into that habit.
&lt;h3 id="Little_Oddities"&gt;Little Oddities&lt;/h3&gt;
If you compile and run a map with a grouped texlight applied to a fairly small brush, you&amp;#039;ll notice something odd. The texlight now casts light as if it were coming from a spotlight with a 90 degree cone somewhere near the back of the texlight brush instead of taking on the shape of the texlight brush itself! That, fortunately or unfortunately, is the nature of Zoner&amp;#039;s compiler. It treats the texlight more like a light entity instead of an &amp;#039;area&amp;#039; of light-emitting texture. That feature (or bug) can be used to make a desklamp look pretty realistic as one would expect a desklamp to cast a cone of light anyway. It&amp;#039;s a little less convenient when you want to make a fluorescent fixture in a room or hallway, although, in general, it&amp;#039;s not very noticeable.</value>
  </data>
  <data name="LightTutorialInput" xml:space="preserve">
    <value>[cat:Tutorials]
[cat:Intermediate Tutorials]
[cat:Goldsource Tutorials]
[cat:Mapping]

Some of the basics of lighting were covered in [[Tutorial: In the Beginning Part 4|In the Beginning Part 4: Basic Lighting]] but people are still asking questions about lighting and texlights. So this tutorial is going to cover the basics and some more advanced stuff to help you get some good lighting in your maps.

[font=blue]Note[/font]: The value of any tutorial is in direct proportion to the effort YOU put into learning the material. If you just read it without trying out the examples and exercises on your own, in a map you make just to play around, you will not get the visual feedback, particularly in this "Light" tutorial, that will make you a better mapper.

This tutorial was developed using WorldCraft/Hammer 3.4 and 3.5. Some of the screenshots may not look exactly like your editor, but the descriptions of the editor menus, entity properties, etc., should give you the information you need. It is also a good idea to get the latest .fgd file and include it in your Configuration Menu. Currently, for HL, that is version 3.0.0.1. While we are on the subject I also recommend using Zoners Half Life Tools 2.5.3 custom Build 1.7. If fact, you'll have to have those tools to do everything described in this tutorial.

== Light entity

Let's start with the humble light entity:

[img:light_1.jpg|Light, glorious light!]

Build a simple box 512 x 512 x 256, hollow it and apply a some texture to the walls. To place a [font=purple]Light[/font] in your map, Select the [font=#e97000]Entity Tool[/font] [Shift+E] or click on the Entity Tool button (it looks like a rounded-top mushroom) and choose [font=purple]light[/font] from the drop down list in the [font=#e97000]Object Bar[/font]. [If you haven't got an Object Bar like the one on the right hand side of the picture above, go to [font=#e97000]View[/font] then [font=#e97000]Screen Elements[/font] and select the Object Bar.] Ok, now place the axe-like cursor over the top (x/y) 2D view, near the center of the room and Left Click, then Right Click and select Create Object. If you have selected the light from the drop down list, then you should be the proud owner of a light entity. Now select the info_player_start entity from the entity, place it in your map and "create" it. Compile your map by using F9 and using the [font=#e97000]Normal[/font] Mode. Make sure that all the compiling options are checked at Normal. Hammer 'Normal' compile has a habit of defaulting it's Run VIS and Run RAD setting to [font=blue]No[/font], so make sure they are checked. You should have something like this:

[img:light_3.jpg|Lights On]

[font=blue]NOTE[/font]: If you don't have something like this then, there is possibly something wrong with your map. Check the error log as the most common problem for new mappers is a LEAK. If you have a LEAK, your map will default to 'Fullbright' and look as though it is totally lit without shadow. Fix the leak and compile again. If it isn't a LEAK, have a look at where your light entity and info_player_start entities are. Are they both inside the map? Can you see both of them inside the box? Sometimes you can place a light inside a thick wall and the compile program will behave as though it is there but you will get a totally dark map. The first thing I am going to look are the [font=red]Properties[/font] of the light. Select the light you have created by Left Clicking on it in one of the views. In the 3D view, it will appear as a light bulb. In the 2D views, it will be a small colored square. When you select it, it will go [font=blue]Red[/font] with little white handles. Now Right Click on the light and select [font=#e97000]Properties[/font] from the dropdown menu. You should have something like this:

[img:light_2.jpg|Get used to this window. It'll be your new best friend!]

=== Properties 

==== Target

This property really is only useful for a light_spot entity (see below). A light entity shines light in all directions and having a target makes no difference to the lighting. If you are using the light to target an [font=purple]info_target[/font], then enter the info_target's name here. More on that later... 

==== Name

If you're not going to switch your light on and off or give it a Custom Appearance, leave this blank. If you want to turn your light 'on' and 'off,' or if you want to give it a Custom Appearance, then you will need to give it a name. This name will be the [font=red]target[/font] in the Properties of the device you are using to switch the light. E.g., the [font=red]target[/font] of a [font=purple]func_button[/font] or a [font=purple]trigger_once[/font]. Here's the rub: if you give a light without a Custom Appearance a name so you can switch it on and off, it will have a Normal Appearance no matter what type of Appearance style you have selected. Have I got you confused yet? See the section on Switching Lights and Texlights below.

==== Brightness

Brightness is comprised of [font=blue]4[/font] numbers. The default is 255 255 128 200. The first three numbers are the coresponding Red, Green and Blue (RGB) pallete scales, the fourth number is the luminosity, or the actual brightness of the light. To make a light brighter or darker, you need to change that 4th number. The Default is [font=blue]200[/font]. You can use the Pick Color button to select the color and luminosity if you prefer that to editing the numbers. The ratio of the 3 RGB values to one another, not the actual numbers themselves, is what determines the color of the light. For instance, RGB values of 200 0 200 and 100 0 100 will both appear purple. Values of 200 200 0 and 100 100 0 will both appear yellow(ish). The size of the color numbers also affects the luminosity of the light. RGB values of 200 200 200 contribute a brightness of 200. Using the values in the previous paragraph, a light with a Brightness property setting of 200 0 200 255 will appear to be about twice as bright as a light with values of 100 0 100 255. Although I've used examples of RGB and brightness values in the range of 0 to 255, you can use much larger numbers if you'd like. A Brightness property of 1000 0 1000 255 will just be a very bright purple light. However, to help you keep track of the colors and brightnesses of lights relative to one another, just use RGB values in the range of 0 to 255 and vary the luminosity (the 4th number) to suit your needs. If you want a really bright purple light, use 255 0 255 1000 instead. [font=blue]Note[/font]: A light with a Brightness value of "0 0 0 0" will actually appear as a light of color "255 255 255" with a mid level brightness. So if you chose this to make a really dark room, then you now know why it didn't work. 

==== Appearance

[i]This property applies only if your light does not have a name. Remember?[/i] You can change the appearance of your light to one of the 11 different types listed below: 

* [font=red]Normal[/font]: A steady light of the chosen color.
* [font=red]Fluorescent Flicker[/font]: Alternates the light between 'off' and 'on' in a random timed sequence.
* [font=red]Slow,strong pulse[/font]: Goes from fully light to dark and back again slowly.
* [font=red]Slow pulse,noblack[/font]: Same as above, but it doesn't go totally dark.. although that is a matter of perception.
* [font=red]Gentle pulse[/font]: Not quite as harsh as the above "pulses."
* [font=red]Flicker A[/font]: a short quick flicker, but only changing the light level slightly.
* [font=red]Flicker B[/font]: a slightly quicker flicker.
* [font=red]Candle A[/font]: Nothing like a candle.. Sort of erratic pulse to black and then a few bright pulses.
* [font=red]Candle B[/font]: Two 'on','off' pulses then a fade to bright.
* [font=red]Candle C[/font]: Three 'on','off' pulses and a bit of Candle 'A' and 'B' thrown in for good measure.
* [font=red]Fast Strobe[/font]: Exactly what it says... 'on and 'off' quickly.
* [font=red]Slow Strobe[/font]: A slower version of the Fast Strobe, no surprises there.

==== Custom Appearance

Used for designing your own custom effect or to give a named light an appearance other than Normal. If you want to design your own light effect, you need to give the light a [font=red]Name[/font]. The brightness will vary according to the strings of letters you enter in this property. If you want, you can trigger a light with a custom appearance and toggle the light on and off. You give the light the appearance you want by specifying a string of letters (a-z) where [font=blue]a[/font] is completely dark and [font=blue]z[/font] is maximum brightness, the 4th number in the Brightness property. Letters in between [font=blue]a[/font] and [font=blue]z[/font] represent brightness levels in between. Each letter will give you about 1/10th of a second at that brightness. If you want more than a 10th of a second at that brightness, repeat the same letter. The letters do not have to go in alphabetical sequence and can be in any order that varies the light the way you want it. There is a maximum number of alpha characters you can enter of 142. So for a really slow pulse you could try: [font=blue]aaaabbbbccccddddeeeeffffgggghhhhggggffffeeeeddddccccbbbbbaaaa[/font] and this will give you about a six second dark to bright to dark effect. Note: You can create some major funkiness by using capital letters, numbers or other characters instead of lower case letters in the custom appearance property! Since you're using Zoner's Half Life Tools and the most recent .fgd file (right?), you will have noticed that your light entity has a few extra values: ZHLT Fade and ZHLT Falloff. The brightness of a real point source of light in nature will decrease as the inverse square of the distance it travels. That is, the brightness at 2 meters will be 1/4 of the brightness at 1 meter. If the brightness at 1 meter is 1/(1*1) = 1, the brightness at 2 meters is 1/(2*2), or 1/4. This "falloff" of brightness, the spreading out of light from a source, looks natural to us 'cause that's, like, how nature actually works. The ZHLT Fade and Falloff properties allow us to change the way the compiler calculates the brightness of a light as it gets farther and farther from its source.

==== ZHLT Fade

If the explanation of this property makes your head hurt and you don't understand it anyway, just leave it at the default of 1.0. This property applies to any light, light_environment, or light_spot entity. ZHLT Fade adds in an artificial factor into the normal (1 / dist * dist) inverse square falloff calculations, by multiplying the denominator of the scale by the fade value. That's why just leaving it at 1 is okay. Individual point lights (point entities) can set their own individual fade and falloff values, which override any global setting on the command line. These fade and falloff values only affect the direct lighting layer, as the radiosity pass always uses plain inverse square falloff. The default fade value is 1.0. Numbers less than 1.0 and greater than 0 will cause the lights to illuminate objects further away. Fade values greater than 1.0 will travel less. This can have uses in making dark corners (we'll get to that in the exercises below) and in texture lighting. See the discussion on texture lighting below. [[font=blue]Note[/font]]: I played around with the falloff parameter a lot. Personally I think Zoner messed up a bit implementing this. To get a light with linear falloff to look even close to a light with inverse square, I had to jack up the fade to, like, 50-150. The parameters between the two types of falloff don't appear to be consistent. In addition, brush areas that are perpendicular to a linear falloff light seemed to be illuminated inconsistently with areas at lesser angles. I've got a map that shows a brush some 1000 units away down a dark hallway lit like the sun. I included the explanation solely for consistency and kind of left the application to the student. 

==== ZHLT Falloff

You can select: Default (normally Inverse Square. [Perhaps intended to allow override by commandline switches[???]]) Inverse Linear Inverse Square This property can also be applied to any light, light_environment, or light_spot entity [test this]. This option can change the normal inverse square falloff of lighting in the direct lighting layer with inverse linear falloff. That is, instead of light falling off at a normal, more realistic 1/dist*dist rate, it will fall off more slowly, i.e., 1/dist. A light that decreases in brightness linearly instead of at an inverse square rate is like a highly collimated beam that doesn't decrease in brightness because it's spreading out, but because something in the air (smoke, haze) is attenuating it. This could be useful if you wanted to simulate a searchlight, a movie projector or a lighthouse beacon that has mirrors or lenses collimating the beam. 

=== Flags

When you bring up the Properties box, you'll see three tabs at the top - Class Info, Flags and Visgroup. Click on the Flags tab and you'll see a bunch of (mostly untitled) checkboxes. 

- 'Initially dark' - You can check this flag if you want the light to be 'off' when you start the map. Kinda useless unless you intend to give the light a name and turn it 'on' with a trigger at some point.

=== Testing it Yourself

So far we have only covered the [font=purple]light[/font] entities properties, I am hoping to show you how to use the thing, or this tutorial will be pretty pointless. If you haven't made up a test map as described above, make one now, just for playing around. Put just an info_player_start and a light entity in a room. What we'll do (actually, what you'll do) is to change a property or two of the light, compile the map and look at the result of the changes. Leave the light's properties all at the default values - no Name, Appearance 'Normal', no Custom Appearance.

Compile and run the map. A room with a plain whitish light in it, right? Now bring up the properties of the light entity and change the Appearance to 'Flourescent flicker.' Just for fun, change the brightness to 0 255 128 150. Compile and run it. You should now see a dimmer, flickering blue-green light. Play around with the Appearance, color and brightness to see their effects. Use the color picker to set the Brightness property numbers, if you like. If everything's dark when you run the map, bump up the 4th number in the brightness property or run up the scale on the right of the color picker to make the light brighter. Depending on your monitor's settings, you may need a brightness of 150 or more to see the effect.

Now, set the Brightness and Appearance properties back to their defaults: Brightness = 255 255 128 200, and a 'Normal' Appearance. Enter a Name of 'light1' (without the quotation marks). If you were to compile and run the map now, you'll just have the old vanilla normal light in a room thing. So click on the Custom Appearance property and enter the string abcdefghijklmnopqrstuvwxyzyxwvutsrqponmlkjihgfedcb. You can highlight the string in the tutorial, hit ctrl-C to copy it, and hit ctrl-v to paste in the Custom Appearance field. When you run it, you should get light that varies from dark to bright and back to dark over about a 5 second period (50 characters in the string at 1/10 of a second apiece). Note that once you have the Custom Appearance that you want, you can change the color and the brightness to get the overall effect you want.

If you're not interested in the ZHLT flags, more of an advanced application anyway, you can skip the next couple of exercises. Make sure your light is near the center of the room and near (but not IN) the ceiling brush. Set the Brightness of your light to 255 255 128 150 (not too bright), set Appearance to Normal, and erase anything you have in Custom Appearance. Compile it, run it and take note of how the room is illuminated. The corners of the room should be a bit darker than the center of the room. Now change the ZHLT Fade property of your light to 2.0. Compile it, run it and note that the center of the room is at just about the same brightness as before but the corners of the room are darker. If you had decreased the brightness to get dark corners instead, the center of the room would be darker also. Change the ZHLT Fade to 0.5, compile and run. Once again, the center of the room is about the same but the corners are lighter. Increasing the brightness to get light in the corners would increase the light in the center of the room as well as the corners. You don't want light in the corners of a room in Half-Life, anyway! The Fade property actually does effect the light in the center of the room. But, by using the Fade property this way, you can more easily maintain the general brightness of a room consistent with other rooms in your map, while still adding some dark corners.

Now move your light to one end of the room. Keep it near the ceiling (but not IN the ceiling brush). Change the ZHLT Fade back to 1.0 and set the ZHLT Falloff to Inverse Linear. Keep the brightness at 150. Compile and run. One bright room, huh? The light drops off much less dramatically using this setting. In fact, you'd have to set up a very long hallway to see much dropoff at all at a brightness of 150. In addition, this setting tends to illuminate brushes a long way off in ways that definitely do not make sense to the eye. With the room setup for this tutorial, you'll probably have to drop the brightness down to 50 or less to see much affect. Even then, the far wall seems unusually bright compared to the adjacent floor.

Enough about plain old lights. Let's look at the...

== Light_spot entity

Light_spot entities, "spotlights," are more fun that regular lights. There are more properties to play with and, in general, the lighting effects are more dramatic. So it's important to understand what the various properties of a light_spot entity. A light_spot projects a cone of light, like a spotlight. Like a spotlight, a light_spot entity can be given a direction along which to point the cone or you can give it a target to aim at. [Reviewers: MORE EXPLANATION? inner angle, outer angle and a picture? ] So, let's look at the [b]Properties[/b]. If you haven't modified your fgd file, the properties for light_spot appear in a slightly different order in the Properites box than for the light entity. The order they appear in the menu is not important. You can edit your fgd file to put them in a more convenient order if you like. 

=== Properties

==== Name

Same as described in 'light' entity above. A named light_spot can only have a Normal Appearance or a Custom Appearance but can be triggered on and off. A light_spot with a Custom Appearance must have a name. 

==== Target

You don't have to use a target to aim the light_spot. You can set the pitch and yaw properties instead. However, if you want to set a target, like an info_target entity, for the light_spot, then, if you later need to move the light_spot around in your map, it will still be aimed at the desired spot in the map and you don't have to manually readjust the direction of the light_spot. To set the target, fill in the name of the entity on which the light_spot will be centered. That entity is usually an info_target or an info_null. Place the info_target or info_null in the map where you want the center of the spot to be aimed. Give the info_target or info_null the same name that you filled in for the light_spot target. Done. [font=blue]NOTE[/font]: Lighting is determined during compilation, not during gameplay. That means, unfortunately, that you can't move the target of the light_spot and have a "spotlight" follow it. You can set the target of a light_spot to a named entity, but the light will remain centered on the spot where the entity was at the start of the map, even if the targeted entity later moves. So it can't be set to follow a func_train or a monster. Bummer. 

==== Pitch roll yaw (Y Z X)

Because roll has no meaning for a symetrical beam, use the Pitch and Yaw properties explained below instead. [font=blue]Note[/font]: if the Is sky property (see below) is set to Yes, the ZHLT fade and falloff properties are ignored. 

==== ZHLT fade

See the discussion in the light entity properties above. 

==== ZHLT falloff

See the discussion in the light entity properties above. 

==== Inner (bright) angle

This property determines the size of the inner, uniformly lit cone. This cone forms the brighter center cone of light. Useful values for the inner angle are in the range of 15 to 90 degrees. At angles of 135 and above, it loses the affect of being a spotlight. [font=red]Outer (fading) angle[/font]: This property determines the size of the outer, fading cone of light. From the edge of the inner angle on out to the outer angle, the light drops off from the more brightly lit center to darkness. Values for the outer angle, to keep it looking like a spotlight, are normally about 15 to 30 degrees wider than the inner angle.

[img:light_bj1.jpg|Inner and outer angles.]

In this picture, the inner angle (the black circle) is 30 degrees. The outer angle is 45 and you can the fading between the outside the black circle. 

==== Pitch

This is the angle above or below the horizontal for the light_spot direction. Angles above the horizontal are postive (+45 points up at an angle of 45 degrees) and angles below the horizontal are negative (-90 points straight down). 

==== Yaw

Yaw is the compass direction for the light as viewed from directly above. You won't see this property in the Smartedit list. You can set it by typing in the desired angle in the Angle box, or by dragging the little white line around in the black compass to the right of the Angle box. 

==== Brightness

See the discussion in the light entity properties above. 

==== Is sky

You have a choice of No or Yes. 'No' means the light_spot will cast light onto your map from where you've placed it. 'Yes' means that any point on the map visible from any 'sky' brush will be lit as if the light_spot were pointing directly at that spot. That is, if you set the direction of a 'sky' light_spot pointing down at a 45 degree angle (pitch= -45), areas which can be seen from any sky brush will be lit as if light were coming down at a 45 degree angle. That angle will be constant throughout any 'sky' illuminated areas, regardless of the location of the light_spot and regardless of where the sky texture is located. Strangely enough, when used as sky illumination, it can still be turned on and off and given a custom appearance! I don't know whether that's a feature or a bug. Also, if you have a window in one room with a sky texture and another window in another room with a sky texture, light will shine in both windows in the same direction. That's.. pretty much.. realistic, hmm? If you want, you can set a target for the light_spot used as sky lighting. The overall lighting from the sky will then be from the direction from the light_spot to the target entity (e.g., info_null or info_target). 

==== Appearance

See the discussion in the light entity properties above. 

==== Custom Appearance

See the discussion in the light entity properties above. 

=== Flags

See the discussion in the light entity properties above.

The third light entity to discuss is the...

== Light_environment entity

The light_environment entity is used (as can the light_spot entity) to control the angle, pitch, color and brightness of any areas that are visible from sky brushes in your map, i.e., the "outdoors." You can use other lights "outside," also, for effect if you wish. And, like the light_spot with its Is sky property set to Yes, a light_environment can be placed anywhere in your map. It does not need to be located near a sky brush nor, for that matter, does it need to be in the "outdoors" area of your map.

=== Properties 

==== Name

Similar to the light and light_spot entities, you can give the light_environment entity a name. Strangely enough, considering its purpose, if you give it a name you can turn it on and off by using its name as the target for a trigger entity (e.g., func_button, trigger_once). Like the other two light entities, its default state is 'on' when the map starts. Unlike the other two, it does not have an 'Initially dark' flag.

==== Pitch roll yaw (YZX)

Like light_spot entity, roll isn't applicable to the light_environment entity. Use Pitch and Angle to set the direction of your "outdoors" light. Note: I'm not sure why the fgd includes the ZHLT properties for light_environment. They are ignored. 

==== ZHLT Fade

==== ZHLT Falloff

==== Pitch

See the discussion in the light_spot entity properties above. 

==== Angle

See the discussion in the light_spot entity properties above. 

==== Brightness

Yes, you can set the color of your outdoor lighting. Might prove useful for early morning, late evening or xeno effects. See the discussion in the light entity properties above for setting color and brightness. 

=== Flags

none

== Texture Lighting (Texlights)

Having discussed the three light entities, that brings us to a discussion on the use of textures to light your map.

Texture lighting is the use of textures to provide lighting. Once your editor has been set up to use them, basic texlights are quick and simple to apply. Texture lights, or texlights for short, can be used for lighting by themselves (quite effectively) or you can 'group' them with light entities to achieve more specialized effects. The basic form of texlight is simple to use. By applying more advanced principles, you can switch texlights on and off and give them varying appearances (as described in the Appearance property in the light entity discussion above) and even custom appearances as described in Custom Appearance above).

=== Setting up to use texlights

To use texture lighting as described in this tutorial, you'll need: 

* The ZHLT Tools 2.5.3 Custom Build 1.7. These tools are recommended for general Half-Life mapping in any case.
* A modified halflife.fgd which lets you insert the info_texlights entity into your map. If you want to use the advanced features of texlights (turning them on and off and using various appearances), the halflife.fgd file must also be modified to add 'texlight styles' to at least one entity, usually [font=purple]func_wall[/font]. 

By using the info_texlights entity, you don't have to create or edit a lights.rad file. There are two big benefits from this: 

* This allows you to change your texlight color and brightness settings without leaving the editor. If you use a lights.rad file to define your texlights, you either have to use that same lighting for every map you make or you have to edit the lights.rad file uniquely for every map. 
* By defining your texlights in an info_texlights entity in your map, those settings are applied only to that map, are included in that map if you distribute it and don't affect the texture lighting in any other map. If you put your map in the TWHL map vault, you don't need to upload the lights.rad file with it or include a text file describing what texture lighting you've defined in your map. It's all in the info_texlights entity inserted into your map file. 

==== Modifying your halflife.fgd file

[font=blue]Note[/font]: Modifying your halflife.fgd file as described below will not affect the way any of your existing maps work. It extends the capabilities of your editor, not change them. Your halflife.fgd file can be found in the fgd subfolder under your Hammer editor folder. It'll be something like C:\Program Files\Valve Hammer Editor\fgd\Half-Life\halflife.fgd.

1. Save a copy of your existing halflife.fgd file in case you screw up.
2. Make sure Hammer is closed and open your halflife.fgd file in Notepad or some simple text editor.
3. Copy the following single line and insert it into the file anywhere. I recommend putting it right after [font=purple]info_teleport_destination[/font] so it'll appear in alphabetical order in your entities dropdown list.

```
@PointClass color(255 128 0) = info_texlights : "Texture Light Config"
```

4. If you've inserted that single line into the fgd where I recommend, check that that portion of the file looks like this:	

```
...
@PointClass size(-8 -8 0, 8 8 16) base(PlayerClass, Targetname) = info_teleport_destination : "Teleport destination"
@PointClass color(255 128 0) = info_texlights : "Texture Light Config"
...
```

5. Search for the description of the [font=purple]func_wall[/font] entity. It will look like this:

```
@SolidClass base(Targetname, Appearflags, RenderFields, Global, ZHLT) = func_wall : "Wall" [
    _minlight(string) : "Minimum light level"
]
```

6. Copy the following lines and insert them into the [font=purple]func_wall[/font] definition so it looks as shown in step 7:

```
    style(choices) : "Texlight style" : 0 =
    [
        0 : "Normal"
        -3: "Grouped"
        10: "Fluorescent flicker"
        2 : "Slow, strong pulse"
        11: "Slow pulse, noblack"
        5 : "Gentle pulse"
        1 : "Flicker A"
        6 : "Flicker B"
        3 : "Candle A"
        7 : "Candle B"
        8 : "Candle C"
        4 : "Fast strobe"
        9 : "Slow strobe"
        12: "Underwater"
    ]
```

7. Check that the [font=purple]func_wall[/font] definition looks like the following. Be sure it's exactly like this, including all the square brackets:

```
@SolidClass base(Targetname, Appearflags, RenderFields, Global, ZHLT) = func_wall : "Wall" [
    style(choices) : "Texlight style" : 0 =
    [
        0 : "Normal"
        -3: "Grouped"
        10: "Fluorescent flicker"
        2 : "Slow, strong pulse"
        11: "Slow pulse, noblack"
        5 : "Gentle pulse"
        1 : "Flicker A"
        6 : "Flicker B"
        3 : "Candle A"
        7 : "Candle B"
        8 : "Candle C"
        4 : "Fast strobe"
        9 : "Slow strobe"
        12: "Underwater"
    ]
    _minlight(string) : "Minimum light level"
]
```

8. Save your modified halflife.fgd file back into the fgd directory of your editor.
9. Restart Hammer for the modifications to take effect.
10. Select the entity tool, drop the entity list down and check that [font=purple]info_texlights[/font] appears somewhere in the list. If you've done it correctly, it will follow [font=purple]info_teleport_destination[/font].
11. Create a brush, tie it to a func_wall entity and check that Texlight style appears as a Property of the [font=purple]func_wall[/font]. 

Now that we have a newly modified fgd to play with, let's work through a quick example so you can get an idea how the info_texlights entity works. 

# Open a New map in Hammer.
# Browse for and select the texture [font=blue]FIFTIES_WALL13[/font] in the [font=red]Texture Bar[/font].
# Select the Block Creation tool and make a block 512w x 512l x 256h.
# Hollow it out. 32 unit walls are fine.
# Bring up the Texture Application tool (Shift-A) and select the downward facing face of the ceiling brush. Which brush you actually select isn't real important as this is just to demonstrate a very simple texlight. But the face you choose must be facing the inside of your map.
#  In the Texture Application tool, the [font=blue]FIFTIES_WALL13[/font] texture should be shown. Select Browse in the Texture Application tool and select the FIFTIES_WALL14V texture.
# Click Apply and ensure that just the texture of just one brushface has changed.
#  Close the tool.
# Insert an info_player_start entity somewhere inside your map.
# Insert an info_texlights entity somewhere in your map. The location doesn't matter as long as it's inside the map somewhere.
#  Select the info_texlights entity and open up Properties.
# Click on Smartedit to open up the Add/Delete dialog.
# Click Add.
#  For the Key, enter FIFTIES_WALL14V.
# For the Value, enter 255 255 128 50.
# Close the Object Properties dialog, compile and run the map.
#  You should appear in an ugly green cinderblock room with a fairly plain lit ceiling. The light in the room is being provided by the texlight. Remember? You didn't add a light entity to the room. 

What you just did is to specify in the info_texlights entity (in just that map, no other) that everywhere the FIFTIES_WALL14V texture is used, it's to emit light with a Brightness of 255 255 128 50. Let's get into some of the details of texture lighting. There are three basic types of texture lighting: 

* Simple texlight (lighted texture) - a texture defined in info_texlights applied to a brush-face. Shines with a Normal appearance. 
* Texlight tied to an entity - a texture defined in info_texlights applied to a brush-face. The brush is tied to an entity (normally a func_wall). Shines with a Texlight style selected in the [font=purple]func_wall[/font] properties.
* Texlight grouped with a light entity - a texture defined in info_texlights applied to a brush-face. The brush is tied to an entity (normally a func_wall). A light entity is grouped with the texlight by giving both the light entity and the func_wall entity the same name. Shines with a Normal appearance or a Custom Appearance set in the light entity properties. Can be turned on and off by triggering the group name. 

=== Simple Lighted Textures

If you completed the example above, you have an idea what a simple lighted texture is. It's a texture applied to a brush (that doesn't have to be an entity! it's applied to a world brush) and defined as a light emitting texture in an info_texlights entity. That's it. You can't switch it on and off or give any appearance other than Normal because it's not tied to an entity. It's plain and simply a texture that emits light. To create a simple texlight: 

# Insert an info_texlights into your map.
# In the info_texlights properties, Add the name of the texture which is to be used for the texlight and the color and brightness of the light that you want the texture to emit.
# Apply that texture to brushfaces whereever you want. 

That's it. You'll now have a 'light' in your map with the shape of the brush faced with the texlight texture.

[font=blue]Note[/font]: a texlight, unlike a light entity, gives off light in proportion to the size of the texlight. If the texlight brush is small, you get a small amount of light. If you make the texlight big, it will give off more light. I suggest making the texlight the size and shape you want and then adjust the luminosity, the 4th number in the Brightness of the texture in the info_texlights list, to get the desired level of lighting. You can also increase the number of texlights to brighten the area.

Quite a bit can be accomplished with simple texlights and they can simplify the construction of portions of your map. Rather than add multiple light entities to light a hallway, for instance, you can add texlights directly to world brush faces as shown in the picture below.

[img:light_bj2.jpg|Light with no light.]

There are no light entities used in that map. The hallway started as a hollowed block forming the hull of the map, the ceiling was clipped to correctly sized brushes and a texlight texture (defined in an info_texlights) applied to look like flourescent lights. Quick but effective. The original Doom maps were lighted only with textures. The light areas were bright textures and the dark areas were dark textures. "Blinking" lights were really just textures with two brightnesses that were rendered alternately every few frames. The areas lit by that blinking light appeared to be lit by the blinking light only because the mapper applied a blinking texture to adjacent shaped brushes to make it look that way.

The Hammer editor and accompanying compiler simplify life by letting you define lights and texlights and assume they emit light that casts shadows and bounces off other surfaces. Note, however, that, with just a couple of exceptions, Half-Life maps are not dynamically lighted. That is, the compiler determines lighting before the map is created. When you actually play Half-Life maps, the "lighting" you see are just textures with bright pixels where there is supposed to be light and darker pixels where there is supposed to be shadows. Differently shaded textures are rendered in a view when a light is turned on or off to make it appear that light is being cast. The few exceptions I know of are the flashlight and, perhaps, the light that an alien slave gives off when it charges up.

=== Texlight Tied to an Entity

To use a texlight that has something other than a Normal (steady) light appearance, you can tie the brush to which the texlight texture has been applied to a func_wall entity. Now you can select a Texlight style in the func_wall properties and have the texlight flicker with various styles.

To create a texlight with a Texlight style: 

# Open the Properties of your info_texlights entity and turn off Smartedit.
# Click Add, enter the name of the texture to be used as a texlight as the Key.
# Enter the Brightness (3 RGB values and a luminosity number) that you want as the Value. In general, texlights need to have much greater luminosities (the 4th number) than light entities. You'll have to give it a value up in the range of 250 or more, maybe up to 2000 or more, to get it to "shine" much, to cast shadows, etc. 
# Create the brush that is to be your texlight. Note: the brush you use for your texlight cannot be a hull brush. All hull brushes must be world brushes or you'll have a leak in your map.
# Tie the brush to a func_wall entity (other entities can be used if you've edited your fgd file to allow selection of Texlight styles).
# Open the Texture Application tool and apply the texlight texture to a face of the brush.
# Open the func_wall Properties of your brush and select a Texlight style, such as Fluorescent flicker or Underwater.
# Compile and run your map and you've got a texlight with other than Normal style.


This is very similar to a simple texlight, but, by tying the brush to a func_wall entity, you have the capability to select a texlight style. In addition, you can use several texlights with the same texture and set different Texlight styles for each one. For instance, a hallway can be lit by several fluorescent fixtures of the same texlight texture, but just one of them flickers.

=== Texlight Grouped with a Light Entity

This application is a bit more complicated but it gives you the capability to turn your texlight on and off and/or give it a Custom Appearance. The "grouped" texlight is a texture applied to a brush and the brush is tied to an entity, most commonly a func_wall. A light entity is then added to the map and "grouped" together with the func_wall by giving both the light and the func_wall the same Name property. The texlight can now be turned on and off by triggering the group name and the texlight can be given a Custom Appearance by setting the Custom Appearance property in the light entity.

Like the simple texlight, the texture that is to emit light is defined in the info_texlights entity with the desired color and luminosity. The principle behind this type of texlight is that the map compiler uses information from the info_texlights entity to set the Brightness of the texlight. The map compiler also uses the Name of the light entity and its Custom Appearance (if it's set) to allow the texlight to be turned on and off and/or give it the Custom Appearance defined in the light entity.

First, here's how to create a grouped texlight: 

# Open the Properties of your info_texlights entity and turn off Smartedit.
# Click Add, enter the name of the texture to be used as a texlight as the Key.
# Enter the Brightness (3 RGB values and a luminosity number) that you want as the Value.
# Create the brush that is to be your texlight.
# Tie the brush to a func_wall entity (other entities can be used if you've edited your fgd file to allow selection of Texlight styles).
# Open the Texture Application tool and apply the texlight texture to a face of the brush. Close the Texture app tool.
# Open the Properties of the func_wall and selected Grouped from the Texlight styles.
# Give the func_wall a name, like 'texlight1' (without the quotation marks).
# Add a light entity to your map (anywhere). Be sure it's inside the map somewhere and not outside the hull.
# Open the Properties of the light entity and give it the same name (like 'texlight1') as the func_wall. This 'groups' it with the func_wall.
# Change the luminosity, the 4th number of the Brightness property, to something small, like 0.01 (e.g., Brightness=255 255 128 0.01). 

[font=blue]Note[/font]: The light entity you've added will still be treated by the compiler as if it's giving off light! If you want only the texlight to give off light, you have to make the light entity very dim (to the point where it isn't seen). If you compile and run a map with a grouped texlight as described in the steps above, the texlight will pretty much look like a simple texlight.

So what's the point? 

* You can set a Custom Appearance (see the Properties of the Light entity at the beginning of the tutorial) in the light entity and the texlight will take on that Custom Appearance. Note, however, that you can't change the Appearance property of the light entity to achieve this, only the Custom Appearance. 
* Since the texlight and the light have a name, you can trigger the texlight on and off. If you want the texlight light to be initially dark, set the Initially dark flag in the grouped light entity. 
* You can have multiple texlights all grouped with one light entity and switch them all on and off, as you would expect to be able to do in a large room with one switch and several light fixtures. You don't have to set the properties of several light entities, just one info_texlights Brightness. If you want to change the light level in an area like that, you can edit just the texture Brightness in the info_texlights list. 
* You don't have to use the same texture for every texlight in a group. As long as the texture is listed in the info_texlights and the func_wall to which the texture's been applied has the same group name, it will behave (have the same appearance and be turned on and off) like the rest of the group. You can give each texlight texture a different color and/or luminosity. Using a multimanager and several groups of texlights, you can create a circus lighting effect.. if you want.

=== Tips for Using info_texlights 

As mentioned above, the advantages of using an info_texlights entity in your map are: you don't have to edit or distribute a lights.rad file, and the texlights you define in one map don't affect the lighting in any other map. In some cases, you may want to use the same texture as both a texlight and as a normal texture. Well, you can't actually do that.

However, you can use two textures that look identical but have different names. What I've done is to create a separate wad file and copied textures from halflife.wad (for instance) into my special wad file (using Wally) but given them a different name. For instance, I copied the texture +0~FIFTS_LGHT06 into my special wad file and gave it the name FIFTS_LGHT06x. Where I want a regular looking light fixture, I use the +0~FIFTS_LGHT06 texture. Where I want the same looking texture as a texlight, I use FIFTS_LGHT06x and define its Brightness in an info_texlights entity in my map. I added my special wad to the Textures tab I have set up in my Configuration. That ensures I have those "special" textures available when I build a map. I also added "-wadinclude &lt;Specialwadname&gt;" to the command line for my csg compiler ("Expert" option in the compile dialog). This results in any textures I've used from my special wad to be included directly in the bsp file.

There are advantages and disadvantages to this setup. On the plus side, I can distribute a bsp file without hassling anyone with an extra wad file. No special instructions on where to copy an extra wad file, etc. Just load and run the bsp as you would any bsp. On the negative side, the bsp file size is increased by the size of a texture that the user already has in his/her halflife.wad file. If the texture isn't too big, no big deal. If I use lots of special textures, the bsp size can be dominated by the size of the extra textures. In the neutral area, if I wanted to distribute the .rmf file, I'd have to include the special wad file. The info_texlights entity included in the .rmf would, however, have the Brightness for any texlights already set. There'd be no need to provide instructions on how to edit the user's lights.rad file which, as a mapper, I would find a pain in the backside.

I made lots and lots of test maps to prepare this tutorial. I got into the habit of inserting a func_button + info_texlights + info_player_start prefab, just to make sure I had a lit button with a defined texlight texture where I could find it in the dark. I did a lot of turning lights on and off and it didn't take long to get into that habit. 

=== Little Oddities 

If you compile and run a map with a grouped texlight applied to a fairly small brush, you'll notice something odd. The texlight now casts light as if it were coming from a spotlight with a 90 degree cone somewhere near the back of the texlight brush instead of taking on the shape of the texlight brush itself! That, fortunately or unfortunately, is the nature of Zoner's compiler. It treats the texlight more like a light entity instead of an 'area' of light-emitting texture. That feature (or bug) can be used to make a desklamp look pretty realistic as one would expect a desklamp to cast a cone of light anyway. It's a little less convenient when you want to make a fluorescent fixture in a room or hallway, although, in general, it's not very noticeable.</value>
  </data>
  <data name="StandardWeaponsProgrammingPageHtml" xml:space="preserve">
    <value>&lt;div class="embed-panel card card-info"&gt;&lt;div class="card-header"&gt;NOTICE&lt;/div&gt;&lt;div class="card-body"&gt;If you are programming for a single player mod and looking for a simpler approach, refer &lt;a href="https://twhl.info/wiki/page/Tutorial%3A_Add_a_new_simple_weapon_%28straightforward_way%29"&gt;Tutorial: Add a new simple weapon (straightforward way)&lt;/a&gt;.&lt;/div&gt;&lt;/div&gt;
This guide will walk through how to add a &amp;quot;regular&amp;quot; weapon to your Half-Life mod. In this case, &amp;quot;regular&amp;quot; means a gun that shoots bullets and reloads. In this article we&amp;#039;ll be implementing the Desert Eagle pistol from Opposing Force into standard Half-Life. This guide assumes that you have experience programming in C++, and a programming environment and your custom mod already set up.&lt;div class="embedded image" title="Here&amp;#039;s what we&amp;#039;ll be implementing in this tutorial"&gt;&lt;span class="caption-panel"&gt;&lt;video class="caption-body" src="https://twhl.info/wiki/embed/Weapons_Programming_-_Desert_Eagle_Demo" playsinline controls &gt;Your browser doesn't support embedded video.&lt;/video&gt;&lt;span class="caption"&gt;Here&amp;#039;s what we&amp;#039;ll be implementing in this tutorial&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;You can view the commit containing all the code changes in this tutorial &lt;a href="https://github.com/LogicAndTrick/halflife-updated/commit/tutorial-standard-weapons"&gt;on GitHub by clicking here&lt;/a&gt;.
&lt;h1 id="Get_the_files_from_Opposing_Force"&gt;Get the files from Opposing Force&lt;/h1&gt;
Since this article isn&amp;#039;t about modelling, animating, or sound design, we&amp;#039;re just going to take the assets we need from the Opposing Force folder. Copy the following files into your mod, from the &lt;strong&gt;gearbox&lt;/strong&gt; folder:
&lt;ul&gt;&lt;li&gt;events/eagle.sc&lt;/li&gt;&lt;li&gt;models/p_desert_eagle.mdl&lt;/li&gt;&lt;li&gt;models/v_desert_eagle.mdl&lt;/li&gt;&lt;li&gt;models/w_desert_eagle.mdl&lt;/li&gt;&lt;li&gt;sound/weapons/desert_eagle_fire.wav&lt;/li&gt;&lt;li&gt;sound/weapons/desert_eagle_reload.wav&lt;/li&gt;&lt;li&gt;sound/weapons/desert_eagle_sight.wav&lt;/li&gt;&lt;li&gt;sound/weapons/desert_eagle_sight2.wav&lt;/li&gt;&lt;li&gt;sprites/320hudof01.spr&lt;/li&gt;&lt;li&gt;sprites/640hudof01.spr&lt;/li&gt;&lt;li&gt;sprites/640hudof02.spr&lt;/li&gt;&lt;li&gt;sprites/ofch1.spr&lt;/li&gt;&lt;li&gt;sprites/weapon_eagle.txt&lt;/li&gt;&lt;/ul&gt;
You might think that the OP4 HUD sprites will look a bit strange in the Half-Life HUD - you&amp;#039;re right! Graphics design isn&amp;#039;t part of this tutorial, so we&amp;#039;re going to live with the out-of-place sprites.
&lt;h1 id="Defining_weapon_constants"&gt;Defining weapon constants&lt;/h1&gt;
Let&amp;#039;s start up by doing some of the less-important admin tasks related to adding a new weapon. For the purposes of this article, the Desert Eagle will share ammo with the .357 magnum, so we won&amp;#039;t need to worry about adding a new ammo type. If you want a custom ammo type for your weapon, check &lt;a href="https://twhl.info/wiki/page/Weapons_Programming_-_Custom_Ammo_Types"&gt;Custom Ammo Types&lt;/a&gt; and the &lt;a href="https://twhl.info/wiki/page/Weapons_Programming_-_Zoomable_Weapons"&gt;Zoomable Weapons&lt;/a&gt; article.&lt;br&gt;&lt;br&gt;First we need to assign the weapon a new ID, as well as define some other constants. These are in &lt;strong&gt;weapons.h&lt;/strong&gt;, so open it now. Towards the top of the file, find the list of &lt;code&gt;#define&lt;/code&gt; statements for each weapon. Add a new line for the new weapon. The value should be unique per weapon, so just increment the number of the last weapon.
&lt;pre class="lang-cpp"&gt;&lt;code&gt;#define WEAPON_NONE          0
#define WEAPON_CROWBAR       1
// ... more lines here
#define WEAPON_SNARK        15
#define WEAPON_DESERT_EAGLE 16&lt;/code&gt;&lt;/pre&gt;

&lt;div class="embed-panel card card-info"&gt;&lt;div class="card-header"&gt;Half-Life Updated SDK specific notice&lt;/div&gt;&lt;div class="card-body"&gt;If you are using Solokiller&amp;#039;s updated Half-Life SDK, you need to add the weapon ID in &lt;code&gt;cdll_dll.h&lt;/code&gt; as well.&lt;/div&gt;&lt;/div&gt;
Next, we&amp;#039;ll define the weight. Just underneath the weapon IDs are the weapon weight constants. I&amp;#039;ll make the weight for the Desert Eagle to be the same as the magnum.
&lt;pre class="lang-cpp"&gt;&lt;code&gt;#define CROWBAR_WEIGHT     0
#define GLOCK_WEIGHT       10
#define PYTHON_WEIGHT      15
// ... more lines here
#define TRIPMINE_WEIGHT    10
#define DESERT_EAGLE_WEIGHT 15&lt;/code&gt;&lt;/pre&gt;
As we&amp;#039;re not adding a new ammo type, we can skip the &lt;code&gt;MAX_CARRY&lt;/code&gt; block, so move on to the &lt;code&gt;MAX_CLIP&lt;/code&gt; block. Add the relevant line to the end of this group.
&lt;pre class="lang-cpp"&gt;&lt;code&gt;#define GLOCK_MAX_CLIP       13
#define PYTHON_MAX_CLIP      6
// ... more lines here
#define SNARK_MAX_CLIP       WEAPON_NOCLIP
#define DESERT_EAGLE_MAX_CLIP 7&lt;/code&gt;&lt;/pre&gt;
Same goes for the &lt;code&gt;DEFAULT_GIVE&lt;/code&gt; constant as well.
&lt;pre class="lang-cpp"&gt;&lt;code&gt;#define GLOCK_DEFAULT_GIVE          13
#define PYTHON_DEFAULT_GIVE         6
// ... more lines here
#define HIVEHAND_DEFAULT_GIVE       8
#define DESERT_EAGLE_DEFAULT_GIVE   7&lt;/code&gt;&lt;/pre&gt;
Since we&amp;#039;ll be reusing the magnum&amp;#039;s ammo box, you can ignore the &lt;code&gt;AMMO_GIVE&lt;/code&gt; section. That&amp;#039;s it for constants.
&lt;h1 id="Creating_a_bare-bones_weapon_class"&gt;Creating a bare-bones weapon class&lt;/h1&gt;
The next step is to get the gun in-game. By the end of this section, it&amp;#039;ll be available and selectable as a weapon, but it won&amp;#039;t do anything useful. Some tutorials will recommend that you copy and paste an existing weapon to get started. This is certainly faster, but let&amp;#039;s write the weapon from scratch so that we have a good handle on programming a new weapon.
&lt;h2 id="Class_declaration"&gt;Class declaration&lt;/h2&gt;
The first thing to do is to define the class inside the &lt;strong&gt;weapons.h&lt;/strong&gt; file. Open it now, and add this after the &lt;code&gt;CSqueak&lt;/code&gt; definition:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;class CDesertEagle : public CBasePlayerWeapon
{
public:
    void Spawn();
    void Precache();
    int iItemSlot() { return 2; }
    bool GetItemInfo(ItemInfo *p);

    int AddToPlayer(CBasePlayer *pPlayer);
    void PrimaryAttack();
    void SecondaryAttack();
    bool Deploy();
    void Holster(int skiplocal = 0);
    void Reload();
    void WeaponIdle();

    virtual bool UseDecrement()
    {
#if defined( CLIENT_WEAPONS )
        return true;
#else
        return false;
#endif
    }
private:

};&lt;/code&gt;&lt;/pre&gt;
This is your standard weapon class definition. There&amp;#039;s no code here, just overrides of the base class methods, as documented in the &lt;a href="https://twhl.info/wiki/page/Weapons_Programming_-_High-Level_Overview"&gt;High-Level Overview&lt;/a&gt; article. Additional changes will be needed to this class later, but this is the basic outline that we&amp;#039;ll need to get started.&lt;br&gt;&lt;br&gt;There&amp;#039;s two things to note here before we continue. First, the value returned by &lt;code&gt;iItemSlot&lt;/code&gt; will be 1 greater than the value used for &lt;code&gt;iSlot&lt;/code&gt; in &lt;code&gt;GetItemInfo&lt;/code&gt; later. Think of the &lt;code&gt;iItemSlot&lt;/code&gt; value being 1-indexed, and the &lt;code&gt;iSlot&lt;/code&gt; value being 0-indexed. Second, the &lt;code&gt;UseDecrement&lt;/code&gt; method is defined in that way in order to handle client predictions. It&amp;#039;s odd, but that&amp;#039;s how it is.
&lt;h2 id="Basic_class_implementation"&gt;Basic class implementation&lt;/h2&gt;
Now to get started on the real stuff. Create a new file called &lt;strong&gt;deserteagle.cpp&lt;/strong&gt; in the &lt;strong&gt;dlls&lt;/strong&gt; directory of your solution folder. Avoid using VS to create this file, because it&amp;#039;ll probably put it in the wrong folder and make everything a mess. Then include the file in both of your projects:
&lt;ul&gt;&lt;li&gt;For the &lt;strong&gt;hldll&lt;/strong&gt; project, expand &amp;quot;Source Files&amp;quot; and then &amp;quot;dlls&amp;quot; and add the file to this directory using &amp;quot;Add -&amp;gt; Existing Item...&amp;quot;&lt;/li&gt;&lt;li&gt;For the &lt;strong&gt;cl_dll&lt;/strong&gt; project, expand &amp;quot;Source Files&amp;quot;, and then &amp;quot;_hl/dlls&amp;quot; and add this file to this directory using &amp;quot;Add -&amp;gt; Existing Item...&amp;quot;&lt;/li&gt;&lt;/ul&gt;
Now let&amp;#039;s prepare the bare minimum implementation of the &lt;code&gt;CDesertEagle&lt;/code&gt; class. We&amp;#039;ll start with a very empty implementation of each method:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;#include &amp;quot;extdll.h&amp;quot;
#include &amp;quot;util.h&amp;quot;
#include &amp;quot;cbase.h&amp;quot;
#include &amp;quot;weapons.h&amp;quot;
#include &amp;quot;player.h&amp;quot;

// These correspond directly to the sequences in the weapon&amp;#039;s view model
enum desert_eagle_e {
    DESERT_EAGLE_IDLE1 = 0,
    DESERT_EAGLE_IDLE2,
    DESERT_EAGLE_IDLE3,
    DESERT_EAGLE_IDLE4,
    DESERT_EAGLE_IDLE5,
    DESERT_EAGLE_SHOOT,
    DESERT_EAGLE_SHOOT_EMPTY,
    DESERT_EAGLE_RELOAD,
    DESERT_EAGLE_RELOAD_NOT_EMPTY,
    DESERT_EAGLE_DRAW,
    DESERT_EAGLE_HOLSTER,
};

LINK_ENTITY_TO_CLASS(weapon_eagle, CDesertEagle)

void CDesertEagle::Spawn()
{

}

void CDesertEagle::Precache()
{

}

bool CDesertEagle::GetItemInfo(ItemInfo* p)
{
    return false;
}

bool CDesertEagle::AddToPlayer(CBasePlayer* pPlayer)
{
    return false;
}

void CDesertEagle::SecondaryAttack()
{

}

void CDesertEagle::PrimaryAttack()
{

}

bool CDesertEagle::Deploy()
{
    return false;
}

void CDesertEagle::Holster(int skiplocal)
{

}

void CDesertEagle::Reload()
{

}

void CDesertEagle::WeaponIdle()
{

}&lt;/code&gt;&lt;/pre&gt;
That&amp;#039;s a start - the project will compile. But it won&amp;#039;t do much at this point, so we should add a bit more code.
&lt;h1 id="Bare_minimum_weapon_code"&gt;Bare minimum weapon code&lt;/h1&gt;
Let&amp;#039;s make the changes needed for the bare minimum functionality for a weapon: allowing the user to select the weapon in the HUD, and show the weapon model when it&amp;#039;s equipped. To get to that point, we need to implement the following methods:
&lt;ul&gt;&lt;li&gt;Spawn&lt;/li&gt;&lt;li&gt;Precache&lt;/li&gt;&lt;li&gt;GetItemInfo&lt;/li&gt;&lt;li&gt;AddToPlayer&lt;/li&gt;&lt;li&gt;Deploy&lt;/li&gt;&lt;li&gt;Holster&lt;/li&gt;&lt;/ul&gt;
All of these methods are very similar for most weapons, so you can implement these methods fairly quickly by referencing a different weapon&amp;#039;s code. We&amp;#039;ll take a close look at each one in detail, but first we need to make one small change in a different file.
&lt;h2 id="Precache_the_weapon"&gt;Precache the weapon&lt;/h2&gt;
For weapons and in-game items, we need to make sure they get precached when the map loads. Open &lt;strong&gt;weapons.cpp&lt;/strong&gt; and fine the &lt;code&gt;W_Precache&lt;/code&gt; method. You&amp;#039;ll see a bunch of calls to &lt;code&gt;UTIL_PrecacheOther&lt;/code&gt; and &lt;code&gt;UTIL_PrecacheOtherWeapon&lt;/code&gt;. All you need to do is add a new line to this method for your new weapon&amp;#039;s classname. Ignore the &lt;code&gt;#if !defined...&lt;/code&gt; lines, they&amp;#039;re not important. Add this line in the same place as the other precache calls, underneath the &lt;code&gt;weapon_357&lt;/code&gt; line is a good place.
&lt;pre class="lang-cpp"&gt;&lt;code&gt;UTIL_PrecacheOtherWeapon(&amp;quot;weapon_eagle&amp;quot;);&lt;/code&gt;&lt;/pre&gt;
Now go back to &lt;strong&gt;deserteagle.cpp&lt;/strong&gt; - let&amp;#039;s start implementing some methods!
&lt;h2 id="Spawn"&gt;Spawn&lt;/h2&gt;
The &lt;code&gt;Spawn&lt;/code&gt; method is called when the weapon entity appears in the world - when the gun is lying on the ground, ready to be picked up. Unless the weapon is given to the player by default, this is how the player will get your weapon. The &lt;code&gt;Spawn&lt;/code&gt; method looks very similar for most weapons. See the comments for the details of each line in this function.
&lt;pre class="lang-cpp"&gt;&lt;code&gt;void CDesertEagle::Spawn()
{
    // Define the classname of the entity
    // This is the name you should use to reference this entity name in your code base.
    pev-&amp;gt;classname = MAKE_STRING(&amp;quot;weapon_eagle&amp;quot;);

    // Precache the weapon models and sounds
    // This might be called by the engine separately, but it&amp;#039;s best to call it here as well just in case.
    Precache();

    // Set the weapon ID
    m_iId = WEAPON_DESERT_EAGLE;

    // Tell the engine about the weapon&amp;#039;s world model
    SET_MODEL(ENT(pev), &amp;quot;models/w_desert_eagle.mdl&amp;quot;);

    // Set the default ammo value for the weapon
    m_iDefaultAmmo = DESERT_EAGLE_DEFAULT_GIVE;

    // Set up some default behaviour for the weapon
    // This will tell the engine that the weapon should &amp;quot;fall&amp;quot; to the ground when it spawns.
    // It also sets up the behaviour so that the weapon is equipped when the player touches it.
    FallInit();
}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="Precache"&gt;Precache&lt;/h2&gt;
The &lt;code&gt;Precache&lt;/code&gt; method is responsible for telling the engine what resources (sounds and models, mostly) that the weapon needs to have loaded in order to function correctly. This usually means the models for the weapon (world, model, and player) and the sounds for the weapon (shoot, reload, etc). Hopefully everything here is pretty understandable without extra explanation.
&lt;pre class="lang-cpp"&gt;&lt;code&gt;void CDesertEagle::Precache()
{
    // Precache models
    PRECACHE_MODEL(&amp;quot;models/v_desert_eagle.mdl&amp;quot;);
    PRECACHE_MODEL(&amp;quot;models/w_desert_eagle.mdl&amp;quot;);
    PRECACHE_MODEL(&amp;quot;models/p_desert_eagle.mdl&amp;quot;);
    PRECACHE_MODEL(&amp;quot;models/shell.mdl&amp;quot;);

    // Precache sounds
    PRECACHE_SOUND(&amp;quot;weapons/desert_eagle_fire.wav&amp;quot;);
    PRECACHE_SOUND(&amp;quot;weapons/desert_eagle_sight.wav&amp;quot;);
    PRECACHE_SOUND(&amp;quot;weapons/desert_eagle_sight2.wav&amp;quot;);
}&lt;/code&gt;&lt;/pre&gt;
You&amp;#039;ll notice that &lt;strong&gt;desert_eagle_reload.wav&lt;/strong&gt; isn&amp;#039;t precached here. This is because the reload sound is only played via a model event, and all sounds in model events are already precached by the &lt;code&gt;PRECACHE_MODEL&lt;/code&gt; call. You only need to precache models or sounds when you directly reference them somewhere in the code. The &lt;strong&gt;models/shell.mdl&lt;/strong&gt; file is used by the client-side code later, to eject an empty shell after a shot.&lt;br&gt;&lt;br&gt;&lt;strong&gt;Note:&lt;/strong&gt; Another resource type referenced in the &lt;code&gt;Precache&lt;/code&gt; method are &amp;quot;events&amp;quot; - used for client prediction. We won&amp;#039;t go into detail for events or client prediction yet - that&amp;#039;s covered later in this article.
&lt;h2 id="GetItemInfo"&gt;GetItemInfo&lt;/h2&gt;
The &lt;code&gt;GetItemInfo&lt;/code&gt; method populates a &lt;code&gt;ItemInfo&lt;/code&gt; struct in order to send information about the weapon to the client. Without this method, the weapon cannot be used in any way. The method should return &lt;code&gt;true&lt;/code&gt; when it&amp;#039;s done. Most of the values here should be fairly obvious, so just take a look at the implementation and comments below. Remember that we&amp;#039;re reusing the 357 ammo, so it&amp;#039;s referenced a few times here.
&lt;pre class="lang-cpp"&gt;&lt;code&gt;bool CDesertEagle::GetItemInfo(ItemInfo* p)
{
    // This should match the classname - the HUD uses it to find the matching .txt file in the sprites/ folder
    p-&amp;gt;pszName = STRING(pev-&amp;gt;classname);

    // The &amp;quot;primary&amp;quot; ammo type for this weapon and the maximum ammo of that type that the player can hold
    p-&amp;gt;pszAmmo1 = &amp;quot;357&amp;quot;;
    p-&amp;gt;iMaxAmmo1 = _357_MAX_CARRY;

    // Same as above, but for &amp;quot;secondary&amp;quot; ammo. This should be NULL and -1 for weapons with no secondary
    p-&amp;gt;pszAmmo2 = NULL;
    p-&amp;gt;iMaxAmmo2 = -1;

    // The size of a full clip
    p-&amp;gt;iMaxClip = DESERT_EAGLE_MAX_CLIP;

    // Special weapon flags - leave this as 0 for now, this is covered in a different article
    p-&amp;gt;iFlags = 0;

    // The &amp;quot;slot&amp;quot; in the HUD that the weapon appears in. This is a pistol, so it goes into slot 1 with the others
    p-&amp;gt;iSlot = 1;

    // The &amp;quot;position&amp;quot; in the HUD that the weapon is added to. We&amp;#039;ll put this after the magnum (which is in slot 1)
    p-&amp;gt;iPosition = 2;

    // Set the ID and auto-switching weights of the weapon
    p-&amp;gt;iId = m_iId = WEAPON_DESERT_EAGLE;
    p-&amp;gt;iWeight = DESERT_EAGLE_WEIGHT;

    return true;
}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="AddToPlayer"&gt;AddToPlayer&lt;/h2&gt;
This method is called when the weapon is picked up by (or given to) the player. Typically, this method just calls the default implementation in &lt;code&gt;CBasePlayerWeapon&lt;/code&gt;, and then sends a message to the client so the HUD can show the weapon icon in the &amp;quot;history&amp;quot; section.
&lt;pre class="lang-cpp"&gt;&lt;code&gt;bool CDesertEagle::AddToPlayer(CBasePlayer* pPlayer)
{
    // AddToPlayer returns true if the weapon was picked up
    if (CBasePlayerWeapon::AddToPlayer(pPlayer))
    {
        // Send a message to the client so the pickup icon can be shown
        MESSAGE_BEGIN(MSG_ONE, gmsgWeapPickup, NULL, pPlayer-&amp;gt;pev);
            WRITE_BYTE(m_iId);
        MESSAGE_END();
        return true;
    }
    return false;
}&lt;/code&gt;&lt;/pre&gt;

&lt;div class="embed-panel card card-info"&gt;&lt;div class="card-header"&gt;Half-Life Updated SDK specific notice&lt;/div&gt;&lt;div class="card-body"&gt;If you are using Solokiller&amp;#039;s updated Half-Life SDK, do not forget to include the &lt;code&gt;UserMessages.h&lt;/code&gt; header file or you will get a compile error saying that &lt;code&gt;gmsgWeapPickup&lt;/code&gt; is not defined.&lt;/div&gt;&lt;/div&gt;

&lt;h2 id="Deploy"&gt;Deploy&lt;/h2&gt;
The &lt;code&gt;Deploy&lt;/code&gt; method is quite simple for most weapons - you just call &lt;code&gt;DefaultDeploy&lt;/code&gt; with the appropriate arguments. That&amp;#039;s what we&amp;#039;ll do for the Desert Eagle as well:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;bool CDesertEagle::Deploy()
{
    return DefaultDeploy(
        &amp;quot;models/v_desert_eagle.mdl&amp;quot;, // Weapon view model
        &amp;quot;models/p_desert_eagle.mdl&amp;quot;, // Weapon player model
        DESERT_EAGLE_DRAW, // &amp;quot;Draw&amp;quot; animation index for the view model
        &amp;quot;onehanded&amp;quot;,       // Third person animation set for the weapon. We&amp;#039;ll use the generic &amp;quot;onehanded&amp;quot; animation set
        UseDecrement(),    // Flag whether or not to do client prediction or not
        pev-&amp;gt;body          // The weapon model&amp;#039;s &amp;quot;body&amp;quot; pointer
    );
}&lt;/code&gt;&lt;/pre&gt;
Note reference to &lt;code&gt;onehanded&lt;/code&gt; here - this string refers to the animation set that should be used when the weapon is being fired by another player. For weapons that are similar to the stock weapons, you can use an existing animation set, which is what we&amp;#039;re doing here. For weapons that require a different pose, you&amp;#039;ll need to edit all of the models in the &lt;strong&gt;models/player/&lt;/strong&gt; folder in order to add a new animation set. This only applies to multiplayer and even then, is an optional change since it involves a lot of work. You can see the existing animation sets by opening any player model in a viewer and looking at the sequences named &lt;code&gt;ref_aim_something&lt;/code&gt;, &lt;code&gt;crouch_aim_something&lt;/code&gt;, &lt;code&gt;ref_shoot_something&lt;/code&gt;, and &lt;code&gt;crouch_shoot_something&lt;/code&gt;, where &lt;code&gt;something&lt;/code&gt; is the name of the animation set.
&lt;h2 id="Holster"&gt;Holster&lt;/h2&gt;
&lt;code&gt;Holster&lt;/code&gt; is slightly more complex than &lt;code&gt;Deploy&lt;/code&gt;, but not by much. This method should cancel any reload that&amp;#039;s currently taking place, and then hide the weapon from view. For most weapons, this is done with a &amp;quot;holster&amp;quot; animation, but you can also just use the default implementation of the &lt;code&gt;Holster&lt;/code&gt; method, which just hides the weapons from view.
&lt;pre class="lang-cpp"&gt;&lt;code&gt;void CDesertEagle::Holster(int skiplocal)
{
    // Cancel any reload in progress
    m_fInReload = false;

    // Delay the next player&amp;#039;s attack for about the same time as the holster animation takes
    m_pPlayer-&amp;gt;m_flNextAttack = UTIL_WeaponTimeBase() + 0.5;

    // Play the &amp;quot;holster&amp;quot; animation
    SendWeaponAnim(DESERT_EAGLE_HOLSTER);
}&lt;/code&gt;&lt;/pre&gt;
A note about &lt;code&gt;UTIL_WeaponTimeBase()&lt;/code&gt; - this is a client-side call that will return a set delay, if required by the client for prediction purposes. When setting delay values in weapons code, you should always add &lt;code&gt;UTIL_WeaponTimeBase()&lt;/code&gt; to the value to ensure the client prediction works properly.
&lt;h2 id="Client_changes"&gt;Client changes&lt;/h2&gt;
Before we finish up here, we need to make sure the client and HUD knows about the new weapon, so it can handle it properly. In the client project, open &lt;strong&gt;hl_weapons.cpp&lt;/strong&gt;. Towards the top of this file, you&amp;#039;ll see some variables defined for each weapon. Add a definition for the new weapon here.
&lt;pre class="lang-cpp"&gt;&lt;code&gt;// HLDM Weapon placeholder entities.
CGlock g_Glock;
// ... more code ...
CSqueak g_Snark;
CDesertEagle g_DesertEagle; // Add this line&lt;/code&gt;&lt;/pre&gt;
Next, scroll down and find the &lt;code&gt;HUD_InitClientWeapons&lt;/code&gt; method. Here you&amp;#039;ll see a series of &lt;code&gt;HUD_PrepEntity&lt;/code&gt; calls - one for each weapon. Add a new line for your weapon.
&lt;pre class="lang-cpp"&gt;&lt;code&gt;// Allocate slot(s) for each weapon that we are going to be predicting
HUD_PrepEntity( &amp;amp;g_Glock    , &amp;amp;player );
// ... more code ...
HUD_PrepEntity( &amp;amp;g_Snark    , &amp;amp;player );
HUD_PrepEntity( &amp;amp;g_DesertEagle, &amp;amp;player ); // Add this line&lt;/code&gt;&lt;/pre&gt;
Finally, scroll down a little more to find &lt;code&gt;HUD_WeaponsPostThink&lt;/code&gt;. There&amp;#039;s a &lt;code&gt;switch&lt;/code&gt; statement here that you&amp;#039;ll need to add a &lt;code&gt;case&lt;/code&gt; to:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;switch ( from-&amp;gt;client.m_iId )
{
    case WEAPON_CROWBAR:
        pWeapon = &amp;amp;g_Crowbar;
        break;

    // ... more code ...

    // Add this case statement
    case WEAPON_DESERT_EAGLE:
        pWeapon = &amp;amp;g_DesertEagle;
        break;
}&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="Reviewing_your_progress"&gt;Reviewing your progress&lt;/h1&gt;
If you&amp;#039;ve followed the tutorial up until this point, you should be able to compile your mod, and run &lt;code&gt;give weapon_eagle&lt;/code&gt; in the console to verify that the weapon is showing up. Run &lt;code&gt;give item_suit&lt;/code&gt; as well, if you don&amp;#039;t have one, so you can see the weapon in the HUD. It won&amp;#039;t shoot at the moment or do anything useful - but you should be able to select it and see the weapon model in-game.
&lt;div class="embed-panel card card-info"&gt;&lt;div class="card-body"&gt;If you are still having problem to spawn the weapon, double check your progress. If it&amp;#039;s still not working, check both of your &lt;code&gt;hl_cdll&lt;/code&gt; and &lt;code&gt;hldll&lt;/code&gt;, and make sure they have &lt;strong&gt;deserteagle.cpp&lt;/strong&gt; in each of them. If you are missing either of them, simply add the cpp by right click on the &lt;code&gt;dlls&lt;/code&gt; folder and press &lt;code&gt;Add&lt;/code&gt;. Select &lt;code&gt;Existing file&lt;/code&gt; and find your  &lt;strong&gt;deserteagle.cpp&lt;/strong&gt;. This should fix the problem.&lt;/div&gt;&lt;/div&gt;
In relation to the HUD: we&amp;#039;ve taken a shortcut with the HUD sprites by copying the files directly from Opposing Force. Take a short break from programming to look at the files you copied from the sprites folder - specifically, the &lt;strong&gt;sprites/weapon_eagle.txt&lt;/strong&gt; file. This file should be named the same as your weapon&amp;#039;s classname, and &lt;strong&gt;must&lt;/strong&gt; be present in order for the weapon to appear in the HUD. The file format is explained in detail in the &lt;a href="https://twhl.info/wiki/page/Weapons_Programming_-_High-Level_Overview"&gt;High-Level Overview&lt;/a&gt; article, so be sure to read through it.&lt;br&gt;&lt;br&gt;If you try to run &lt;code&gt;impulse 101&lt;/code&gt;, you&amp;#039;ll notice that your weapon isn&amp;#039;t given to the player. Let&amp;#039;s take care of that and one other small thing before we continue. Open &lt;strong&gt;player.cpp&lt;/strong&gt; and search for the &lt;code&gt;CheatImpulseCommands&lt;/code&gt; function. Somewhere in the &lt;code&gt;case 101:&lt;/code&gt; section, add a line for your weapon:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;case 101:
    gEvilImpulse101 = true;
    // ... code ...
    GiveNamedItem( &amp;quot;weapon_eagle&amp;quot; ); // Add this line
    // ... more code ...
    gEvilImpulse101 = false;
    break;&lt;/code&gt;&lt;/pre&gt;
The other small thing to take care of here is to add your weapon to the list of &lt;a href="https://twhl.info/wiki/page/func_breakable"&gt;func_breakable&lt;/a&gt; drop items. Open &lt;strong&gt;func_break.cpp&lt;/strong&gt; and at the top, you&amp;#039;ll see an array called &lt;code&gt;CBreakable::pSpawnObjects&lt;/code&gt;. Add your weapon classname to this array. This list corresponds to the FGD file - don&amp;#039;t forget to add it to the FGD when you&amp;#039;re making changes to it.
&lt;pre class="lang-cpp"&gt;&lt;code&gt;const char *CBreakable::pSpawnObjects[] =
{
    NULL,                // 0
    // ... code ...
    &amp;quot;weapon_hornetgun&amp;quot;,  // 21
    &amp;quot;weapon_eagle&amp;quot;, // 22 &amp;lt;- add this line
};&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="Implement_shooting_mechanics"&gt;Implement shooting mechanics&lt;/h1&gt;
Let&amp;#039;s get to the real code - shooting and reloading. At the end of this section, the weapon will shoot, reload, and do idle animations. The gun will be fully functional - except the Desert Eagle&amp;#039;s iconic laser sight, which we&amp;#039;ll add later. You might be able to guess which methods need to be implemented for these features, but here they are anyway:
&lt;ul&gt;&lt;li&gt;Client-side event code in &lt;strong&gt;ev_hldm.cpp&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;PrimaryAttack&lt;/li&gt;&lt;li&gt;Reload&lt;/li&gt;&lt;li&gt;WeaponIdle&lt;/li&gt;&lt;/ul&gt;
Again, these methods are fairly similar for most weapons, so you can take a look at the other weapon implementations for a good starting point. Let&amp;#039;s implement these methods now.
&lt;h2 id="Client-side_event_code"&gt;Client-side event code&lt;/h2&gt;
Weapon firing happens on the server-side, but most of the actual effects happen on the client side. Without the client-side changes we&amp;#039;re about to make, the shooting animation will look very strange. The shooting animation happens on the client side before the server applies the actual damage, so the game feels more responsive to players in multiplayer.&lt;br&gt;&lt;br&gt;The client event code simply plays the sound and animation that the player would expect to see when they fire the weapon. The event is loaded by the weapon&amp;#039;s class, in the &lt;code&gt;Precache&lt;/code&gt; method. Before we can do that, however, we need a new variable to hold the event resource. Go to &lt;strong&gt;weapons.h&lt;/strong&gt; and add this field to the &lt;code&gt;private&lt;/code&gt; section of your &lt;code&gt;CDesertEagle&lt;/code&gt; class:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;class CDesertEagle : public CBasePlayerWeapon
{
public:
    // no changes in the public section
private:
    unsigned short m_usFireDesertEagle;
};&lt;/code&gt;&lt;/pre&gt;
Now go into &lt;strong&gt;deserteagle.cpp&lt;/strong&gt; and add this to the end of the &lt;code&gt;Precache&lt;/code&gt; method:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;// Precache fire event
m_usFireDesertEagle = PRECACHE_EVENT(1, &amp;quot;events/eagle.sc&amp;quot;);&lt;/code&gt;&lt;/pre&gt;
There&amp;#039;s that &lt;strong&gt;event.sc&lt;/strong&gt; file you copied earlier. The secret of this file is.... the contents don&amp;#039;t matter. It can be empty, and it makes no difference. All that matters is that this file exists - the name of the file is used, and nothing else.&lt;br&gt;&lt;br&gt;That&amp;#039;s all for loading the event, now let&amp;#039;s implement the event handler. Go to &lt;strong&gt;hl_events.cpp&lt;/strong&gt; and add a method definition for &lt;code&gt;EV_FireDesertEagle&lt;/code&gt; at the top of the file, and a &lt;code&gt;pfnHookEvent&lt;/code&gt; call for your event inside &lt;code&gt;Game_HookEvents&lt;/code&gt;:
&lt;div class="embed-panel card card-info"&gt;&lt;div class="card-header"&gt;Half-Life Updated SDK specific notice&lt;/div&gt;&lt;div class="card-body"&gt;If you are using Solokiller&amp;#039;s updated Half-Life SDK, declare the fire event in the &lt;code&gt;ev_hldm.h&lt;/code&gt; instead.&lt;/div&gt;&lt;/div&gt;

&lt;pre class="lang-cpp"&gt;&lt;code&gt;extern &amp;quot;C&amp;quot;
{
// ... code ...
void EV_FireDesertEagle( struct event_args_s *args );
}

void Game_HookEvents( void )
{
    // ... more code ...
    gEngfuncs.pfnHookEvent(&amp;quot;events/eagle.sc&amp;quot;, EV_FireDesertEagle);
}&lt;/code&gt;&lt;/pre&gt;
Next, we&amp;#039;ll go into &lt;strong&gt;ev_hldm.cpp&lt;/strong&gt; and add the same definition to the top of the file:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;extern &amp;quot;C&amp;quot;
{
// ... code ...
void EV_FireDesertEagle( struct event_args_s *args );
}&lt;/code&gt;&lt;/pre&gt;
Scroll down a little and add the function implementation somewhere in this file. This code is mostly borrowed from the glock fire event, with small tweaks:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;//======================
// DESERT EAGLE START
//======================

// Exactly the same enum from deserteagle.cpp, these
// values correspond to sequences in the viewmodel file
enum desert_eagle_e {
    DESERT_EAGLE_IDLE1 = 0,
    DESERT_EAGLE_IDLE2,
    DESERT_EAGLE_IDLE3,
    DESERT_EAGLE_IDLE4,
    DESERT_EAGLE_IDLE5,
    DESERT_EAGLE_SHOOT,
    DESERT_EAGLE_SHOOT_EMPTY,
    DESERT_EAGLE_RELOAD,
    DESERT_EAGLE_RELOAD_NOT_EMPTY,
    DESERT_EAGLE_DRAW,
    DESERT_EAGLE_HOLSTER,
};

void EV_FireDesertEagle( event_args_t *args )
{
    // Just a bunch of variables and boilerplate copy/paste code
    int idx;
    vec3_t origin;
    vec3_t angles;
    vec3_t velocity;
    bool empty;

    vec3_t ShellVelocity;
    vec3_t ShellOrigin;
    int shell;
    vec3_t vecSrc, vecAiming;
    vec3_t up, right, forward;

    idx = args-&amp;gt;entindex;
    VectorCopy(args-&amp;gt;origin, origin);
    VectorCopy(args-&amp;gt;angles, angles);
    VectorCopy(args-&amp;gt;velocity, velocity);

    empty = 0 != args-&amp;gt;bparam1;
    AngleVectors(angles, forward, right, up);

    shell = gEngfuncs.pEventAPI-&amp;gt;EV_FindModelIndex(&amp;quot;models/shell.mdl&amp;quot;);// brass shell

    // If the entity firing this event is the player
    if (EV_IsLocal(idx))
    {
        // Render a muzzleflash
        EV_MuzzleFlash();

        // Show the weapon animation (a different one if this was the last bullet in the clip)
        gEngfuncs.pEventAPI-&amp;gt;EV_WeaponAnimation(empty ? DESERT_EAGLE_SHOOT_EMPTY : DESERT_EAGLE_SHOOT, 0);

        // Apply some recoil to the player&amp;#039;s view
        V_PunchAxis(0, -4.0);
    }

    // Eject an empty bullet shell (the numbers here are mostly magic, experiment with them or just use whatever, it&amp;#039;s not too important)
    EV_GetDefaultShellInfo(args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, -9.0, 14.0, 9.0);
    EV_EjectBrass(ShellOrigin, ShellVelocity, angles[YAW], shell, TE_BOUNCE_SHELL);

    // Play the &amp;quot;shoot&amp;quot; sound
    gEngfuncs.pEventAPI-&amp;gt;EV_PlaySound(idx, origin, CHAN_WEAPON, &amp;quot;weapons/desert_eagle_fire.wav&amp;quot;, gEngfuncs.pfnRandomFloat(0.92, 1), ATTN_NORM, 0, 98 + gEngfuncs.pfnRandomLong(0, 3));

    // Fire some bullets (this will do some prediction stuff, show a tracer, play texture sound, and render a decal where the bullet hits)
    EV_GetGunPosition(args, vecSrc, origin);
    VectorCopy(forward, vecAiming);
    EV_HLDM_FireBullets(idx, forward, right, up, 1, vecSrc, vecAiming, 8192, BULLET_PLAYER_357, 0, 0, args-&amp;gt;fparam1, args-&amp;gt;fparam2);
}

//======================
// DESERT EAGLE END
//======================&lt;/code&gt;&lt;/pre&gt;
That&amp;#039;s everything for &lt;strong&gt;ev_hldm.cpp&lt;/strong&gt;. Go back to &lt;strong&gt;deserteagle.cpp&lt;/strong&gt; for the next parts.
&lt;h2 id="PrimaryAttack"&gt;PrimaryAttack&lt;/h2&gt;
This method is called, as you might expect, when the player presses the &amp;quot;Fire&amp;quot; key, which is usually the mouse1 button. This method should make sure the gun is allowed to fire (check if the player&amp;#039;s underwater, check if the clip is empty, etc), and then actually perform the firing. The following code is very similar to the existing code for the .357 magnum:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;void CDesertEagle::PrimaryAttack()
{
    // Don&amp;#039;t fire underwater - waterlevel 3 indicates that the player&amp;#039;s head is underwater
    if (m_pPlayer-&amp;gt;pev-&amp;gt;waterlevel == 3)
    {
        // Play a &amp;quot;click&amp;quot; and don&amp;#039;t allow another primary attack for a short time
        PlayEmptySound();
        m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.15;
        return;
    }

    // Check if the clip is empty
    if (m_iClip &amp;lt;= 0)
    {
        if (!m_fInReload &amp;amp;&amp;amp; m_fFireOnEmpty)
        {
            // If the player has fired previously, but is still holding the attack button down,
            // just play the empty &amp;quot;click&amp;quot; sound until the player releases the button.
            PlayEmptySound();
            m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
        }

        return;
    }

    // If we get to this point - we&amp;#039;re shooting!

    m_pPlayer-&amp;gt;m_iWeaponVolume = NORMAL_GUN_VOLUME;
    m_pPlayer-&amp;gt;m_iWeaponFlash = NORMAL_GUN_FLASH;

    // Decrease the number of bullets in the clip
    m_iClip--;

    // Add a muzzleflash to the player effects
    m_pPlayer-&amp;gt;pev-&amp;gt;effects |= EF_MUZZLEFLASH;

    // Player &amp;quot;shoot&amp;quot; animation
    m_pPlayer-&amp;gt;SetAnimation(PLAYER_ATTACK1);

    // Set global vectors in the engine (don&amp;#039;t ask)
    UTIL_MakeVectors(m_pPlayer-&amp;gt;pev-&amp;gt;v_angle + m_pPlayer-&amp;gt;pev-&amp;gt;punchangle);

    // Shoot bullets!
    Vector vecSrc = m_pPlayer-&amp;gt;GetGunPosition();
    Vector vecAiming = m_pPlayer-&amp;gt;GetAutoaimVector(AUTOAIM_10DEGREES);
    Vector vecDir = m_pPlayer-&amp;gt;FireBulletsPlayer(
        1,                     // Number of bullets to shoot
        vecSrc,                // The source of the bullets (i.e. the gun)
        vecAiming,             // The direction to fire in (i.e. where the player is pointing)
        VECTOR_CONE_10DEGREES, // The accuracy spread of the weapon
        8192,                  // The distance the bullet can go (8192 is the limit for the engine)
        BULLET_PLAYER_357,     // The type of bullet being fired
        0,                     // Number of tracer bullets to fire (none in this case)
        0,                     // Set to non-zero to override the amount of damage (usually, leave this as 0)
        m_pPlayer-&amp;gt;pev,        // Attacker entity
        m_pPlayer-&amp;gt;random_seed // The random seed
    );

    int flags;
#if defined( CLIENT_WEAPONS )
    flags = FEV_NOTHOST;
#else
    flags = 0;
#endif

    PLAYBACK_EVENT_FULL(flags, m_pPlayer-&amp;gt;edict(), m_usFireDesertEagle, 0.0, (float*)&amp;amp;g_vecZero, (float*)&amp;amp;g_vecZero, vecDir.x, vecDir.y, 0, 0, (m_iClip == 0) ? 1 : 0, 0);

    // If the clip is now empty and there&amp;#039;s no more ammo available, update the HEV
    if (!m_iClip &amp;amp;&amp;amp; m_pPlayer-&amp;gt;m_rgAmmo[m_iPrimaryAmmoType] &amp;lt;= 0)
    {
        // HEV suit - indicate out of ammo condition
        m_pPlayer-&amp;gt;SetSuitUpdate(&amp;quot;!HEV_AMO0&amp;quot;, false, 0);
    }

    // The desert eagle can fire quite quickly with no laser spot, so use a 250ms delay
    m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.25;

    // Set the time until the weapon should start idling again
    m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + UTIL_SharedRandomFloat(m_pPlayer-&amp;gt;random_seed, 10, 15);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="Reload"&gt;Reload&lt;/h2&gt;
Compared to the two previous methods, the reload method is thankfully very easy to implement. We simply check to make sure that the player needs to reload and has enough ammo to reload, and if those are true, then we call the &lt;code&gt;DefaultReload&lt;/code&gt; function.
&lt;pre class="lang-cpp"&gt;&lt;code&gt;void CDesertEagle::Reload()
{
    // Don&amp;#039;t reload if the player doesn&amp;#039;t have any ammo
    if (m_pPlayer-&amp;gt;ammo_357 &amp;lt;= 0) return;

    int iResult;

    // The view model has two different animations depending on if there are any bullets in the clip
    if (m_iClip == 0) iResult = DefaultReload(DESERT_EAGLE_MAX_CLIP, DESERT_EAGLE_RELOAD, 1.5);
    else iResult = DefaultReload(DESERT_EAGLE_MAX_CLIP, DESERT_EAGLE_RELOAD_NOT_EMPTY, 1.5);

    if (iResult)
    {
        // If the reload happened, then reset the weapon&amp;#039;s idle time
        m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + UTIL_SharedRandomFloat(m_pPlayer-&amp;gt;random_seed, 10, 15);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="WeaponIdle"&gt;WeaponIdle&lt;/h2&gt;
&lt;code&gt;WeaponIdle&lt;/code&gt; must be implemented to make sure idle animations are shown while the player isn&amp;#039;t doing anything while holding the gun. It can also be used to randomly switch between different idle animations to keep things interesting. The Desert Eagle model has 5 idle animations, so we use the random number utility to switch between each of them:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;void CDesertEagle::WeaponIdle()
{
    // This is used in conjunction with the PlayEmptySound function.
    // This resets a flag so the &amp;quot;click&amp;quot; for an empty weapon can be replayed after a short delay
    ResetEmptySound();

    // Despite the name, this will SET the autoaim vector.
    // 10 degrees is what the magnum uses, so we&amp;#039;ll use the same.
    m_pPlayer-&amp;gt;GetAutoaimVector(AUTOAIM_10DEGREES);

    // Exit out of the method if the weapon time hasn&amp;#039;t passed yet or if the clip is empty
    if (m_flTimeWeaponIdle &amp;gt; UTIL_WeaponTimeBase() || m_iClip &amp;lt;= 0) return;

    // Weapon idle is only called after the weapon hasn&amp;#039;t been used (fired or reloaded)
    // for a while. In this case we want to play one of the idle animations for the weapon.
    // The desert eagle view model has 5 different idle animations, and we&amp;#039;ll give each one
    // a 20% chance of playing, using the random number util function.
    int iAnim;
    float flRand = UTIL_SharedRandomFloat(m_pPlayer-&amp;gt;random_seed, 0, 1);

    if (flRand &amp;lt;= 0.2)
    {
        // The numbers here (76.0 / 30.0) are a way to represent the time taken by the
        // animation, so the next idle animation isn&amp;#039;t played before the current one has
        // been completed. This animation is 76 frames long, and runs at 30 frames per second.
        iAnim = DESERT_EAGLE_IDLE1;
        m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + (76.0 / 30.0);
    }
    else if (flRand &amp;lt;= 0.4)
    {
        iAnim = DESERT_EAGLE_IDLE2;
        m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + (61.0 / 24.0);
    }
    else if (flRand &amp;lt;= 0.6)
    {
        iAnim = DESERT_EAGLE_IDLE3;
        m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + (50.0 / 30.0);
    }
    else if (flRand &amp;lt;= 0.8)
    {
        iAnim = DESERT_EAGLE_IDLE4;
        m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + (76.0 / 30.0);
    }
    else
    {
        iAnim = DESERT_EAGLE_IDLE5;
        m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + (61.0 / 30.0);
    }

    // Play the idle animation
    SendWeaponAnim(iAnim, UseDecrement(), pev-&amp;gt;body);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="Optional:_Adding_the_laser_spot"&gt;Optional: Adding the laser spot&lt;/h1&gt;
The laser spot is very specific to the Desert Eagle and it&amp;#039;s unlikely that most of your weapons will use one. But for the sake of completion, let&amp;#039;s add it in as well. For most of the implementation of the laser spot, we&amp;#039;ll be looking at the RPG (as it already has a laser spot).
&lt;h2 id="Update_the_class_declaration"&gt;Update the class declaration&lt;/h2&gt;
First, open &lt;strong&gt;weapons.h&lt;/strong&gt; and add the following changes to the &lt;code&gt;CDesertEagle&lt;/code&gt; class. These changes are directly from the &lt;code&gt;CRpg&lt;/code&gt; class and are required for the laser spot to work. Note that the &lt;code&gt;CLaserSpot&lt;/code&gt; class is referenced here - so make sure your &lt;code&gt;CDesertEagle&lt;/code&gt; is defined &lt;strong&gt;after&lt;/strong&gt; the &lt;code&gt;CLaserSpot&lt;/code&gt; class to avoid compile errors.&lt;br&gt;&lt;br&gt;At the top of the public block:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;#ifndef CLIENT_DLL
    bool Save(CSave&amp;amp; save);
    bool Restore(CRestore&amp;amp; restore);
    static TYPEDESCRIPTION m_SaveData[];
#endif&lt;/code&gt;&lt;/pre&gt;
And after &lt;code&gt;WeaponIdle()&lt;/code&gt;:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;void UpdateSpot();
bool ShouldWeaponIdle() { return true; };

CLaserSpot* m_pSpot;
int m_fSpotActive;&lt;/code&gt;&lt;/pre&gt;
The &lt;code&gt;Save&lt;/code&gt; and &lt;code&gt;Restore&lt;/code&gt; methods need to be added now that we&amp;#039;ve added a custom field to the class - &lt;code&gt;m_fSpotActive&lt;/code&gt;. This will be a flag to detect when the spot is active. To maintain this state between saves, we need to implement save/restore for the class. This is also why the field needs to be public - so the save/restore code can access it. We won&amp;#039;t need to save the actual laser spot object (&lt;code&gt;m_pSpot&lt;/code&gt;), since we can create this as-needed.&lt;br&gt;&lt;br&gt;The &lt;code&gt;UpdateSpot&lt;/code&gt; method is where the logic will go to .... update the spot. The other change - &lt;code&gt;ShouldWeaponIdle&lt;/code&gt; is slightly more nuanced. By default, the &lt;code&gt;WeaponIdle&lt;/code&gt; method is only called when the player isn&amp;#039;t doing something else (such as shooting or reloading). By overriding &lt;code&gt;ShouldWeaponIdle&lt;/code&gt;, we can force the &lt;code&gt;WeaponIdle&lt;/code&gt; method to always be called. We do this so we can always call &lt;code&gt;UpdateSpot&lt;/code&gt; so it can stay up-to-date.
&lt;h2 id="Implement_save/restore"&gt;Implement save/restore&lt;/h2&gt;
Go to &lt;strong&gt;weapons.cpp&lt;/strong&gt; next and scroll to the very end to find the save/restore logic for each of the default weapons. If you take a look at some of them, you&amp;#039;ll see a very standard pattern for this. Simply implement this pattern for the desert eagle class, and that&amp;#039;s all you need to do. Here&amp;#039;s the code to add:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;TYPEDESCRIPTION    CDesertEagle::m_SaveData[] =
{
    DEFINE_FIELD(CDesertEagle, m_fSpotActive, FIELD_INTEGER),
};
IMPLEMENT_SAVERESTORE(CDesertEagle, CBasePlayerWeapon);&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="Make_the_changes_to_the_weapon_code"&gt;Make the changes to the weapon code&lt;/h2&gt;
Finally, we need to implement the laser spot logic in the weapon code itself. Open &lt;strong&gt;deserteagle.cpp&lt;/strong&gt;, and let&amp;#039;s get started. Most of these changes are directly from the &lt;code&gt;CRpg&lt;/code&gt; class, so take a look there for more information.&lt;br&gt;&lt;br&gt;Taking a look at how the Desert Eagle in Opposing Force behaves, this is what we want for the laser spot:
&lt;ul&gt;&lt;li&gt;By default, the laser is off&lt;/li&gt;&lt;li&gt;The laser is toggled by pressing the secondary attack button&lt;/li&gt;&lt;li&gt;The laser plays a sound when toggled&lt;/li&gt;&lt;li&gt;When the laser is turned on, the gun shoots slower, but is more accurate&lt;/li&gt;&lt;li&gt;The laser disappears while the player is shooting or reloading, but reappears afterwards&lt;/li&gt;&lt;li&gt;If the laser is enabled and the player switches to another weapon and then back, the laser turns on (and plays the sound) when the weapon is re-selected&lt;/li&gt;&lt;/ul&gt;

&lt;h3 id="Precache_2"&gt;Precache&lt;/h3&gt;
First, add this line to the &lt;code&gt;Precache&lt;/code&gt; method. This simply ensures that the laser spot&amp;#039;s resources are precached properly.
&lt;pre class="lang-cpp"&gt;&lt;code&gt;UTIL_PrecacheOther( &amp;quot;laser_spot&amp;quot; );&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="Holster_2"&gt;Holster&lt;/h3&gt;
Next, we&amp;#039;ll change the &lt;code&gt;Holster&lt;/code&gt; code so that the laser is killed when the weapon is unequipped:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;#ifndef CLIENT_DLL
    // If the laser spot exists, kill it
    if (m_pSpot)
    {
        m_pSpot-&amp;gt;Killed(NULL, GIB_NEVER);
        m_pSpot = NULL;
    }
#endif&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="WeaponIdle_2"&gt;WeaponIdle&lt;/h3&gt;
First, add a call to &lt;code&gt;UpdateSpot()&lt;/code&gt; to the very top of the &lt;code&gt;WeaponIdle&lt;/code&gt; function, above &lt;code&gt;ResetEmptySound()&lt;/code&gt;. Next, if you take a close look at the idle animations for the Desert Eagle in Opposing Force, you&amp;#039;ll notice that 3 of the idle animations only play when the laser is off, and the other 2 only play when the laser is on. We&amp;#039;ll update this method so that this behaviour is the same as well. Here&amp;#039;s the updated version of this function:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;void CDesertEagle::WeaponIdle()
{
    // Update the laser spot
    UpdateSpot();

    // This is used in conjunction with the PlayEmptySound function.
    // This resets a flag so the &amp;quot;click&amp;quot; for an empty weapon can be replayed after a short delay
    ResetEmptySound();

    // Despite the name, this will SET the autoaim vector.
    // 10 degrees is what the magnum uses, so we&amp;#039;ll use the same.
    m_pPlayer-&amp;gt;GetAutoaimVector(AUTOAIM_10DEGREES);

    // Exit out of the method if the weapon time hasn&amp;#039;t passed yet or if the clip is empty
    if (m_flTimeWeaponIdle &amp;gt; UTIL_WeaponTimeBase() || m_iClip &amp;lt;= 0) return;

    // Weapon idle is only called after the weapon hasn&amp;#039;t been used (fired or reloaded)
    // for a while. In this case we want to play one of the idle animations for the weapon.
    // The desert eagle view model has 5 different idle animations, 1-3 will play when the laser
    // is off, and 4-5 will play when the laser is on.
    int iAnim;
    float flRand = UTIL_SharedRandomFloat(m_pPlayer-&amp;gt;random_seed, 0, 1);

    // When the laser is on, we&amp;#039;ll add 1 to the random result so that laser off
    // animations play when the value is between 0 and 1, and laser on animations
    // play when the value is between 1 and 2.
    if (m_fSpotActive) flRand += 1.01; // Add an extra .01 to ensure it&amp;#039;s always &amp;gt; 1

    // Laser off animations
    if (flRand &amp;lt;= 0.333)
    {
        // The numbers here (76.0 / 30.0) are a way to represent the time taken by the
        // animation, so the next idle animation isn&amp;#039;t played before the current one has
        // been completed. This animation is 76 frames long, and runs at 30 frames per second.
        iAnim = DESERT_EAGLE_IDLE1;
        m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + (76.0 / 30.0);
    }
    else if (flRand &amp;lt;= 0.667)
    {
        iAnim = DESERT_EAGLE_IDLE2;
        m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + (61.0 / 24.0);
    }
    else if (flRand &amp;lt;= 1)
    {
        iAnim = DESERT_EAGLE_IDLE3;
        m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + (50.0 / 30.0);
    }
    // Laser on animations
    else if (flRand &amp;lt;= 1.5)
    {
        iAnim = DESERT_EAGLE_IDLE4;
        m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + (76.0 / 30.0);
    }
    else
    {
        iAnim = DESERT_EAGLE_IDLE5;
        m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + (61.0 / 30.0);
    }

    // Play the idle animation
    SendWeaponAnim(iAnim, UseDecrement(), pev-&amp;gt;body);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="Reload_2"&gt;Reload&lt;/h3&gt;
When the player reloads, we want to hide the laser. Add this inside the &lt;code&gt;if (iResult)&lt;/code&gt; block in the &lt;code&gt;Reload&lt;/code&gt; function:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;#ifndef CLIENT_DLL
        // If the player is reloading, hide the laser until the reload is complete
        if (m_pSpot &amp;amp;&amp;amp; m_fSpotActive)
        {
            m_pSpot-&amp;gt;Suspend(1.6);
            m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 1.6;
        }
#endif&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="PrimaryAttack_2"&gt;PrimaryAttack&lt;/h3&gt;
There&amp;#039;s three changes we want to make to the &lt;code&gt;PrimaryAttack&lt;/code&gt; method: the accuracy should be better, shots should be slower, and the laser should be hidden for a short time during the fire animation. Let&amp;#039;s take care of each of these.&lt;br&gt;&lt;br&gt;Increasing the accuracy - this is done as part of the &lt;code&gt;FireBulletsPlayer&lt;/code&gt; call. We&amp;#039;ll simply change &lt;code&gt;VECTOR_CONE_10DEGREES&lt;/code&gt; to &lt;code&gt;VECTOR_CONE_1DEGREES&lt;/code&gt; when the spot is active. This is what we end up with:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;Vector vecDir = m_pPlayer-&amp;gt;FireBulletsPlayer(
    1,                     // Number of bullets to shoot
    vecSrc,                // The source of the bullets (i.e. the gun)
    vecAiming,             // The direction to fire in (i.e. where the player is pointing)
    m_fSpotActive ? VECTOR_CONE_1DEGREES : VECTOR_CONE_10DEGREES,  // The accuracy spread of the weapon
    8192,                  // The distance the bullet can go (8192 is the limit for the engine)
    BULLET_PLAYER_357,     // The type of bullet being fired
    0,                     // Number of tracer bullets to fire (none in this case)
    0,                     // Set to non-zero to override the amount of damage (usually, leave this as 0)
    m_pPlayer-&amp;gt;pev,        // Attacker entity
    m_pPlayer-&amp;gt;random_seed // The random seed
);&lt;/code&gt;&lt;/pre&gt;
Making shots slower - this is simply a matter of changing the value of &lt;code&gt;m_flNextPrimaryAttack&lt;/code&gt;, towards the end of the method. We&amp;#039;ll double the delay if the spot is active. Here&amp;#039;s the result:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;// The desert eagle can fire quite quickly with no laser spot, so use a 250ms delay
// When the spot is active, the delay should be 500ms instead.
m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + (m_fSpotActive ? 0.5 : 0.25);&lt;/code&gt;&lt;/pre&gt;
Hiding the laser - similar to the reload function, we&amp;#039;ll simply hide the laser for a short time. This goes directly after the previous code:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;#ifndef CLIENT_DLL
    // Hide the laser until the player can shoot again
    if (m_pSpot &amp;amp;&amp;amp; m_fSpotActive)
    {
        m_pSpot-&amp;gt;Suspend(0.6);
        m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.6;
    }
#endif&lt;/code&gt;&lt;/pre&gt;
Last but not least, we&amp;#039;ll call the &lt;code&gt;UpdateSpot&lt;/code&gt; method to make sure it stays up-to-date. This goes right at the end:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;// Keep the laser updated
UpdateSpot();&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="SecondaryAttack"&gt;SecondaryAttack&lt;/h3&gt;
Like the RPG, the secondary attack will toggle the laser spot on and off. However, the Desert Eagle also has sounds that play when the laser is toggled, so we&amp;#039;ll add code for that as well. This is what &lt;code&gt;SecondaryAttack&lt;/code&gt; should look like:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;void CDesertEagle::SecondaryAttack()
{
    // Toggle the laser
    m_fSpotActive = !m_fSpotActive;

#ifndef CLIENT_DLL
    // If the laser is being turned off, kill the laser
    if (!m_fSpotActive &amp;amp;&amp;amp; m_pSpot)
    {
        m_pSpot-&amp;gt;Killed(NULL, GIB_NORMAL);
        m_pSpot = NULL;
    }
#endif

    if (m_fSpotActive)
    {
        // If the spot is being turned on, play the ON sound and delay for a short time
        EMIT_SOUND(ENT(m_pPlayer-&amp;gt;pev), CHAN_ITEM, &amp;quot;weapons/desert_eagle_sight.wav&amp;quot;, 1, ATTN_NORM);
        m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.25;
    }
    else
    {
        // If the spot is being turned off, play the OFF sound and delay for a slightly longer time
        EMIT_SOUND(ENT(m_pPlayer-&amp;gt;pev), CHAN_ITEM, &amp;quot;weapons/desert_eagle_sight2.wav&amp;quot;, 1, ATTN_NORM);
        m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.5;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="UpdateSpot"&gt;UpdateSpot&lt;/h3&gt;
Finally, the new method: &lt;code&gt;UpdateSpot&lt;/code&gt;. This is just a copy-paste from the &lt;code&gt;CRpg&lt;/code&gt; class. Here&amp;#039;s the code:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;void CDesertEagle::UpdateSpot(void)
{
#ifndef CLIENT_DLL
    // If the spot is active
    if (m_fSpotActive)
    {
        // Make sure the spot entity has been created
        if (!m_pSpot)
        {
            m_pSpot = CLaserSpot::CreateSpot();
        }

        // Perform a TraceLine to find the point that the laser shines on
        UTIL_MakeVectors(m_pPlayer-&amp;gt;pev-&amp;gt;v_angle);
        Vector vecSrc = m_pPlayer-&amp;gt;GetGunPosition();
        Vector vecAiming = gpGlobals-&amp;gt;v_forward;

        TraceResult tr;
        UTIL_TraceLine(vecSrc, vecSrc + vecAiming * 8192, dont_ignore_monsters, ENT(m_pPlayer-&amp;gt;pev), &amp;amp;tr);

        // Put the laser spot at the end of the trace
        UTIL_SetOrigin(m_pSpot-&amp;gt;pev, tr.vecEndPos);
    }
#endif
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="A_small_tweak"&gt;A small tweak&lt;/h3&gt;
The weapon is basically complete at this point: but there&amp;#039;s one missing feature - when the laser is active, and the weapon is switched to from another weapon, you want to play the &amp;quot;laser on&amp;quot; sound when the laser appears. Now, you could probably do something in the &lt;code&gt;Deploy&lt;/code&gt; function to handle this, but there&amp;#039;s a different way. Instead of playing the &amp;quot;laser on&amp;quot; sound inside &lt;code&gt;SecondaryAttack&lt;/code&gt;, we could play it when the laser is created in the &lt;code&gt;UpdateSpot&lt;/code&gt; method.&lt;br&gt;&lt;br&gt;Go into the &lt;code&gt;SecondaryAttack&lt;/code&gt; method, and cut the &lt;code&gt;EMIT_SOUND&lt;/code&gt; line for when the laser is being turned on. Keep it in the clipboard, because we&amp;#039;ll be pasting it into &lt;code&gt;UpdateSpot&lt;/code&gt; next.&lt;br&gt;&lt;br&gt;In &lt;code&gt;SecondaryAttack&lt;/code&gt;:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;if (m_fSpotActive)
{
    // If the spot is being turned on, play the ON sound and delay for a short time
    // Note: The &amp;quot;on&amp;quot; sound is handled by the UpdateSpot function so it works on Deploy as well!
    m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.25;
}
else
// ... more code ...&lt;/code&gt;&lt;/pre&gt;
Now go over to &lt;code&gt;UpdateSpot&lt;/code&gt; and add the &lt;code&gt;EMIT_SOUND&lt;/code&gt; line in:
&lt;pre class="lang-cpp"&gt;&lt;code&gt;// Make sure the spot entity has been created
if (!m_pSpot)
{
    m_pSpot = CLaserSpot::CreateSpot();

    // Play the &amp;quot;laser on&amp;quot; sound here, so it plays after a Deploy as well as a SecondaryAttack
    EMIT_SOUND(ENT(m_pPlayer-&amp;gt;pev), CHAN_ITEM, &amp;quot;weapons/desert_eagle_sight.wav&amp;quot;, 1, ATTN_NORM);
}
// ... more code ...&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="Another_small_tweak"&gt;Another small tweak&lt;/h3&gt;
If you compare your new Desert Eagle to Opposing Force... it looks pretty good! But if you look closely at the laser spot, you might notice that in OP4, it&amp;#039;s actually quite a bit smaller. In fact, if you compare the scales of the laser spots for the RPG and Desert Eagle, it&amp;#039;s actually half the size of RPG&amp;#039;s.&lt;div class="embedded image"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://twhl.info/wiki/embed/Weapons_Programming_-_Desert_Eagle_Sprite_Size_Comparison" alt="User posted image" /&gt;&lt;/span&gt;&lt;/div&gt;Fortunately, this only takes a very small tweak to your code to get the same effect. In &lt;code&gt;UpdateSpot&lt;/code&gt;, when creating the laser spot, simply set it&amp;#039;s scale to &lt;code&gt;0.5&lt;/code&gt;. That&amp;#039;s it!
&lt;pre class="lang-cpp"&gt;&lt;code&gt;// Make sure the spot entity has been created
if (!m_pSpot)
{
    m_pSpot = CLaserSpot::CreateSpot();
    m_pSpot-&amp;gt;pev-&amp;gt;scale = 0.5;

    // Play the &amp;quot;laser on&amp;quot; sound here, so it plays after a Deploy as well as a SecondaryAttack
    EMIT_SOUND(ENT(m_pPlayer-&amp;gt;pev), CHAN_ITEM, &amp;quot;weapons/desert_eagle_sight.wav&amp;quot;, 1, ATTN_NORM);
}&lt;/code&gt;&lt;/pre&gt;
Now the size of the laser spot will match Opposing Force. You might notice that OP4 uses a different sprite for the laser spot - if you want to use it, simply copy the &lt;strong&gt;gearbox/sprites/laserdot.spr&lt;/strong&gt; file into your mod. If you want you mod to use a different sprite for the Desert Eagle, you&amp;#039;ll need to make further changes to the &lt;code&gt;CLaserSpot&lt;/code&gt; class in order to make the sprite it uses more configurable.
&lt;h1 id="Make_the_changes_to_your_FGD"&gt;Make the changes to your FGD&lt;/h1&gt;
This is the last step of adding any new entity to your mod - update the FGD so you can place it in your editor! For weapons, doing this is very simple, since they rarely have any special keyvalues. Just add this to your FGD file:
&lt;pre class="lang-plaintext"&gt;&lt;code&gt;@PointClass base(Weapon, Targetx) studio(&amp;quot;models/w_desert_eagle.mdl&amp;quot;) = weapon_eagle : &amp;quot;Desert Eagle&amp;quot; []&lt;/code&gt;&lt;/pre&gt;
And don&amp;#039;t forget about the change to the &lt;a href="https://twhl.info/wiki/page/func_breakable"&gt;func_breakable&lt;/a&gt; definition as well! It&amp;#039;s in the &lt;code&gt;Breakable&lt;/code&gt; base class, just add your number and description for the weapon to the end:
&lt;pre class="lang-plaintext"&gt;&lt;code&gt;@BaseClass base(Targetname,Global) = Breakable
[
    ...
    spawnobject(choices) : &amp;quot;Spawn On Break&amp;quot; : 0 =
    [
        0: &amp;quot;Nothing&amp;quot;
        ...
        21: &amp;quot;Hornet Gun&amp;quot;
        22: &amp;quot;Desert Eagle&amp;quot;
    ]
    ...
]&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="Enjoy!"&gt;Enjoy!&lt;/h1&gt;
You&amp;#039;re finally finished! Hopefully you&amp;#039;ve been compiling your mod and checking the results as you go, but just in case you haven&amp;#039;t, do that now! &lt;a href="https://github.com/LogicAndTrick/halflife-updated/commit/tutorial-standard-weapons"&gt;Click here to see the full source code for this tutorial.&lt;/a&gt;</value>
  </data>
  <data name="StandardWeaponsProgrammingPageInput" xml:space="preserve">
    <value>[cat:Tutorials]
[cat:Programming]
[cat:Goldsource Tutorials]
[book:Half-Life Programming|chapter:Weapons Programming|chapternumber:2|pagenumber:3]
[credit:Original author|user:1983]

~~~info
:NOTICE
If you are programming for a single player mod and looking for a simpler approach, refer [[Tutorial: Add a new simple weapon (straightforward way)]].
~~~

This guide will walk through how to add a "regular" weapon to your Half-Life mod. In this case, "regular" means a gun that shoots bullets and reloads. In this article we'll be implementing the Desert Eagle pistol from Opposing Force into standard Half-Life. This guide assumes that you have experience programming in C++, and a programming environment and your custom mod already set up.

[video:Weapons Programming - Desert Eagle Demo|Here's what we'll be implementing in this tutorial]

You can view the commit containing all the code changes in this tutorial [https://github.com/LogicAndTrick/halflife-updated/commit/tutorial-standard-weapons|on GitHub by clicking here].

= Get the files from Opposing Force

Since this article isn't about modelling, animating, or sound design, we're just going to take the assets we need from the Opposing Force folder. Copy the following files into your mod, from the *gearbox* folder:

- events/eagle.sc
- models/p_desert_eagle.mdl
- models/v_desert_eagle.mdl
- models/w_desert_eagle.mdl
- sound/weapons/desert_eagle_fire.wav
- sound/weapons/desert_eagle_reload.wav
- sound/weapons/desert_eagle_sight.wav
- sound/weapons/desert_eagle_sight2.wav
- sprites/320hudof01.spr
- sprites/640hudof01.spr
- sprites/640hudof02.spr
- sprites/ofch1.spr
- sprites/weapon_eagle.txt

You might think that the OP4 HUD sprites will look a bit strange in the Half-Life HUD - you're right! Graphics design isn't part of this tutorial, so we're going to live with the out-of-place sprites. 

= Defining weapon constants

Let's start up by doing some of the less-important admin tasks related to adding a new weapon. For the purposes of this article, the Desert Eagle will share ammo with the .357 magnum, so we won't need to worry about adding a new ammo type. If you want a custom ammo type for your weapon, check [[Weapons Programming - Custom Ammo Types|Custom Ammo Types]] and the [[Weapons Programming - Zoomable Weapons|Zoomable Weapons]] article.

First we need to assign the weapon a new ID, as well as define some other constants. These are in *weapons.h*, so open it now. Towards the top of the file, find the list of `#define` statements for each weapon. Add a new line for the new weapon. The value should be unique per weapon, so just increment the number of the last weapon.

```cpp
#define WEAPON_NONE          0
#define WEAPON_CROWBAR       1
// ... more lines here
#define WEAPON_SNARK        15
#define WEAPON_DESERT_EAGLE 16
```

~~~info
:Half-Life Updated SDK specific notice
If you are using Solokiller's updated Half-Life SDK, you need to add the weapon ID in `cdll_dll.h` as well.
~~~


Next, we'll define the weight. Just underneath the weapon IDs are the weapon weight constants. I'll make the weight for the Desert Eagle to be the same as the magnum.

```cpp
#define CROWBAR_WEIGHT     0
#define GLOCK_WEIGHT       10
#define PYTHON_WEIGHT      15
// ... more lines here
#define TRIPMINE_WEIGHT    10
#define DESERT_EAGLE_WEIGHT 15
```

As we're not adding a new ammo type, we can skip the `MAX_CARRY` block, so move on to the `MAX_CLIP` block. Add the relevant line to the end of this group.

```cpp
#define GLOCK_MAX_CLIP       13
#define PYTHON_MAX_CLIP      6
// ... more lines here
#define SNARK_MAX_CLIP       WEAPON_NOCLIP
#define DESERT_EAGLE_MAX_CLIP 7
```

Same goes for the `DEFAULT_GIVE` constant as well.

```cpp
#define GLOCK_DEFAULT_GIVE          13
#define PYTHON_DEFAULT_GIVE         6
// ... more lines here
#define HIVEHAND_DEFAULT_GIVE       8
#define DESERT_EAGLE_DEFAULT_GIVE   7
```

Since we'll be reusing the magnum's ammo box, you can ignore the `AMMO_GIVE` section. That's it for constants.

= Creating a bare-bones weapon class

The next step is to get the gun in-game. By the end of this section, it'll be available and selectable as a weapon, but it won't do anything useful. Some tutorials will recommend that you copy and paste an existing weapon to get started. This is certainly faster, but let's write the weapon from scratch so that we have a good handle on programming a new weapon.

== Class declaration

The first thing to do is to define the class inside the *weapons.h* file. Open it now, and add this after the `CSqueak` definition:

```cpp
class CDesertEagle : public CBasePlayerWeapon
{
public:
	void Spawn();
	void Precache();
	int iItemSlot() { return 2; }
	bool GetItemInfo(ItemInfo *p);

	int AddToPlayer(CBasePlayer *pPlayer);
	void PrimaryAttack();
	void SecondaryAttack();
	bool Deploy();
	void Holster(int skiplocal = 0);
	void Reload();
	void WeaponIdle();

	virtual bool UseDecrement()
	{ 
#if defined( CLIENT_WEAPONS )
		return true;
#else
		return false;
#endif
	}
private:

};
```

This is your standard weapon class definition. There's no code here, just overrides of the base class methods, as documented in the [[Weapons Programming - High-Level Overview|High-Level Overview]] article. Additional changes will be needed to this class later, but this is the basic outline that we'll need to get started.

There's two things to note here before we continue. First, the value returned by `iItemSlot` will be 1 greater than the value used for `iSlot` in `GetItemInfo` later. Think of the `iItemSlot` value being 1-indexed, and the `iSlot` value being 0-indexed. Second, the `UseDecrement` method is defined in that way in order to handle client predictions. It's odd, but that's how it is.

== Basic class implementation

Now to get started on the real stuff. Create a new file called *deserteagle.cpp* in the *dlls* directory of your solution folder. Avoid using VS to create this file, because it'll probably put it in the wrong folder and make everything a mess. Then include the file in both of your projects:

- For the *hldll* project, expand "Source Files" and then "dlls" and add the file to this directory using "Add -&gt; Existing Item..."
- For the *cl_dll* project, expand "Source Files", and then "_hl/dlls" and add this file to this directory using "Add -&gt; Existing Item..."

Now let's prepare the bare minimum implementation of the `CDesertEagle` class. We'll start with a very empty implementation of each method:

```cpp
#include "extdll.h"
#include "util.h"
#include "cbase.h"
#include "weapons.h"
#include "player.h"

// These correspond directly to the sequences in the weapon's view model
enum desert_eagle_e {
    DESERT_EAGLE_IDLE1 = 0,
    DESERT_EAGLE_IDLE2,
    DESERT_EAGLE_IDLE3,
    DESERT_EAGLE_IDLE4,
    DESERT_EAGLE_IDLE5,
    DESERT_EAGLE_SHOOT,
    DESERT_EAGLE_SHOOT_EMPTY,
    DESERT_EAGLE_RELOAD,
    DESERT_EAGLE_RELOAD_NOT_EMPTY,
    DESERT_EAGLE_DRAW,
    DESERT_EAGLE_HOLSTER,
};

LINK_ENTITY_TO_CLASS(weapon_eagle, CDesertEagle)

void CDesertEagle::Spawn()
{

}

void CDesertEagle::Precache()
{

}

bool CDesertEagle::GetItemInfo(ItemInfo* p)
{
	return false;
}

bool CDesertEagle::AddToPlayer(CBasePlayer* pPlayer)
{
	return false;
}

void CDesertEagle::SecondaryAttack()
{

}

void CDesertEagle::PrimaryAttack()
{

}

bool CDesertEagle::Deploy()
{
	return false;
}

void CDesertEagle::Holster(int skiplocal)
{

}

void CDesertEagle::Reload()
{

}

void CDesertEagle::WeaponIdle()
{

}
```

That's a start - the project will compile. But it won't do much at this point, so we should add a bit more code.

= Bare minimum weapon code

Let's make the changes needed for the bare minimum functionality for a weapon: allowing the user to select the weapon in the HUD, and show the weapon model when it's equipped. To get to that point, we need to implement the following methods:

- Spawn
- Precache
- GetItemInfo
- AddToPlayer
- Deploy
- Holster

All of these methods are very similar for most weapons, so you can implement these methods fairly quickly by referencing a different weapon's code. We'll take a close look at each one in detail, but first we need to make one small change in a different file.

== Precache the weapon

For weapons and in-game items, we need to make sure they get precached when the map loads. Open *weapons.cpp* and fine the `W_Precache` method. You'll see a bunch of calls to `UTIL_PrecacheOther` and `UTIL_PrecacheOtherWeapon`. All you need to do is add a new line to this method for your new weapon's classname. Ignore the `#if !defined...` lines, they're not important. Add this line in the same place as the other precache calls, underneath the `weapon_357` line is a good place.

```cpp
UTIL_PrecacheOtherWeapon("weapon_eagle");
```

Now go back to *deserteagle.cpp* - let's start implementing some methods!

== Spawn

The `Spawn` method is called when the weapon entity appears in the world - when the gun is lying on the ground, ready to be picked up. Unless the weapon is given to the player by default, this is how the player will get your weapon. The `Spawn` method looks very similar for most weapons. See the comments for the details of each line in this function.

```cpp
void CDesertEagle::Spawn()
{
    // Define the classname of the entity
    // This is the name you should use to reference this entity name in your code base.
    pev-&gt;classname = MAKE_STRING("weapon_eagle");

    // Precache the weapon models and sounds
    // This might be called by the engine separately, but it's best to call it here as well just in case.
    Precache();

    // Set the weapon ID
    m_iId = WEAPON_DESERT_EAGLE;

    // Tell the engine about the weapon's world model
    SET_MODEL(ENT(pev), "models/w_desert_eagle.mdl");

    // Set the default ammo value for the weapon
    m_iDefaultAmmo = DESERT_EAGLE_DEFAULT_GIVE;

    // Set up some default behaviour for the weapon
    // This will tell the engine that the weapon should "fall" to the ground when it spawns.
    // It also sets up the behaviour so that the weapon is equipped when the player touches it.
    FallInit();
}
```

== Precache

The `Precache` method is responsible for telling the engine what resources (sounds and models, mostly) that the weapon needs to have loaded in order to function correctly. This usually means the models for the weapon (world, model, and player) and the sounds for the weapon (shoot, reload, etc). Hopefully everything here is pretty understandable without extra explanation.

```cpp
void CDesertEagle::Precache()
{
    // Precache models
    PRECACHE_MODEL("models/v_desert_eagle.mdl");
    PRECACHE_MODEL("models/w_desert_eagle.mdl");
    PRECACHE_MODEL("models/p_desert_eagle.mdl");
    PRECACHE_MODEL("models/shell.mdl");

    // Precache sounds
    PRECACHE_SOUND("weapons/desert_eagle_fire.wav");
    PRECACHE_SOUND("weapons/desert_eagle_sight.wav");
    PRECACHE_SOUND("weapons/desert_eagle_sight2.wav");
}
```

You'll notice that *desert_eagle_reload.wav* isn't precached here. This is because the reload sound is only played via a model event, and all sounds in model events are already precached by the `PRECACHE_MODEL` call. You only need to precache models or sounds when you directly reference them somewhere in the code. The *models/shell.mdl* file is used by the client-side code later, to eject an empty shell after a shot.

*Note:* Another resource type referenced in the `Precache` method are "events" - used for client prediction. We won't go into detail for events or client prediction yet - that's covered later in this article.

== GetItemInfo

The `GetItemInfo` method populates a `ItemInfo` struct in order to send information about the weapon to the client. Without this method, the weapon cannot be used in any way. The method should return `true` when it's done. Most of the values here should be fairly obvious, so just take a look at the implementation and comments below. Remember that we're reusing the 357 ammo, so it's referenced a few times here.

```cpp
bool CDesertEagle::GetItemInfo(ItemInfo* p)
{
    // This should match the classname - the HUD uses it to find the matching .txt file in the sprites/ folder
    p-&gt;pszName = STRING(pev-&gt;classname);

    // The "primary" ammo type for this weapon and the maximum ammo of that type that the player can hold
    p-&gt;pszAmmo1 = "357";
    p-&gt;iMaxAmmo1 = _357_MAX_CARRY;

    // Same as above, but for "secondary" ammo. This should be NULL and -1 for weapons with no secondary
    p-&gt;pszAmmo2 = NULL;
    p-&gt;iMaxAmmo2 = -1;

    // The size of a full clip
    p-&gt;iMaxClip = DESERT_EAGLE_MAX_CLIP;

    // Special weapon flags - leave this as 0 for now, this is covered in a different article
    p-&gt;iFlags = 0;

    // The "slot" in the HUD that the weapon appears in. This is a pistol, so it goes into slot 1 with the others
    p-&gt;iSlot = 1;

    // The "position" in the HUD that the weapon is added to. We'll put this after the magnum (which is in slot 1)
    p-&gt;iPosition = 2;

    // Set the ID and auto-switching weights of the weapon
    p-&gt;iId = m_iId = WEAPON_DESERT_EAGLE;
    p-&gt;iWeight = DESERT_EAGLE_WEIGHT;

    return true;
}
```

== AddToPlayer

This method is called when the weapon is picked up by (or given to) the player. Typically, this method just calls the default implementation in `CBasePlayerWeapon`, and then sends a message to the client so the HUD can show the weapon icon in the "history" section.

```cpp
bool CDesertEagle::AddToPlayer(CBasePlayer* pPlayer)
{
    // AddToPlayer returns true if the weapon was picked up
    if (CBasePlayerWeapon::AddToPlayer(pPlayer))
    {
        // Send a message to the client so the pickup icon can be shown
        MESSAGE_BEGIN(MSG_ONE, gmsgWeapPickup, NULL, pPlayer-&gt;pev);
            WRITE_BYTE(m_iId);
        MESSAGE_END();
        return true;
    }
    return false;
}
```

~~~info
:Half-Life Updated SDK specific notice
If you are using Solokiller's updated Half-Life SDK, do not forget to include the `UserMessages.h` header file or you will get a compile error saying that `gmsgWeapPickup` is not defined.
~~~

== Deploy

The `Deploy` method is quite simple for most weapons - you just call `DefaultDeploy` with the appropriate arguments. That's what we'll do for the Desert Eagle as well:

```cpp
bool CDesertEagle::Deploy()
{
    return DefaultDeploy(
        "models/v_desert_eagle.mdl", // Weapon view model
        "models/p_desert_eagle.mdl", // Weapon player model
        DESERT_EAGLE_DRAW, // "Draw" animation index for the view model
        "onehanded",       // Third person animation set for the weapon. We'll use the generic "onehanded" animation set
        UseDecrement(),    // Flag whether or not to do client prediction or not
        pev-&gt;body          // The weapon model's "body" pointer
    );
}
```

Note reference to `onehanded` here - this string refers to the animation set that should be used when the weapon is being fired by another player. For weapons that are similar to the stock weapons, you can use an existing animation set, which is what we're doing here. For weapons that require a different pose, you'll need to edit all of the models in the *models/player/* folder in order to add a new animation set. This only applies to multiplayer and even then, is an optional change since it involves a lot of work. You can see the existing animation sets by opening any player model in a viewer and looking at the sequences named `ref_aim_something`, `crouch_aim_something`, `ref_shoot_something`, and `crouch_shoot_something`, where `something` is the name of the animation set.

== Holster

`Holster` is slightly more complex than `Deploy`, but not by much. This method should cancel any reload that's currently taking place, and then hide the weapon from view. For most weapons, this is done with a "holster" animation, but you can also just use the default implementation of the `Holster` method, which just hides the weapons from view.

```cpp
void CDesertEagle::Holster(int skiplocal)
{
    // Cancel any reload in progress
    m_fInReload = false;

    // Delay the next player's attack for about the same time as the holster animation takes
    m_pPlayer-&gt;m_flNextAttack = UTIL_WeaponTimeBase() + 0.5;

    // Play the "holster" animation
    SendWeaponAnim(DESERT_EAGLE_HOLSTER);
}
```

A note about `UTIL_WeaponTimeBase()` - this is a client-side call that will return a set delay, if required by the client for prediction purposes. When setting delay values in weapons code, you should always add `UTIL_WeaponTimeBase()` to the value to ensure the client prediction works properly.

== Client changes

Before we finish up here, we need to make sure the client and HUD knows about the new weapon, so it can handle it properly. In the client project, open *hl_weapons.cpp*. Towards the top of this file, you'll see some variables defined for each weapon. Add a definition for the new weapon here.

```cpp
// HLDM Weapon placeholder entities.
CGlock g_Glock;
// ... more code ...
CSqueak g_Snark;
CDesertEagle g_DesertEagle; // Add this line
```

Next, scroll down and find the `HUD_InitClientWeapons` method. Here you'll see a series of `HUD_PrepEntity` calls - one for each weapon. Add a new line for your weapon.

```cpp
// Allocate slot(s) for each weapon that we are going to be predicting
HUD_PrepEntity( &amp;g_Glock	, &amp;player );
// ... more code ...
HUD_PrepEntity( &amp;g_Snark	, &amp;player );
HUD_PrepEntity( &amp;g_DesertEagle, &amp;player ); // Add this line
```

Finally, scroll down a little more to find `HUD_WeaponsPostThink`. There's a `switch` statement here that you'll need to add a `case` to:

```cpp
switch ( from-&gt;client.m_iId )
{
    case WEAPON_CROWBAR:
        pWeapon = &amp;g_Crowbar;
        break;

    // ... more code ...

    // Add this case statement
    case WEAPON_DESERT_EAGLE:
        pWeapon = &amp;g_DesertEagle;
        break;
}
```

= Reviewing your progress

If you've followed the tutorial up until this point, you should be able to compile your mod, and run `give weapon_eagle` in the console to verify that the weapon is showing up. Run `give item_suit` as well, if you don't have one, so you can see the weapon in the HUD. It won't shoot at the moment or do anything useful - but you should be able to select it and see the weapon model in-game.

~~~info
If you are still having problem to spawn the weapon, double check your progress. If it's still not working, check both of your `hl_cdll` and `hldll`, and make sure they have *deserteagle.cpp* in each of them. If you are missing either of them, simply add the cpp by right click on the `dlls` folder and press `Add`. Select `Existing file` and find your  *deserteagle.cpp*. This should fix the problem.
~~~

In relation to the HUD: we've taken a shortcut with the HUD sprites by copying the files directly from Opposing Force. Take a short break from programming to look at the files you copied from the sprites folder - specifically, the *sprites/weapon_eagle.txt* file. This file should be named the same as your weapon's classname, and *must* be present in order for the weapon to appear in the HUD. The file format is explained in detail in the [[Weapons Programming - High-Level Overview|High-Level Overview]] article, so be sure to read through it.

If you try to run `impulse 101`, you'll notice that your weapon isn't given to the player. Let's take care of that and one other small thing before we continue. Open *player.cpp* and search for the `CheatImpulseCommands` function. Somewhere in the `case 101:` section, add a line for your weapon:

```cpp
case 101:
    gEvilImpulse101 = true;
    // ... code ...
    GiveNamedItem( "weapon_eagle" ); // Add this line
    // ... more code ...
    gEvilImpulse101 = false;
    break;
```

The other small thing to take care of here is to add your weapon to the list of [[func_breakable]] drop items. Open *func_break.cpp* and at the top, you'll see an array called `CBreakable::pSpawnObjects`. Add your weapon classname to this array. This list corresponds to the FGD file - don't forget to add it to the FGD when you're making changes to it.

```cpp
const char *CBreakable::pSpawnObjects[] =
{
    NULL,                // 0
    // ... code ...
    "weapon_hornetgun",  // 21
    "weapon_eagle", // 22 &lt;- add this line
};
```

= Implement shooting mechanics

Let's get to the real code - shooting and reloading. At the end of this section, the weapon will shoot, reload, and do idle animations. The gun will be fully functional - except the Desert Eagle's iconic laser sight, which we'll add later. You might be able to guess which methods need to be implemented for these features, but here they are anyway:

- Client-side event code in *ev_hldm.cpp*
- PrimaryAttack
- Reload
- WeaponIdle

Again, these methods are fairly similar for most weapons, so you can take a look at the other weapon implementations for a good starting point. Let's implement these methods now.

== Client-side event code

Weapon firing happens on the server-side, but most of the actual effects happen on the client side. Without the client-side changes we're about to make, the shooting animation will look very strange. The shooting animation happens on the client side before the server applies the actual damage, so the game feels more responsive to players in multiplayer.

The client event code simply plays the sound and animation that the player would expect to see when they fire the weapon. The event is loaded by the weapon's class, in the `Precache` method. Before we can do that, however, we need a new variable to hold the event resource. Go to *weapons.h* and add this field to the `private` section of your `CDesertEagle` class:

```cpp
class CDesertEagle : public CBasePlayerWeapon
{
public:
    // no changes in the public section
private:
    unsigned short m_usFireDesertEagle;
};
```

Now go into *deserteagle.cpp* and add this to the end of the `Precache` method:

```cpp
// Precache fire event
m_usFireDesertEagle = PRECACHE_EVENT(1, "events/eagle.sc");
```

There's that *event.sc* file you copied earlier. The secret of this file is.... the contents don't matter. It can be empty, and it makes no difference. All that matters is that this file exists - the name of the file is used, and nothing else.

That's all for loading the event, now let's implement the event handler. Go to *hl_events.cpp* and add a method definition for `EV_FireDesertEagle` at the top of the file, and a `pfnHookEvent` call for your event inside [code]Game_HookEvents[/code]:

~~~info
:Half-Life Updated SDK specific notice
If you are using Solokiller's updated Half-Life SDK, declare the fire event in the `ev_hldm.h` instead.
~~~

```cpp
extern "C"
{
// ... code ...
void EV_FireDesertEagle( struct event_args_s *args );
}

void Game_HookEvents( void )
{
    // ... more code ...
    gEngfuncs.pfnHookEvent("events/eagle.sc", EV_FireDesertEagle);
}
```

Next, we'll go into *ev_hldm.cpp* and add the same definition to the top of the file:

```cpp
extern "C"
{
// ... code ...
void EV_FireDesertEagle( struct event_args_s *args );
}
```

Scroll down a little and add the function implementation somewhere in this file. This code is mostly borrowed from the glock fire event, with small tweaks:

```cpp
//======================
// DESERT EAGLE START
//======================

// Exactly the same enum from deserteagle.cpp, these
// values correspond to sequences in the viewmodel file
enum desert_eagle_e {
	DESERT_EAGLE_IDLE1 = 0,
	DESERT_EAGLE_IDLE2,
	DESERT_EAGLE_IDLE3,
	DESERT_EAGLE_IDLE4,
	DESERT_EAGLE_IDLE5,
	DESERT_EAGLE_SHOOT,
	DESERT_EAGLE_SHOOT_EMPTY,
	DESERT_EAGLE_RELOAD,
	DESERT_EAGLE_RELOAD_NOT_EMPTY,
	DESERT_EAGLE_DRAW,
	DESERT_EAGLE_HOLSTER,
};

void EV_FireDesertEagle( event_args_t *args )
{
	// Just a bunch of variables and boilerplate copy/paste code
	int idx;
	vec3_t origin;
	vec3_t angles;
	vec3_t velocity;
	bool empty;

	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	int shell;
	vec3_t vecSrc, vecAiming;
	vec3_t up, right, forward;

	idx = args-&gt;entindex;
	VectorCopy(args-&gt;origin, origin);
	VectorCopy(args-&gt;angles, angles);
	VectorCopy(args-&gt;velocity, velocity);

	empty = 0 != args-&gt;bparam1;
	AngleVectors(angles, forward, right, up);

	shell = gEngfuncs.pEventAPI-&gt;EV_FindModelIndex("models/shell.mdl");// brass shell

	// If the entity firing this event is the player
	if (EV_IsLocal(idx))
	{
		// Render a muzzleflash
		EV_MuzzleFlash();

		// Show the weapon animation (a different one if this was the last bullet in the clip)
		gEngfuncs.pEventAPI-&gt;EV_WeaponAnimation(empty ? DESERT_EAGLE_SHOOT_EMPTY : DESERT_EAGLE_SHOOT, 0);

		// Apply some recoil to the player's view
		V_PunchAxis(0, -4.0);
	}

	// Eject an empty bullet shell (the numbers here are mostly magic, experiment with them or just use whatever, it's not too important)
	EV_GetDefaultShellInfo(args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, -9.0, 14.0, 9.0);
	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[YAW], shell, TE_BOUNCE_SHELL);

	// Play the "shoot" sound
	gEngfuncs.pEventAPI-&gt;EV_PlaySound(idx, origin, CHAN_WEAPON, "weapons/desert_eagle_fire.wav", gEngfuncs.pfnRandomFloat(0.92, 1), ATTN_NORM, 0, 98 + gEngfuncs.pfnRandomLong(0, 3));

	// Fire some bullets (this will do some prediction stuff, show a tracer, play texture sound, and render a decal where the bullet hits)
	EV_GetGunPosition(args, vecSrc, origin);
	VectorCopy(forward, vecAiming);
	EV_HLDM_FireBullets(idx, forward, right, up, 1, vecSrc, vecAiming, 8192, BULLET_PLAYER_357, 0, 0, args-&gt;fparam1, args-&gt;fparam2);
}

//======================
// DESERT EAGLE END
//======================
```

That's everything for *ev_hldm.cpp*. Go back to *deserteagle.cpp* for the next parts.

== PrimaryAttack

This method is called, as you might expect, when the player presses the "Fire" key, which is usually the mouse1 button. This method should make sure the gun is allowed to fire (check if the player's underwater, check if the clip is empty, etc), and then actually perform the firing. The following code is very similar to the existing code for the .357 magnum:

```cpp
void CDesertEagle::PrimaryAttack()
{
    // Don't fire underwater - waterlevel 3 indicates that the player's head is underwater
    if (m_pPlayer-&gt;pev-&gt;waterlevel == 3)
    {
        // Play a "click" and don't allow another primary attack for a short time
        PlayEmptySound();
        m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.15;
        return;
    }

    // Check if the clip is empty
    if (m_iClip &lt;= 0)
    {
        if (!m_fInReload &amp;&amp; m_fFireOnEmpty)
        {
            // If the player has fired previously, but is still holding the attack button down,
            // just play the empty "click" sound until the player releases the button.
            PlayEmptySound();
            m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
        }

        return;
    }

    // If we get to this point - we're shooting!

	m_pPlayer-&gt;m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer-&gt;m_iWeaponFlash = NORMAL_GUN_FLASH;

    // Decrease the number of bullets in the clip
    m_iClip--;

    // Add a muzzleflash to the player effects
	m_pPlayer-&gt;pev-&gt;effects |= EF_MUZZLEFLASH;

    // Player "shoot" animation
    m_pPlayer-&gt;SetAnimation(PLAYER_ATTACK1);

    // Set global vectors in the engine (don't ask)
    UTIL_MakeVectors(m_pPlayer-&gt;pev-&gt;v_angle + m_pPlayer-&gt;pev-&gt;punchangle);

    // Shoot bullets!
    Vector vecSrc = m_pPlayer-&gt;GetGunPosition();
    Vector vecAiming = m_pPlayer-&gt;GetAutoaimVector(AUTOAIM_10DEGREES);
    Vector vecDir = m_pPlayer-&gt;FireBulletsPlayer(
        1,                     // Number of bullets to shoot
        vecSrc,                // The source of the bullets (i.e. the gun)
        vecAiming,             // The direction to fire in (i.e. where the player is pointing)
        VECTOR_CONE_10DEGREES, // The accuracy spread of the weapon
        8192,                  // The distance the bullet can go (8192 is the limit for the engine)
        BULLET_PLAYER_357,     // The type of bullet being fired
        0,                     // Number of tracer bullets to fire (none in this case)
        0,                     // Set to non-zero to override the amount of damage (usually, leave this as 0)
        m_pPlayer-&gt;pev,        // Attacker entity
        m_pPlayer-&gt;random_seed // The random seed
    );

    int flags;
#if defined( CLIENT_WEAPONS )
    flags = FEV_NOTHOST;
#else
    flags = 0;
#endif
    
    PLAYBACK_EVENT_FULL(flags, m_pPlayer-&gt;edict(), m_usFireDesertEagle, 0.0, (float*)&amp;g_vecZero, (float*)&amp;g_vecZero, vecDir.x, vecDir.y, 0, 0, (m_iClip == 0) ? 1 : 0, 0);

    // If the clip is now empty and there's no more ammo available, update the HEV
    if (!m_iClip &amp;&amp; m_pPlayer-&gt;m_rgAmmo[m_iPrimaryAmmoType] &lt;= 0)
    {
        // HEV suit - indicate out of ammo condition
        m_pPlayer-&gt;SetSuitUpdate("!HEV_AMO0", false, 0);
    }

    // The desert eagle can fire quite quickly with no laser spot, so use a 250ms delay
    m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.25;

    // Set the time until the weapon should start idling again
    m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + UTIL_SharedRandomFloat(m_pPlayer-&gt;random_seed, 10, 15);
}
```

== Reload

Compared to the two previous methods, the reload method is thankfully very easy to implement. We simply check to make sure that the player needs to reload and has enough ammo to reload, and if those are true, then we call the `DefaultReload` function.

```cpp
void CDesertEagle::Reload()
{
    // Don't reload if the player doesn't have any ammo
    if (m_pPlayer-&gt;ammo_357 &lt;= 0) return;

    int iResult;

    // The view model has two different animations depending on if there are any bullets in the clip
    if (m_iClip == 0) iResult = DefaultReload(DESERT_EAGLE_MAX_CLIP, DESERT_EAGLE_RELOAD, 1.5);
    else iResult = DefaultReload(DESERT_EAGLE_MAX_CLIP, DESERT_EAGLE_RELOAD_NOT_EMPTY, 1.5);

    if (iResult)
    {
        // If the reload happened, then reset the weapon's idle time
        m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + UTIL_SharedRandomFloat(m_pPlayer-&gt;random_seed, 10, 15);
    }
}
```

== WeaponIdle

`WeaponIdle` must be implemented to make sure idle animations are shown while the player isn't doing anything while holding the gun. It can also be used to randomly switch between different idle animations to keep things interesting. The Desert Eagle model has 5 idle animations, so we use the random number utility to switch between each of them:

```cpp
void CDesertEagle::WeaponIdle()
{
    // This is used in conjunction with the PlayEmptySound function.
    // This resets a flag so the "click" for an empty weapon can be replayed after a short delay
    ResetEmptySound();

    // Despite the name, this will SET the autoaim vector.
    // 10 degrees is what the magnum uses, so we'll use the same.
    m_pPlayer-&gt;GetAutoaimVector(AUTOAIM_10DEGREES);

    // Exit out of the method if the weapon time hasn't passed yet or if the clip is empty
    if (m_flTimeWeaponIdle &gt; UTIL_WeaponTimeBase() || m_iClip &lt;= 0) return;

    // Weapon idle is only called after the weapon hasn't been used (fired or reloaded)
    // for a while. In this case we want to play one of the idle animations for the weapon.
    // The desert eagle view model has 5 different idle animations, and we'll give each one
    // a 20% chance of playing, using the random number util function.
    int iAnim;
    float flRand = UTIL_SharedRandomFloat(m_pPlayer-&gt;random_seed, 0, 1);

    if (flRand &lt;= 0.2)
    {
        // The numbers here (76.0 / 30.0) are a way to represent the time taken by the
        // animation, so the next idle animation isn't played before the current one has
        // been completed. This animation is 76 frames long, and runs at 30 frames per second.
        iAnim = DESERT_EAGLE_IDLE1;
        m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + (76.0 / 30.0);
    }
    else if (flRand &lt;= 0.4)
    {
        iAnim = DESERT_EAGLE_IDLE2;
        m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + (61.0 / 24.0);
    }
    else if (flRand &lt;= 0.6)
    {
        iAnim = DESERT_EAGLE_IDLE3;
        m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + (50.0 / 30.0);
    }
    else if (flRand &lt;= 0.8)
    {
        iAnim = DESERT_EAGLE_IDLE4;
        m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + (76.0 / 30.0);
    }
    else
    {
        iAnim = DESERT_EAGLE_IDLE5;
        m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + (61.0 / 30.0);
    }

    // Play the idle animation
    SendWeaponAnim(iAnim, UseDecrement(), pev-&gt;body);
}
```

= Optional: Adding the laser spot

The laser spot is very specific to the Desert Eagle and it's unlikely that most of your weapons will use one. But for the sake of completion, let's add it in as well. For most of the implementation of the laser spot, we'll be looking at the RPG (as it already has a laser spot).

== Update the class declaration

First, open *weapons.h* and add the following changes to the `CDesertEagle` class. These changes are directly from the `CRpg` class and are required for the laser spot to work. Note that the `CLaserSpot` class is referenced here - so make sure your `CDesertEagle` is defined *after* the `CLaserSpot` class to avoid compile errors.

At the top of the public block:

```cpp
#ifndef CLIENT_DLL
    bool Save(CSave&amp; save);
    bool Restore(CRestore&amp; restore);
    static TYPEDESCRIPTION m_SaveData[];
#endif
```
And after [code]WeaponIdle()[/code]:

```cpp
    void UpdateSpot();
    bool ShouldWeaponIdle() { return true; };

    CLaserSpot* m_pSpot;
    int m_fSpotActive;
```

The `Save` and `Restore` methods need to be added now that we've added a custom field to the class - `m_fSpotActive`. This will be a flag to detect when the spot is active. To maintain this state between saves, we need to implement save/restore for the class. This is also why the field needs to be public - so the save/restore code can access it. We won't need to save the actual laser spot object (`m_pSpot`), since we can create this as-needed.

The `UpdateSpot` method is where the logic will go to .... update the spot. The other change - `ShouldWeaponIdle` is slightly more nuanced. By default, the `WeaponIdle` method is only called when the player isn't doing something else (such as shooting or reloading). By overriding `ShouldWeaponIdle`, we can force the `WeaponIdle` method to always be called. We do this so we can always call `UpdateSpot` so it can stay up-to-date.

== Implement save/restore

Go to *weapons.cpp* next and scroll to the very end to find the save/restore logic for each of the default weapons. If you take a look at some of them, you'll see a very standard pattern for this. Simply implement this pattern for the desert eagle class, and that's all you need to do. Here's the code to add:

```cpp
TYPEDESCRIPTION	CDesertEagle::m_SaveData[] =
{
    DEFINE_FIELD(CDesertEagle, m_fSpotActive, FIELD_INTEGER),
};
IMPLEMENT_SAVERESTORE(CDesertEagle, CBasePlayerWeapon);
```

== Make the changes to the weapon code

Finally, we need to implement the laser spot logic in the weapon code itself. Open *deserteagle.cpp*, and let's get started. Most of these changes are directly from the `CRpg` class, so take a look there for more information.

Taking a look at how the Desert Eagle in Opposing Force behaves, this is what we want for the laser spot:

- By default, the laser is off
- The laser is toggled by pressing the secondary attack button
- The laser plays a sound when toggled
- When the laser is turned on, the gun shoots slower, but is more accurate
- The laser disappears while the player is shooting or reloading, but reappears afterwards
- If the laser is enabled and the player switches to another weapon and then back, the laser turns on (and plays the sound) when the weapon is re-selected

=== Precache

First, add this line to the `Precache` method. This simply ensures that the laser spot's resources are precached properly.

```cpp
UTIL_PrecacheOther( "laser_spot" );
```

=== Holster

Next, we'll change the `Holster` code so that the laser is killed when the weapon is unequipped:

```cpp
#ifndef CLIENT_DLL
    // If the laser spot exists, kill it
    if (m_pSpot)
    {
        m_pSpot-&gt;Killed(NULL, GIB_NEVER);
        m_pSpot = NULL;
    }
#endif
```

=== WeaponIdle

First, add a call to `UpdateSpot()` to the very top of the `WeaponIdle` function, above [code]ResetEmptySound()[/code]. Next, if you take a close look at the idle animations for the Desert Eagle in Opposing Force, you'll notice that 3 of the idle animations only play when the laser is off, and the other 2 only play when the laser is on. We'll update this method so that this behaviour is the same as well. Here's the updated version of this function:

```cpp
void CDesertEagle::WeaponIdle()
{
    // Update the laser spot
    UpdateSpot();

    // This is used in conjunction with the PlayEmptySound function.
    // This resets a flag so the "click" for an empty weapon can be replayed after a short delay
    ResetEmptySound();

    // Despite the name, this will SET the autoaim vector.
    // 10 degrees is what the magnum uses, so we'll use the same.
    m_pPlayer-&gt;GetAutoaimVector(AUTOAIM_10DEGREES);

    // Exit out of the method if the weapon time hasn't passed yet or if the clip is empty
    if (m_flTimeWeaponIdle &gt; UTIL_WeaponTimeBase() || m_iClip &lt;= 0) return;

    // Weapon idle is only called after the weapon hasn't been used (fired or reloaded)
    // for a while. In this case we want to play one of the idle animations for the weapon.
    // The desert eagle view model has 5 different idle animations, 1-3 will play when the laser
    // is off, and 4-5 will play when the laser is on.
    int iAnim;
    float flRand = UTIL_SharedRandomFloat(m_pPlayer-&gt;random_seed, 0, 1);

    // When the laser is on, we'll add 1 to the random result so that laser off
    // animations play when the value is between 0 and 1, and laser on animations
    // play when the value is between 1 and 2.
    if (m_fSpotActive) flRand += 1.01; // Add an extra .01 to ensure it's always &gt; 1

    // Laser off animations
    if (flRand &lt;= 0.333)
    {
        // The numbers here (76.0 / 30.0) are a way to represent the time taken by the
        // animation, so the next idle animation isn't played before the current one has
        // been completed. This animation is 76 frames long, and runs at 30 frames per second.
        iAnim = DESERT_EAGLE_IDLE1;
        m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + (76.0 / 30.0);
    }
    else if (flRand &lt;= 0.667)
    {
        iAnim = DESERT_EAGLE_IDLE2;
        m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + (61.0 / 24.0);
    }
    else if (flRand &lt;= 1)
    {
        iAnim = DESERT_EAGLE_IDLE3;
        m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + (50.0 / 30.0);
    }
    // Laser on animations
    else if (flRand &lt;= 1.5)
    {
        iAnim = DESERT_EAGLE_IDLE4;
        m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + (76.0 / 30.0);
    }
    else
    {
        iAnim = DESERT_EAGLE_IDLE5;
        m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + (61.0 / 30.0);
    }

    // Play the idle animation
    SendWeaponAnim(iAnim, UseDecrement(), pev-&gt;body);
}
```

=== Reload

When the player reloads, we want to hide the laser. Add this inside the `if (iResult)` block in the `Reload` function:

```cpp
#ifndef CLIENT_DLL
        // If the player is reloading, hide the laser until the reload is complete
        if (m_pSpot &amp;&amp; m_fSpotActive)
        {
            m_pSpot-&gt;Suspend(1.6);
            m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 1.6;
        }
#endif
```

=== PrimaryAttack

There's three changes we want to make to the `PrimaryAttack` method: the accuracy should be better, shots should be slower, and the laser should be hidden for a short time during the fire animation. Let's take care of each of these.

Increasing the accuracy - this is done as part of the `FireBulletsPlayer` call. We'll simply change `VECTOR_CONE_10DEGREES` to `VECTOR_CONE_1DEGREES` when the spot is active. This is what we end up with:

```cpp
    Vector vecDir = m_pPlayer-&gt;FireBulletsPlayer(
        1,                     // Number of bullets to shoot
        vecSrc,                // The source of the bullets (i.e. the gun)
        vecAiming,             // The direction to fire in (i.e. where the player is pointing)
        m_fSpotActive ? VECTOR_CONE_1DEGREES : VECTOR_CONE_10DEGREES,  // The accuracy spread of the weapon
        8192,                  // The distance the bullet can go (8192 is the limit for the engine)
        BULLET_PLAYER_357,     // The type of bullet being fired
        0,                     // Number of tracer bullets to fire (none in this case)
        0,                     // Set to non-zero to override the amount of damage (usually, leave this as 0)
        m_pPlayer-&gt;pev,        // Attacker entity
        m_pPlayer-&gt;random_seed // The random seed
    );
```

Making shots slower - this is simply a matter of changing the value of `m_flNextPrimaryAttack`, towards the end of the method. We'll double the delay if the spot is active. Here's the result:

```cpp
    // The desert eagle can fire quite quickly with no laser spot, so use a 250ms delay
    // When the spot is active, the delay should be 500ms instead.
    m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + (m_fSpotActive ? 0.5 : 0.25);
```

Hiding the laser - similar to the reload function, we'll simply hide the laser for a short time. This goes directly after the previous code:

```cpp
#ifndef CLIENT_DLL
    // Hide the laser until the player can shoot again
    if (m_pSpot &amp;&amp; m_fSpotActive)
    {
        m_pSpot-&gt;Suspend(0.6);
        m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.6;
    }
#endif
```

Last but not least, we'll call the `UpdateSpot` method to make sure it stays up-to-date. This goes right at the end:

```cpp
    // Keep the laser updated
    UpdateSpot();
```

=== SecondaryAttack

Like the RPG, the secondary attack will toggle the laser spot on and off. However, the Desert Eagle also has sounds that play when the laser is toggled, so we'll add code for that as well. This is what `SecondaryAttack` should look like:

```cpp
void CDesertEagle::SecondaryAttack()
{
    // Toggle the laser
    m_fSpotActive = !m_fSpotActive;

#ifndef CLIENT_DLL
    // If the laser is being turned off, kill the laser
    if (!m_fSpotActive &amp;&amp; m_pSpot)
    {
        m_pSpot-&gt;Killed(NULL, GIB_NORMAL);
        m_pSpot = NULL;
    }
#endif

    if (m_fSpotActive)
    {
        // If the spot is being turned on, play the ON sound and delay for a short time
        EMIT_SOUND(ENT(m_pPlayer-&gt;pev), CHAN_ITEM, "weapons/desert_eagle_sight.wav", 1, ATTN_NORM);
        m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.25;
    }
    else
    {
        // If the spot is being turned off, play the OFF sound and delay for a slightly longer time
        EMIT_SOUND(ENT(m_pPlayer-&gt;pev), CHAN_ITEM, "weapons/desert_eagle_sight2.wav", 1, ATTN_NORM);
        m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.5;
    }
}
```

=== UpdateSpot

Finally, the new method: `UpdateSpot`. This is just a copy-paste from the `CRpg` class. Here's the code:

```cpp
void CDesertEagle::UpdateSpot(void)
{
#ifndef CLIENT_DLL
    // If the spot is active
    if (m_fSpotActive)
    {
        // Make sure the spot entity has been created
        if (!m_pSpot)
        {
            m_pSpot = CLaserSpot::CreateSpot();
        }

        // Perform a TraceLine to find the point that the laser shines on
        UTIL_MakeVectors(m_pPlayer-&gt;pev-&gt;v_angle);
        Vector vecSrc = m_pPlayer-&gt;GetGunPosition();
        Vector vecAiming = gpGlobals-&gt;v_forward;

        TraceResult tr;
        UTIL_TraceLine(vecSrc, vecSrc + vecAiming * 8192, dont_ignore_monsters, ENT(m_pPlayer-&gt;pev), &amp;tr);

        // Put the laser spot at the end of the trace
        UTIL_SetOrigin(m_pSpot-&gt;pev, tr.vecEndPos);
    }
#endif
}
```

=== A small tweak

The weapon is basically complete at this point: but there's one missing feature - when the laser is active, and the weapon is switched to from another weapon, you want to play the "laser on" sound when the laser appears. Now, you could probably do something in the `Deploy` function to handle this, but there's a different way. Instead of playing the "laser on" sound inside `SecondaryAttack`, we could play it when the laser is created in the `UpdateSpot` method.

Go into the `SecondaryAttack` method, and cut the `EMIT_SOUND` line for when the laser is being turned on. Keep it in the clipboard, because we'll be pasting it into `UpdateSpot` next.

In [code]SecondaryAttack[/code]:

```cpp
    if (m_fSpotActive)
    {
        // If the spot is being turned on, play the ON sound and delay for a short time
        // Note: The "on" sound is handled by the UpdateSpot function so it works on Deploy as well!
        m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.25;
    }
    else
    // ... more code ...
```

Now go over to `UpdateSpot` and add the `EMIT_SOUND` line in:

```cpp
        // Make sure the spot entity has been created
        if (!m_pSpot)
        {
            m_pSpot = CLaserSpot::CreateSpot();

            // Play the "laser on" sound here, so it plays after a Deploy as well as a SecondaryAttack
            EMIT_SOUND(ENT(m_pPlayer-&gt;pev), CHAN_ITEM, "weapons/desert_eagle_sight.wav", 1, ATTN_NORM);
        }
        // ... more code ...
```

=== Another small tweak

If you compare your new Desert Eagle to Opposing Force... it looks pretty good! But if you look closely at the laser spot, you might notice that in OP4, it's actually quite a bit smaller. In fact, if you compare the scales of the laser spots for the RPG and Desert Eagle, it's actually half the size of RPG's.

[img:Weapons Programming - Desert Eagle Sprite Size Comparison]

Fortunately, this only takes a very small tweak to your code to get the same effect. In `UpdateSpot`, when creating the laser spot, simply set it's scale to `0.5`. That's it!

```cpp
        // Make sure the spot entity has been created
        if (!m_pSpot)
        {
            m_pSpot = CLaserSpot::CreateSpot();
            m_pSpot-&gt;pev-&gt;scale = 0.5;

            // Play the "laser on" sound here, so it plays after a Deploy as well as a SecondaryAttack
            EMIT_SOUND(ENT(m_pPlayer-&gt;pev), CHAN_ITEM, "weapons/desert_eagle_sight.wav", 1, ATTN_NORM);
        }
```

Now the size of the laser spot will match Opposing Force. You might notice that OP4 uses a different sprite for the laser spot - if you want to use it, simply copy the *gearbox/sprites/laserdot.spr* file into your mod. If you want you mod to use a different sprite for the Desert Eagle, you'll need to make further changes to the `CLaserSpot` class in order to make the sprite it uses more configurable.

= Make the changes to your FGD

This is the last step of adding any new entity to your mod - update the FGD so you can place it in your editor! For weapons, doing this is very simple, since they rarely have any special keyvalues. Just add this to your FGD file:

```plaintext
@PointClass base(Weapon, Targetx) studio("models/w_desert_eagle.mdl") = weapon_eagle : "Desert Eagle" []
```

And don't forget about the change to the [[func_breakable]] definition as well! It's in the `Breakable` base class, just add your number and description for the weapon to the end:

```plaintext
@BaseClass base(Targetname,Global) = Breakable
[
    ...
    spawnobject(choices) : "Spawn On Break" : 0 =
    [
        0: "Nothing"
        ...
        21: "Hornet Gun"
        22: "Desert Eagle"
    ]
    ... 
]
```

= Enjoy!

You're finally finished! Hopefully you've been compiling your mod and checking the results as you go, but just in case you haven't, do that now! [https://github.com/LogicAndTrick/halflife-updated/commit/tutorial-standard-weapons|Click here to see the full source code for this tutorial.]</value>
  </data>
  <data name="TwhlFormattingWikiPageHtml" xml:space="preserve">
    <value>TWHL uses a custom text syntax that we call &lt;em&gt;WikiCode&lt;/em&gt;. It is a combination of Markdown and BBCode, with a few extra things to spice it up. If you&amp;#039;re familiar with either of these markup systems, you shouldn&amp;#039;t have too much trouble.
&lt;h2 id="Basic_text_formatting"&gt;Basic text formatting&lt;/h2&gt;
There are two ways to do basic text formatting - the &lt;em&gt;Markdown&lt;/em&gt; way and the &lt;em&gt;BBCode&lt;/em&gt; way. Markdown style is usually faster to type, but BBCode is generally more flexible.
&lt;table class="table table-bordered"&gt;&lt;tr&gt;&lt;th&gt;Format&lt;/th&gt;&lt;th&gt;Markdown style&lt;/th&gt;&lt;th&gt;BBCode style&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Bold text&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;*Bold text*&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;[b]Bold text[/b]&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;em&gt;Italic text&lt;/em&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;/Italic text/&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;[i]Italic text[/i]&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span class="underline"&gt;Underlined text&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;_Underlined text_&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;[u]Underlined text[/u]&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span class="strikethrough"&gt;Strikethrough text&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;~Strikethrough text~&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;[s]Strikethrough text[/s]&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Inline code&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;`Inline code`&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;[ code ]Inline code[ /code ]&lt;/code&gt; (remove extra spaces)&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2 id="Smilies/emoticons/emoji"&gt;Smilies/emoticons/emoji&lt;/h2&gt;
Before the land of smartphones and dedicated Unicode glyphs, emoji were known as &amp;#039;smilies&amp;#039;, and were not text, but images! Bizarre, I know. TWHL has complete Unicode support, so go nuts with your smartphone keyboards and you won&amp;#039;t have any issues with favourites such as &lt;code&gt;U+1F4A9: PILE OF POO&lt;/code&gt;: 💩. For us plebs using desktop browsers, though, you can also use the traditional smilies from the good ol&amp;#039; days.&lt;br&gt;&lt;br&gt;Here is TWHL&amp;#039;s library of smilies and their corresponding text representations. Simply type the text and it will be replaced with a smiley image in the post.&lt;br&gt;&lt;br&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/aggrieved.png" alt=":aggrieved:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/aghast.png" alt=":aghast:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/angry.png" alt=":x" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/badass.png" alt=":badass:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/confused.png" alt=":confused:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/cry.png" alt=":cry:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/cyclops.png" alt=":cyclops:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/lol.png" alt=":lol:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/frown.png" alt=":|" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/furious.png" alt=":furious:" /&gt;&lt;br&gt;&lt;img class="smiley" src="https://twhl.info/images/smilies/glad.png" alt=":glad:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/heart.png" alt=":heart:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/grin.png" alt=":D" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/nervous.png" alt=":nervous:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/nuke.png" alt=":nuke:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/nuts.png" alt=":nuts:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/quizzical.png" alt=":quizzical:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/rollseyes.png" alt=":roll:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/sad.png" alt=":(" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/smile.png" alt=":)" /&gt;&lt;br&gt;&lt;img class="smiley" src="https://twhl.info/images/smilies/surprised.png" alt=":o" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/thebox.png" alt=":thebox:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/thefinger.png" alt=":thefinger:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/tired.png" alt=":tired:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/tongue.png" alt=":P" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/toocool.png" alt=":cool:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/unsure.png" alt=":\" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/biggrin.png" alt=":biggrin:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/wink.png" alt=";)" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/zonked.png" alt=":zonked:" /&gt;&lt;br&gt;&lt;img class="smiley" src="https://twhl.info/images/smilies/sarcastic.png" alt=":sarcastic:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/combine.png" alt=":combine:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/gak.png" alt=":gak:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/animehappy.png" alt=":^_^:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/pwnt.png" alt=":pwned:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/target.png" alt=":target:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/ninja.png" alt=":ninja:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/hammer.png" alt=":hammer:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/pirate.png" alt=":pirate:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/walter.png" alt=":walter:" /&gt;&lt;br&gt;&lt;img class="smiley" src="https://twhl.info/images/smilies/plastered.png" alt=":plastered:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/bigmouth.png" alt=":zomg:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/brokenheart.png" alt=":heartbreak:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/ciggiesmilie.png" alt=":ciggie:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/combines.png" alt=":combines:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/crowbar.png" alt=":crowbar:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/death.png" alt=":death:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/freeman.png" alt=":freeman:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/hecu.png" alt=":hecu:" /&gt; &lt;img class="smiley" src="https://twhl.info/images/smilies/nya.png" alt=":nya:" /&gt;
&lt;pre class="lang-plaintext"&gt;&lt;code&gt;:aggrieved:  :aghast:    :x            :badass:   :confused:  :cry:      :cyclops:    :lol:      :|        :furious:
:glad:       :heart:     :D            :nervous:  :nuke:      :nuts:     :quizzical:  :roll:     :(        :)
:o           :thebox:    :thefinger:   :tired:    :P          :cool:     :\           :biggrin:  ;)        :zonked:
:sarcastic:  :combine:   :gak:         :^_^:      :pwned:     :target:   :ninja:      :hammer:   :pirate:  :walter:
:plastered:  :zomg:      :heartbreak:  :ciggie:   :combines:  :crowbar:  :death:      :freeman:  :hecu:    :nya:&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="Linking"&gt;Linking&lt;/h2&gt;
On the web, linking is one of the more useful things you can do. So, of course there are multiple ways you can link to things using WikiCode. To use auto-linking, make sure the URL starts with &lt;code&gt;http://&lt;/code&gt;. Be careful, because some browsers don&amp;#039;t include this by default.
&lt;table class="table table-bordered"&gt;&lt;tr&gt;&lt;th&gt;Link method&lt;/th&gt;&lt;th&gt;Markup&lt;/th&gt;&lt;th&gt;Result&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Standard link&lt;/td&gt;&lt;td&gt;&lt;code&gt;[url]http://example.com[/url]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;a href="http://example.com"&gt;http://example.com&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Custom link&lt;/td&gt;&lt;td&gt;&lt;code&gt;[url=http://example.com]Example link[/url]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;a href="http://example.com"&gt;Example link&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Standard email link&lt;/td&gt;&lt;td&gt;&lt;code&gt;[email]test@example.com[/email]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;a href="mailto:test@example.com"&gt;test@example.com&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Custom email link&lt;/td&gt;&lt;td&gt;&lt;code&gt;[email=test@example.com]Example email link[/email]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;a href="mailto:test@example.com"&gt;Example email link&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Quick link&lt;/td&gt;&lt;td&gt;&lt;code&gt;[http://example.com]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;a href="http://example.com"&gt;http://example.com&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Custom quick link&lt;/td&gt;&lt;td&gt;&lt;code&gt;[http://example.com|Example link]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;a href="http://example.com"&gt;Example link&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Link to TWHL wiki page&lt;/td&gt;&lt;td&gt;&lt;code&gt;[[Home]]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;a href="https://twhl.info/wiki/page/Home"&gt;Home&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Custom link to TWHL wiki page&lt;/td&gt;&lt;td&gt;&lt;code&gt;[[Home|Example link]]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;a href="https://twhl.info/wiki/page/Home"&gt;Example link&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Auto-link&lt;/td&gt;&lt;td&gt;&lt;code&gt;http://example.com&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;a href="http://example.com"&gt;http://example.com&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2 id="Images"&gt;Images&lt;/h2&gt;
Embedding images is another useful thing to do, especially on a wiki. Because it&amp;#039;s important, there&amp;#039;s a few different ways that images can be added to a post. The output isn&amp;#039;t shown in this case because images can take a fair amount of space, but you can experiment by using the preview button when typing a post.
&lt;table class="table table-bordered"&gt;&lt;tr&gt;&lt;th&gt;Format&lt;/th&gt;&lt;th&gt;Markup&lt;/th&gt;&lt;th&gt;Notes&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Normal image&lt;/td&gt;&lt;td&gt;&lt;code&gt;[img]http://example.com/example.jpg[/img]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Embed a normal image (breaks text top and bottom)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Link image&lt;/td&gt;&lt;td&gt;&lt;code&gt;[url=http://example.com][img]http://example.com/example.jpg[/img][/url]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Clickable to open a URL&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Inline image&lt;/td&gt;&lt;td&gt;&lt;code&gt;[simg]http://example.com/example.jpg[/simg]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Embed a small image (inline with text)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Advanced image&lt;/td&gt;&lt;td&gt;&lt;code&gt;[img:http://example.com/example.jpg]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;See details on the advanced image format below&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Link to TWHL wiki image&lt;/td&gt;&lt;td&gt;&lt;code&gt;[img:example.jpg]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;example.jpg&lt;/code&gt; is the title of the wiki upload&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3 id="Pasting_images"&gt;Pasting images&lt;/h3&gt;
If you have an image on your clipboard (usually from taking a screenshot with the &lt;code&gt;PrtSc&lt;/code&gt; key, snipping tool in Windows 7, or &lt;code&gt;Win+Shift+S&lt;/code&gt; in Windows 10), you can press &lt;code&gt;Ctrl+V&lt;/code&gt; into a TWHL textbox to upload the image and insert the required WikiCode to embed the image. This will not work if you have an image &lt;strong&gt;file&lt;/strong&gt; on your clipboard - it must be an actual image.
&lt;h3 id="Using_the_advanced_image_tag"&gt;Using the advanced image tag&lt;/h3&gt;
&lt;div class="embedded image small right" title="This image has a url, the size is &amp;#039;small&amp;#039;, and the position is &amp;#039;right&amp;#039;."&gt;&lt;a href="http://example.com"&gt;&lt;span class="caption-panel"&gt;&lt;img class="caption-body" src="https://via.placeholder.com/400" alt="This image has a url, the size is &amp;#039;small&amp;#039;, and the position is &amp;#039;right&amp;#039;." /&gt;&lt;span class="caption"&gt;This image has a url, the size is &amp;#039;small&amp;#039;, and the position is &amp;#039;right&amp;#039;.&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;Sometimes you wish you had more flexibility when embedding images. Well, now you do! The advanced image tag gives you a few options when adding images to your post.&lt;br&gt;&lt;br&gt;The syntax can look something like this: &lt;code&gt;[img:example.jpg|url:http://example.com|size_modifier|position_modifier|caption_text]&lt;/code&gt;&lt;br&gt;&lt;br&gt;Where every field aside from &lt;code&gt;img:&lt;/code&gt; is optional. An explanation of each option:
&lt;ul&gt;&lt;li&gt;&lt;code&gt;url:&lt;/code&gt; - should explain itself. Use this to make the image link to a website when you click on it.&lt;/li&gt;&lt;li&gt;&lt;code&gt;size_modifier&lt;/code&gt; - by default, the image tries to fill the width of the page. You can use the size modifier to change it to a fixed size. Valid values are: &lt;code&gt;thumb&lt;/code&gt;, &lt;code&gt;small&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt;, and &lt;code&gt;large&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;code&gt;position_modifier&lt;/code&gt; - by default, the image is centered and text will be wrapped above and below the image. You can use the position modifier to change the position and make the text flow around the image. Valid values are &lt;code&gt;inline&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, and &lt;code&gt;center&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;code&gt;caption_text&lt;/code&gt; - if you type anything aside from the values above, it will be treated as a caption to the image. You can only use plain text in the caption.&lt;/li&gt;&lt;/ul&gt;
As an aside, video and audio files may sometimes be uploaded to the wiki. You can embed these files on modern browsers using the advanced image tag. Just replace &lt;code&gt;[img:]&lt;/code&gt; with &lt;code&gt;[video:]&lt;/code&gt; or &lt;code&gt;[audio:]&lt;/code&gt; to use them. You can embed external video and audio as well, but note that some formats are not supported on some browsers, so it might not work for everyone. The safest formats to use are mp3 for audio, and mp4 for video.
&lt;h2 id="Youtube"&gt;Youtube&lt;/h2&gt;
&lt;div class='embedded video left medium'&gt;&lt;div class='caption-panel'&gt;&lt;div class='video-container caption-body'&gt;&lt;div class='video-content'&gt;&lt;div class='uninitialised' data-youtube-id='oGlhgVz5r6E' style='background-image: url("https://i.ytimg.com/vi/oGlhgVz5r6E/hqdefault.jpg");'&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;span class='caption'&gt;This is the caption text&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;Embedding Youtube videos was an often-requested feature in TWHL, and now everybody can do it. To embed the video, you first need to find the video ID. You can find this in the URL of any Youtube video - it&amp;#039;s a string of 10 or so letters and numbers. It&amp;#039;s underlined in the example below.&lt;br&gt;&lt;br&gt;youtube.com/watch?v=&lt;span class="underline"&gt;oGlhgVz5r6E&lt;/span&gt;&lt;br&gt;&lt;br&gt;Once you have the ID, you can use the &lt;code&gt;[youtube]&lt;/code&gt; tag to add it to your post:
&lt;pre class="lang-plaintext"&gt;&lt;code&gt;[youtube]oGlhgVz5r6E[/youtube]&lt;/code&gt;&lt;/pre&gt;
You may also use the advanced image syntax. The options are similar to the &lt;code&gt;[img:]&lt;/code&gt; tag, but you can&amp;#039;t use the &lt;code&gt;url:&lt;/code&gt;, &lt;code&gt;inline&lt;/code&gt;, or &lt;code&gt;thumb&lt;/code&gt; options in the tag. An example:
&lt;pre class="lang-plaintext"&gt;&lt;code&gt;[youtube:oGlhgVz5r6E|left|medium|This is the caption text]&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="Headings"&gt;Headings&lt;/h2&gt;
Headings follow the HTML trend by having six levels. To use a heading, start a new line with &lt;code&gt;=&lt;/code&gt; symbols. The more symbols you use, the smaller the heading will be.
&lt;div class="embed-panel card card-default"&gt;&lt;div class="card-body"&gt;&lt;h1 id="Heading_1_(Largest)"&gt;Heading 1 (Largest)&lt;/h1&gt;
&lt;h2 id="Heading_2"&gt;Heading 2&lt;/h2&gt;
&lt;h3 id="Heading_3"&gt;Heading 3&lt;/h3&gt;
&lt;h4 id="Heading_4"&gt;Heading 4&lt;/h4&gt;
&lt;h5 id="Heading_5"&gt;Heading 5&lt;/h5&gt;
&lt;h6 id="Heading_6_(Smallest)"&gt;Heading 6 (Smallest)&lt;/h6&gt;&lt;/div&gt;&lt;/div&gt;
These headings are generated by this code:
&lt;pre class="lang-plaintext"&gt;&lt;code&gt;= Heading 1 (Largest)
== Heading 2
=== Heading 3
==== Heading 4
===== Heading 5
====== Heading 6 (Smallest)&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="Lists"&gt;Lists&lt;/h2&gt;
You can make lists by using &lt;code&gt;*&lt;/code&gt; for bullet points or &lt;code&gt;#&lt;/code&gt; for ordered lists. You can create sub-lists by adding extra symbols. You can mix list types on each level.
&lt;div class="embed-panel card card-default"&gt;&lt;div class="card-body"&gt;&lt;ul&gt;&lt;li&gt;List item 1&lt;/li&gt;&lt;li&gt;List item 2&lt;ul&gt;&lt;li&gt;List item 2.1&lt;/li&gt;&lt;li&gt;List item 2.2&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;ol&gt;&lt;li&gt;Step 1&lt;/li&gt;&lt;li&gt;Step 2&lt;ul&gt;&lt;li&gt;Be sure to do step 1 before step 2!&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;
The markup for the above looks like:
&lt;pre class="lang-plaintext"&gt;&lt;code&gt;* List item 1
* List item 2
** List item 2.1
** List item 2.2

# Step 1
# Step 2
#* Be sure to do step 1 before step 2!&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="Quotes"&gt;Quotes&lt;/h2&gt;
Often you want to quote another user when you are replying to them. Again, there are two different ways to quote users.
&lt;blockquote&gt;Markdown style quotes&lt;br&gt;This is the second line of the quote&lt;/blockquote&gt;
The code looks like this:
&lt;pre class="lang-plaintext"&gt;&lt;code&gt;&amp;gt; Markdown style quotes
&amp;gt; This is the second line of the quote&lt;/code&gt;&lt;/pre&gt;
It&amp;#039;s important to note that additional lines in the quote must also start with the &amp;#039;&amp;gt;&amp;#039; character.&lt;br&gt;&lt;br&gt;Quotes can be nested quite easily:
&lt;blockquote&gt;&lt;blockquote&gt;This is the parent quote&lt;/blockquote&gt;
This is the child quote&lt;/blockquote&gt;
And the markup:
&lt;pre class="lang-plaintext"&gt;&lt;code&gt;&amp;gt;&amp;gt; This is the parent quote
&amp;gt; This is the child quote&lt;/code&gt;&lt;/pre&gt;
The second way to quote users is to use the &lt;code&gt;[quote]&lt;/code&gt; BBCode tag. These quotes can be nested as well. The new lines are not required, they are simply there to make it easier to read the example.
&lt;pre class="lang-plaintext"&gt;&lt;code&gt;[quote]
    [quote]This is the parent quote[/quote]
    This is the child quote
[/quote]&lt;/code&gt;&lt;/pre&gt;
BBCode quotes have the advantage of adding the name of the person you are quoting:&lt;blockquote&gt;&lt;strong class="quote-name"&gt;GLaDOS said:&lt;/strong&gt;Oh, hi. So, how are you holding up? Because I&amp;#039;m a potato!&lt;/blockquote&gt;Which can be done like this:
&lt;pre class="lang-plaintext"&gt;&lt;code&gt;[quote=GLaDOS]Oh, hi. So, how are you holding up? Because I&amp;#039;m a potato![/quote]&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="Panels"&gt;Panels&lt;/h2&gt;
Panels are a simple way to separate some content into its own block. Panels can&amp;#039;t be nested within each other, but they can contain any other markup you want. To create a panel, simply mark the start of the content with &lt;code&gt;~~~&lt;/code&gt;. The end of the panel will be marked by the next line that starts with &lt;code&gt;~~~&lt;/code&gt;.&lt;br&gt;&lt;br&gt;If the first line of your panel content starts with &lt;code&gt;:&lt;/code&gt;, it will be used as the panel title.
&lt;div class="embed-panel card card-default"&gt;&lt;div class="card-header"&gt;Panel Title&lt;/div&gt;&lt;div class="card-body"&gt;This is a panel.&lt;br&gt;The markup for a panel looks like this:
&lt;pre class="lang-plaintext"&gt;&lt;code&gt;~~~
:Panel Title
This is a panel.
~~~&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
Panels can have different colours as well. The options are: &lt;code&gt;message&lt;/code&gt; (green), &lt;code&gt;info&lt;/code&gt; (blue), &lt;code&gt;warning&lt;/code&gt; (yellow), and &lt;code&gt;error&lt;/code&gt; (red). To use these colours, put the option after the &lt;code&gt;~~~&lt;/code&gt; at the beginning of the panel.
&lt;div class="embed-panel card card-info"&gt;&lt;div class="card-header"&gt;Information Panel&lt;/div&gt;&lt;div class="card-body"&gt;This is an &amp;#039;informative&amp;#039; panel, it is coloured blue.&lt;br&gt;The markup for an info panel looks like this:
&lt;pre class="lang-plaintext"&gt;&lt;code&gt;~~~info
:Information Panel
This is an &amp;#039;informative&amp;#039; panel, it is coloured blue.
~~~&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id="Horizontal_line"&gt;Horizontal line&lt;/h2&gt;
This is a pretty simple one. Simply have a line of text that has nothing but &lt;code&gt;---&lt;/code&gt;. It&amp;#039;ll draw a line that&amp;#039;s useful for separating sections of text in a post. It looks like this:
&lt;hr /&gt;

&lt;h2 id="Wiki_category"&gt;Wiki category&lt;/h2&gt;
This is the only tag that&amp;#039;s specific to the wiki. You can use it in other places, but it will just be ignored. Add this tag to categorise wiki pages. Make sure you spell the category correctly, or the page will link to the wrong category. Here&amp;#039;s some examples:
&lt;pre class="lang-plaintext"&gt;&lt;code&gt;[cat:Put Category Name Here]
[cat:Source Tutorials]
[cat:Requires Further Detail]&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="Embedded_vault"&gt;Embedded vault&lt;/h2&gt;
If you&amp;#039;re posting on a WIP thread or want to show off your new map or mod, you can embed the map vault item into the post. This is also good for posting example maps on a wiki page. To embed a vault item you need to know the ID of the item. You can find this at the end of the URL on the vault page. For example: twhl.info/vault/view/&lt;span class="underline"&gt;1234&lt;/span&gt;&lt;br&gt;&lt;br&gt;Then you put that ID in a vault tag like this:
&lt;pre class="lang-plaintext"&gt;&lt;code&gt;[vault:1234]&lt;/code&gt;&lt;/pre&gt;
The vault item will be added to the page as a screenshot slideshow, along with a link to the item. If you would like to see what it looks like, you can use the post preview function to experiment with this feature.
&lt;h2 id="Tables"&gt;Tables&lt;/h2&gt;
If you want to get really fancy with your post, you can insert a table. The contents of a table can only be inline - for example, inline images, text formatting, links, and so on. You can&amp;#039;t put stuff like Youtube videos or quotes in a table.&lt;br&gt;&lt;br&gt;To create a table, you use one line of text per table row. For a header row, start the line with &lt;code&gt;|=&lt;/code&gt;. For a normal row, start the line with &lt;code&gt;|-&lt;/code&gt;. After that, simply enter the contents of each column, separated by a &lt;code&gt;|&lt;/code&gt; character. For example:
&lt;table class="table table-bordered"&gt;&lt;tr&gt;&lt;th&gt;Header 1&lt;/th&gt;&lt;th&gt;Header 2&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
This table can be created by typing this:
&lt;pre class="lang-plaintext"&gt;&lt;code&gt;|= Header 1 | Header 2
|- Value 1  | Value 2&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="Advanced_text_formatting"&gt;Advanced text formatting&lt;/h2&gt;
These advanced text formatting techniques are not possible using the Markdown style.
&lt;table class="table table-bordered"&gt;&lt;tr&gt;&lt;th&gt;Format&lt;/th&gt;&lt;th&gt;BBCode&lt;/th&gt;&lt;th&gt;Notes&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span style="color: red;"&gt;Colour text&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;[font=red]Colour text[/font]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Can use any colour name from the &lt;a href="https://developer.mozilla.org/en/docs/Web/CSS/color_value#Color_keywords"&gt;CSS colour list&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span style="color: #FEA320;"&gt;Colour text 2&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;[font=#FEA320]Colour text 2[/font]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Can use any RGB hex value&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span style="font-size: 20px;"&gt;Large text&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;[font size=20]Large text[/font]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Can use sizes between 6px and 40px&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span style="font-size: 8px;"&gt;Small text&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;[font size=8]Small text[/font]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;The standard text size is 14px&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span style="color: red;font-size: 20px;"&gt;Large red text&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;[font color=red size=20]Large text[/font]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Both size and colour can be combined. Remember to use the American spelling for &amp;quot;color&amp;quot;.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span class="spoiler" title="Spoiler"&gt;Spoiler tag&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;[spoiler]Spoiler tag[/spoiler]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Don&amp;#039;t spoil stuff for others!&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span class="spoiler" title="Half-Life"&gt;There&amp;#039;s a resonance cascade&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;[spoiler=Half-Life]There&amp;#039;s a resonance cascade[/spoiler]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;It&amp;#039;s polite to specify what game/movie/etc. the spoiler is for&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2 id="Code_blocks"&gt;Code blocks&lt;/h2&gt;
You may be wondering how those text blocks appeared above without the BBCode inside them being formatted. This is one of the features of a code block - everything inside them is treated as plain text, and not formatted. This is good for posting snippets of code. To post a code block using the Markdown style, surround the code with three backtick characters (that&amp;#039;s the ` character). This will align the code block to the left to avoid unnecessary whitespace.
&lt;pre class="lang-plaintext"&gt;&lt;code&gt;```
Surround your text with three backticks like this to format it as code.
```
&lt;/code&gt;&lt;/pre&gt;
If you don&amp;#039;t like backticks for some reason, the BBCode tag you want is &lt;code&gt;[pre]&lt;/code&gt;. It stands for &amp;quot;preformatted&amp;quot;. Unlike backtick blocks, preformatted blocks will retain all whitespace, including at the start of lines.
&lt;pre class="lang-plaintext"&gt;&lt;code&gt;[pre]All the text inside this tag will be a code block. All whitespace inside this block will be retained.[/pre]&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="Syntax_highlighting"&gt;Syntax highlighting&lt;/h3&gt;

&lt;pre class="lang-js"&gt;&lt;code&gt;function javascript() { console.log(&amp;#039;hello!&amp;#039;); }&lt;/code&gt;&lt;/pre&gt;
TWHL&amp;#039;s code highlighting feature will try to detect which programming language your code block contains, but for more control over which language to use, you can specify the language with the following syntax (using &lt;code&gt;js&lt;/code&gt; as the example language):
&lt;pre class="lang-plaintext"&gt;&lt;code&gt;[pre=js]function javascript() { console.log(&amp;#039;hello!&amp;#039;); }[/pre]&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="lang-plaintext"&gt;&lt;code&gt;```js
function javascript() { console.log(&amp;#039;hello!&amp;#039;); }
```
&lt;/code&gt;&lt;/pre&gt;
The following languages are supported:
&lt;ul&gt;&lt;li&gt;PHP - &lt;code&gt;php&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Windows batch - &lt;code&gt;dos&lt;/code&gt;, &lt;code&gt;bat&lt;/code&gt;, &lt;code&gt;cmd&lt;/code&gt;&lt;/li&gt;&lt;li&gt;CSS - &lt;code&gt;css&lt;/code&gt;&lt;/li&gt;&lt;li&gt;C++ - &lt;code&gt;cpp&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;c++&lt;/code&gt;&lt;/li&gt;&lt;li&gt;C# - &lt;code&gt;cs&lt;/code&gt;&lt;/li&gt;&lt;li&gt;INI config - &lt;code&gt;ini&lt;/code&gt;&lt;/li&gt;&lt;li&gt;JSON - &lt;code&gt;json&lt;/code&gt;&lt;/li&gt;&lt;li&gt;HTML/XML - &lt;code&gt;xml&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt;&lt;/li&gt;&lt;li&gt;AngelScript - &lt;code&gt;angelscript&lt;/code&gt;&lt;/li&gt;&lt;li&gt;JavaScript - &lt;code&gt;javascript&lt;/code&gt;, &lt;code&gt;js&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Force no highlighting - &lt;code&gt;plaintext&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;h2 id="Columns"&gt;Columns&lt;/h2&gt;
For complex stuff you might want to present some content in columns, side by side. You can do that by using the columns directive. It looks like this:
&lt;pre class="lang-plaintext"&gt;&lt;code&gt;%%columns=6:3:3
Column 1
%%
Column 2
%%
Column 3
%%&lt;/code&gt;&lt;/pre&gt;
Which looks like this:
&lt;div class="embed-panel card card-default"&gt;&lt;div class="card-body"&gt;&lt;div class="row"&gt;&lt;div class="col-md-6"&gt;Column 1&lt;/div&gt;&lt;div class="col-md-3"&gt;Column 2&lt;/div&gt;&lt;div class="col-md-3"&gt;Column 3&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
Some things to note:
&lt;ul&gt;&lt;li&gt;The column widths are specified in the first line, in this case, &lt;code&gt;6:3:3&lt;/code&gt;. These numbers are in respect to the page being 12 units wide. The column widths &lt;strong&gt;must&lt;/strong&gt; add up to a total of 12 or the columns will not work.&lt;/li&gt;&lt;li&gt;You need to specify the same number of content sections as columns in the first line, or the columns will not work.&lt;/li&gt;&lt;li&gt;On small resolution screens (phones, tablets), the columns will show underneath each other instead of side by side.&lt;/li&gt;&lt;/ul&gt;

&lt;hr /&gt;
Phew! That&amp;#039;s everything! I know there&amp;#039;s a lot of stuff here, but don&amp;#039;t worry too much about it. If you need to do a particular thing, just come back to this page later so you can refresh your memory.</value>
  </data>
  <data name="TwhlFormattingWikiPageInput" xml:space="preserve">
    <value>[cat:Meta]

TWHL uses a custom text syntax that we call /WikiCode/. It is a combination of Markdown and BBCode, with a few extra things to spice it up. If you're familiar with either of these markup systems, you shouldn't have too much trouble.

== Basic text formatting

There are two ways to do basic text formatting - the /Markdown/ way and the /BBCode/ way. Markdown style is usually faster to type, but BBCode is generally more flexible.

|= Format | Markdown style | BBCode style
|- *Bold text* | `*Bold text*` | [code][b]Bold text[/b][/code]
|- /Italic text/ | `/Italic text/` | [code][i]Italic text[/i][/code]
|- _Underlined text_ | `_Underlined text_` | [code][u]Underlined text[/u][/code]
|- ~Strikethrough text~ | `~Strikethrough text~` | [code][s]Strikethrough text[/s][/code]
|- `Inline code` | [code]`Inline code`[/code] | [code][ code ]Inline code[ /code ][/code] (remove extra spaces)

== Smilies/emoticons/emoji

Before the land of smartphones and dedicated Unicode glyphs, emoji were known as 'smilies', and were not text, but images! Bizarre, I know. TWHL has complete Unicode support, so go nuts with your smartphone keyboards and you won't have any issues with favourites such as `U+1F4A9: PILE OF POO`: 💩. For us plebs using desktop browsers, though, you can also use the traditional smilies from the good ol' days.

Here is TWHL's library of smilies and their corresponding text representations. Simply type the text and it will be replaced with a smiley image in the post.

 :aggrieved: :aghast: :x :badass: :confused: :cry: :cyclops: :lol: :| :furious:
:glad: :heart: :D :nervous: :nuke: :nuts: :quizzical: :roll: :( :)
:o :thebox: :thefinger: :tired: :P :cool: :\ :biggrin: ;) :zonked:
:sarcastic: :combine: :gak: :^_^: :pwned: :target: :ninja: :hammer: :pirate: :walter:
:plastered: :zomg: :heartbreak: :ciggie: :combines: :crowbar: :death: :freeman: :hecu: :nya: 

```plaintext
:aggrieved:  :aghast:    :x            :badass:   :confused:  :cry:      :cyclops:    :lol:      :|        :furious:
:glad:       :heart:     :D            :nervous:  :nuke:      :nuts:     :quizzical:  :roll:     :(        :)
:o           :thebox:    :thefinger:   :tired:    :P          :cool:     :\           :biggrin:  ;)        :zonked:
:sarcastic:  :combine:   :gak:         :^_^:      :pwned:     :target:   :ninja:      :hammer:   :pirate:  :walter:
:plastered:  :zomg:      :heartbreak:  :ciggie:   :combines:  :crowbar:  :death:      :freeman:  :hecu:    :nya:
```

== Linking

On the web, linking is one of the more useful things you can do. So, of course there are multiple ways you can link to things using WikiCode. To use auto-linking, make sure the URL starts with `http://`. Be careful, because some browsers don't include this by default.

|= Link method | Markup | Result
|- Standard link | [code][url]http://example.com[/url][/code] | [url]http://example.com[/url]
|- Custom link | [code][url=http://example.com]Example link[/url][/code] | [url=http://example.com]Example link[/url]
|- Standard email link | [code][email]test@example.com[/email][/code] | [email]test@example.com[/email]
|- Custom email link | [code][email=test@example.com]Example email link[/email][/code] | [email=test@example.com]Example email link[/email]
|- Quick link | [code][http://example.com][/code] | [http://example.com]
|- Custom quick link | [code][http://example.com|Example link][/code] | [http://example.com|Example link]
|- Link to TWHL wiki page | [code][[Home]][/code] | [[Home]]
|- Custom link to TWHL wiki page | [code][[Home|Example link]][/code] | [[Home|Example link]]
|- Auto-link | `http://example.com` | http://example.com

== Images

Embedding images is another useful thing to do, especially on a wiki. Because it's important, there's a few different ways that images can be added to a post. The output isn't shown in this case because images can take a fair amount of space, but you can experiment by using the preview button when typing a post.

|= Format | Markup | Notes
|- Normal image | [code][img]http://example.com/example.jpg[/img][/code] | Embed a normal image (breaks text top and bottom)
|- Link image | [code][url=http://example.com][img]http://example.com/example.jpg[/img][/url][/code] | Clickable to open a URL
|- Inline image | [code][simg]http://example.com/example.jpg[/simg][/code] | Embed a small image (inline with text)
|- Advanced image | [code][img:http://example.com/example.jpg][/code] | See details on the advanced image format below
|- Link to TWHL wiki image | [code][img:example.jpg][/code] | `example.jpg` is the title of the wiki upload

=== Pasting images

If you have an image on your clipboard (usually from taking a screenshot with the `PrtSc` key, snipping tool in Windows 7, or `Win+Shift+S` in Windows 10), you can press `Ctrl+V` into a TWHL textbox to upload the image and insert the required WikiCode to embed the image. This will not work if you have an image *file* on your clipboard - it must be an actual image.

=== Using the advanced image tag

[img:https://via.placeholder.com/400|url:http://example.com|small|right|This image has a url, the size is 'small', and the position is 'right'.]

Sometimes you wish you had more flexibility when embedding images. Well, now you do! The advanced image tag gives you a few options when adding images to your post.

The syntax can look something like this: [code][img:example.jpg|url:http://example.com|size_modifier|position_modifier|caption_text][/code]

Where every field aside from `img:` is optional. An explanation of each option:

- `url:` - should explain itself. Use this to make the image link to a website when you click on it.
- `size_modifier` - by default, the image tries to fill the width of the page. You can use the size modifier to change it to a fixed size. Valid values are: `thumb`, `small`, `medium`, and `large`.
- `position_modifier` - by default, the image is centered and text will be wrapped above and below the image. You can use the position modifier to change the position and make the text flow around the image. Valid values are `inline`, `left`, `right`, and `center`.
- `caption_text` - if you type anything aside from the values above, it will be treated as a caption to the image. You can only use plain text in the caption.

As an aside, video and audio files may sometimes be uploaded to the wiki. You can embed these files on modern browsers using the advanced image tag. Just replace [code][img:][/code] with [code][video:][/code] or [code][audio:][/code] to use them. You can embed external video and audio as well, but note that some formats are not supported on some browsers, so it might not work for everyone. The safest formats to use are mp3 for audio, and mp4 for video.

== Youtube

[youtube:oGlhgVz5r6E|left|medium|This is the caption text]

Embedding Youtube videos was an often-requested feature in TWHL, and now everybody can do it. To embed the video, you first need to find the video ID. You can find this in the URL of any Youtube video - it's a string of 10 or so letters and numbers. It's underlined in the example below.

youtube.com/watch?v=[u]oGlhgVz5r6E[/u]

Once you have the ID, you can use the [code][youtube][/code] tag to add it to your post:

```plaintext
[youtube]oGlhgVz5r6E[/youtube]
```

You may also use the advanced image syntax. The options are similar to the [code][img:][/code] tag, but you can't use the `url:`, `inline`, or `thumb` options in the tag. An example:

```plaintext
[youtube:oGlhgVz5r6E|left|medium|This is the caption text]
```

== Headings

Headings follow the HTML trend by having six levels. To use a heading, start a new line with `=` symbols. The more symbols you use, the smaller the heading will be.

~~~
= Heading 1 (Largest)
== Heading 2
=== Heading 3
==== Heading 4
===== Heading 5
====== Heading 6 (Smallest)
~~~

These headings are generated by this code:

```plaintext
= Heading 1 (Largest)
== Heading 2
=== Heading 3
==== Heading 4
===== Heading 5
====== Heading 6 (Smallest)
```

== Lists

You can make lists by using `*` for bullet points or `#` for ordered lists. You can create sub-lists by adding extra symbols. You can mix list types on each level.

~~~
* List item 1
* List item 2
** List item 2.1
** List item 2.2

# Step 1
# Step 2
#* Be sure to do step 1 before step 2!
~~~

The markup for the above looks like:

```plaintext
* List item 1
* List item 2
** List item 2.1
** List item 2.2

# Step 1
# Step 2
#* Be sure to do step 1 before step 2!
```

== Quotes

Often you want to quote another user when you are replying to them. Again, there are two different ways to quote users.

&gt; Markdown style quotes
&gt; This is the second line of the quote

The code looks like this:

```plaintext
&gt; Markdown style quotes
&gt; This is the second line of the quote
```

It's important to note that additional lines in the quote must also start with the '&gt;' character.

Quotes can be nested quite easily:

&gt;&gt; This is the parent quote
&gt; This is the child quote

And the markup:

```plaintext
&gt;&gt; This is the parent quote
&gt; This is the child quote
```

The second way to quote users is to use the [code][quote][/code] BBCode tag. These quotes can be nested as well. The new lines are not required, they are simply there to make it easier to read the example.

```plaintext
[quote]
    [quote]This is the parent quote[/quote]
    This is the child quote
[/quote]
```

BBCode quotes have the advantage of adding the name of the person you are quoting:

[quote=GLaDOS]Oh, hi. So, how are you holding up? Because I'm a potato![/quote]

Which can be done like this:

```plaintext
[quote=GLaDOS]Oh, hi. So, how are you holding up? Because I'm a potato![/quote]
```

== Panels

Panels are a simple way to separate some content into its own block. Panels can't be nested within each other, but they can contain any other markup you want. To create a panel, simply mark the start of the content with `~~~`. The end of the panel will be marked by the next line that starts with `~~~`.

If the first line of your panel content starts with `:`, it will be used as the panel title.

~~~
:Panel Title
This is a panel.
The markup for a panel looks like this:
```plaintext
    ~~~
    :Panel Title
    This is a panel.
    ~~~
```
~~~

Panels can have different colours as well. The options are: `message` (green), `info` (blue), `warning` (yellow), and `error` (red). To use these colours, put the option after the `~~~` at the beginning of the panel.

~~~info
:Information Panel
This is an 'informative' panel, it is coloured blue.
The markup for an info panel looks like this:
```plaintext
    ~~~info
    :Information Panel
    This is an 'informative' panel, it is coloured blue.
    ~~~
```
~~~

== Horizontal line

This is a pretty simple one. Simply have a line of text that has nothing but `---`. It'll draw a line that's useful for separating sections of text in a post. It looks like this:

---

== Wiki category

This is the only tag that's specific to the wiki. You can use it in other places, but it will just be ignored. Add this tag to categorise wiki pages. Make sure you spell the category correctly, or the page will link to the wrong category. Here's some examples:

```plaintext
[cat:Put Category Name Here]
[cat:Source Tutorials]
[cat:Requires Further Detail]
```

== Embedded vault

If you're posting on a WIP thread or want to show off your new map or mod, you can embed the map vault item into the post. This is also good for posting example maps on a wiki page. To embed a vault item you need to know the ID of the item. You can find this at the end of the URL on the vault page. For example: twhl.info/vault/view/[u]1234[/u]

Then you put that ID in a vault tag like this:

```plaintext
[vault:1234]
```

The vault item will be added to the page as a screenshot slideshow, along with a link to the item. If you would like to see what it looks like, you can use the post preview function to experiment with this feature.

== Tables

If you want to get really fancy with your post, you can insert a table. The contents of a table can only be inline - for example, inline images, text formatting, links, and so on. You can't put stuff like Youtube videos or quotes in a table.

To create a table, you use one line of text per table row. For a header row, start the line with `|=`. For a normal row, start the line with `|-`. After that, simply enter the contents of each column, separated by a `|` character. For example:

|= Header 1 | Header 2
|- Value 1 | Value 2

This table can be created by typing this:

```plaintext
|= Header 1 | Header 2
|- Value 1  | Value 2
```

== Advanced text formatting

These advanced text formatting techniques are not possible using the Markdown style.

|= Format | BBCode | Notes
|- [font=red]Colour text[/font] | [code][font=red]Colour text[/font][/code] | Can use any colour name from the [https://developer.mozilla.org/en/docs/Web/CSS/color_value#Color_keywords|CSS colour list]
|- [font=#FEA320]Colour text 2[/font] | [code][font=#FEA320]Colour text 2[/font][/code] | Can use any RGB hex value
|- [font size=20]Large text[/font] | [code][font size=20]Large text[/font][/code] | Can use sizes between 6px and 40px
|- [font size=8]Small text[/font] | [code][font size=8]Small text[/font][/code] | The standard text size is 14px
|- [font color=red size=20]Large red text[/font] | [code][font color=red size=20]Large text[/font][/code] | Both size and colour can be combined. Remember to use the American spelling for "color".
|- [spoiler]Spoiler tag[/spoiler] | [code][spoiler]Spoiler tag[/spoiler][/code] | Don't spoil stuff for others!
|- [spoiler=Half-Life]There's a resonance cascade[/spoiler] | [code][spoiler=Half-Life]There's a resonance cascade[/spoiler][/code] | It's polite to specify what game/movie/etc. the spoiler is for

== Code blocks

You may be wondering how those text blocks appeared above without the BBCode inside them being formatted. This is one of the features of a code block - everything inside them is treated as plain text, and not formatted. This is good for posting snippets of code. To post a code block using the Markdown style, surround the code with three backtick characters (that's the ` character). This will align the code block to the left to avoid unnecessary whitespace.

[pre=plaintext]
```
Surround your text with three backticks like this to format it as code.
```
[/pre]

If you don't like backticks for some reason, the BBCode tag you want is [code][pre][/code]. It stands for "preformatted". Unlike backtick blocks, preformatted blocks will retain all whitespace, including at the start of lines.

```plaintext
[pre]All the text inside this tag will be a code block. All whitespace inside this block will be retained.[/pre]
```

=== Syntax highlighting

```js
function javascript() { console.log('hello!'); }
```

TWHL's code highlighting feature will try to detect which programming language your code block contains, but for more control over which language to use, you can specify the language with the following syntax (using `js` as the example language):

```plaintext
[pre=js]function javascript() { console.log('hello!'); }[/pre]

```
[pre=plaintext]
```js
function javascript() { console.log('hello!'); }
```
[/pre]

The following languages are supported:

- PHP - `php`
- Windows batch - `dos`, `bat`, `cmd`
- CSS - `css`
- C++ - `cpp`, `c`, `c++`
- C# - `cs`
- INI config - `ini`
- JSON - `json`
- HTML/XML - `xml`, `html`
- AngelScript - `angelscript`
- JavaScript - `javascript`, `js`
- Force no highlighting - `plaintext`

== Columns

For complex stuff you might want to present some content in columns, side by side. You can do that by using the columns directive. It looks like this:

```plaintext
%%columns=6:3:3
Column 1
%%
Column 2
%%
Column 3
%%
```

Which looks like this:

~~~
%%columns=6:3:3
Column 1
%%
Column 2
%%
Column 3
%%
~~~

Some things to note:

* The column widths are specified in the first line, in this case, `6:3:3`. These numbers are in respect to the page being 12 units wide. The column widths *must* add up to a total of 12 or the columns will not work.
* You need to specify the same number of content sections as columns in the first line, or the columns will not work.
* On small resolution screens (phones, tablets), the columns will show underneath each other instead of side by side.

---

Phew! That's everything! I know there's a lot of stuff here, but don't worry too much about it. If you need to do a particular thing, just come back to this page later so you can refresh your memory.</value>
  </data>
</root>